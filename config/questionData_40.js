const data = {
  questions: [
    {
      uid: "underscorify-substring",
      testStrategy: "JSON",
      name: "Underscorify Substring",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Strings",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 5524,
        failureCount: 2494,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226841994",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 2434,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in two strings: a main string and a potential\n  substring of the main string. The function should return a version of the main\n  string with every instance of the substring in it wrapped between underscores.\n</p>\n<p>\n  If two or more instances of the substring in the main string overlap each\n  other or sit side by side, the underscores relevant to these substrings should\n  only appear on the far left of the leftmost substring and on the far right of\n  the rightmost substring. If the main string doesn\'t contain the other string\n  at all, the function should return the main string intact.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "testthis is a testtest to see if testestest it works"\n<span class="CodeEditor-promptParameter">substring</span> = "test"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"_test_this is a _testtest_ to see if _testestest_ it works"\n</pre>\n</div>',
      hints: [
        "<p>\nThe first thing you need to do to solve this question is to get the locations of all instances of the substring in the main string. Try traversing the main string one character at a time and calling whatever substring-matching function is built into the language you're working in. Store a 2D array of locations, where each subarray holds the starting and ending indices of a specific instance of the substring in the main string.\n</p>\n",
        '\n<p>\nThe second thing you need to do is to "collapse" the 2D array mentioned in Hint #1. In essence, you need to merge the locations of substrings that overlap each other or sit next to each other. Traverse the 2D array mentioned in Hint #1 and build a new 2D array that holds these "collapsed" locations.\n</p>\n',
        '\n<p>\nFinally, you need to create a new string with underscores added in the correct positions. Construct this new string by traversing the main string and the 2D array mentioned in Hint #2 at the same time. You might have to keep track of when you are "in between" underscores in order to correctly traverse the 2D array.\n</p>',
      ],
      spaceTime:
        "Average case: O(n + m) | O(n) space - where n is the length of the main string and m is the length of the substring",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            'using namespace std;\n\nstring underscorifySubstring(string str, string subStr) {\n  // Write your code here.\n  return "";\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nvector<vector<int>> getLocations(string str, string subStr);\nvector<vector<int>> collapse(vector<vector<int>> locations);\nstring underscorify(string str, vector<vector<int>> locations);\n\n// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nstring underscorifySubstring(string str, string subStr) {\n  vector<vector<int>> locations = collapse(getLocations(str, subStr));\n  return underscorify(str, locations);\n}\n\nvector<vector<int>> getLocations(string str, string subStr) {\n  vector<vector<int>> locations{};\n  int startIdx = 0;\n  while (startIdx < str.length()) {\n    int nextIdx = str.find(subStr, startIdx);\n    if (nextIdx != string::npos) {\n      locations.push_back(vector<int>{nextIdx, int(nextIdx + subStr.length())});\n      startIdx = nextIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return locations;\n}\n\nvector<vector<int>> collapse(vector<vector<int>> locations) {\n  if (locations.empty()) {\n    return locations;\n  }\n  vector<vector<int>> newLocations{locations[0]};\n  vector<int> *previous = &newLocations[0];\n  for (int i = 1; i < locations.size(); i++) {\n    vector<int> *current = &locations[i];\n    if (current->at(0) <= previous->at(1)) {\n      previous->at(1) = current->at(1);\n    } else {\n      newLocations.push_back(*current);\n      previous = &newLocations[newLocations.size() - 1];\n    }\n  }\n  return newLocations;\n}\n\nstring underscorify(string str, vector<vector<int>> locations) {\n  int locationsIdx = 0;\n  int stringIdx = 0;\n  bool inBetweenUnderscores = false;\n  vector<string> finalChars{};\n  int i = 0;\n  while (stringIdx < str.length() && locationsIdx < locations.size()) {\n    if (stringIdx == locations[locationsIdx][i]) {\n      finalChars.push_back("_");\n      inBetweenUnderscores = !inBetweenUnderscores;\n      if (!inBetweenUnderscores) {\n        locationsIdx++;\n      }\n      i = i == 1 ? 0 : 1;\n    }\n    string s(1, str[stringIdx]);\n    finalChars.push_back(s);\n    stringIdx++;\n  }\n  if (locationsIdx < locations.size()) {\n    finalChars.push_back("_");\n  } else if (stringIdx < str.length()) {\n    finalChars.push_back(str.substr(stringIdx));\n  }\n  return accumulate(finalChars.begin(), finalChars.end(), string());\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(\n          underscorifySubstring(\n              "testthis is a testtest to see if testestest it works", "test") ==\n          "_test_this is a _testtest_ to see if _testestest_ it works");\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(\n          underscorifySubstring(\n              "testthis is a testtest to see if testestest it works", "test") ==\n          "_test_this is a _testtest_ to see if _testestest_ it works");\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            'using System;\n\npublic class Program {\n\tpublic static string UnderscorifySubstring(string str, string substring) {\n\t\t// Write your code here.\n\t\treturn "";\n\t}\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// Average case: O(n + m) | O(n) space - where n is the length\n\t// of the main string and m is the length of the substring\n\tpublic static string UnderscorifySubstring(string str, string substring) {\n\t\tList<int[]> locations = collapse(getLocations(str, substring));\n\t\treturn underscorify(str, locations);\n\t}\n\n\tpublic static List<int[]> getLocations(string str, string substring) {\n\t\tList<int[]> locations = new List<int[]>();\n\t\tint startIdx = 0;\n\t\twhile (startIdx < str.Length) {\n\t\t\tint nextIdx = str.IndexOf(substring, startIdx);\n\t\t\tif (nextIdx != -1) {\n\t\t\t\tlocations.Add(new int[] {nextIdx, nextIdx + substring.Length});\n\t\t\t\tstartIdx = nextIdx + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tpublic static List<int[]> collapse(List<int[]> locations) {\n\t\tif (locations.Count == 0) {\n\t\t\treturn locations;\n\t\t}\n\t\tList<int[]> newLocations = new List<int[]>();\n\t\tnewLocations.Add(locations[0]);\n\t\tint[] previous = newLocations[0];\n\t\tfor (int i = 1; i < locations.Count; i++) {\n\t\t\tint[] current = locations[i];\n\t\t\tif (current[0] <= previous[1]) {\n\t\t\t\tprevious[1] = current[1];\n\t\t\t} else {\n\t\t\t\tnewLocations.Add(current);\n\t\t\t\tprevious = current;\n\t\t\t}\n\t\t}\n\t\treturn newLocations;\n\t}\n\n\tpublic static string underscorify(string str, List<int[]> locations) {\n\t\tint locationsIdx = 0;\n\t\tint stringIdx = 0;\n\t\tbool inBetweenUnderscores = false;\n\t\tList<string> finalChars = new List<string>();\n\t\tint i = 0;\n\t\twhile (stringIdx < str.Length && locationsIdx < locations.Count) {\n\t\t\tif (stringIdx == locations[locationsIdx][i]) {\n\t\t\t\tfinalChars.Add("_");\n\t\t\t\tinBetweenUnderscores = !inBetweenUnderscores;\n\t\t\t\tif (!inBetweenUnderscores) {\n\t\t\t\t\tlocationsIdx++;\n\t\t\t\t}\n\t\t\t\ti = i == 1 ? 0 : 1;\n\t\t\t}\n\t\t\tfinalChars.Add(str[stringIdx].ToString());\n\t\t\tstringIdx += 1;\n\t\t}\n\t\tif (locationsIdx < locations.Count) {\n\t\t\tfinalChars.Add("_");\n\t\t} else if (stringIdx < str.Length) {\n\t\t\tfinalChars.Add(str.Substring(stringIdx));\n\t\t}\n\t\treturn String.Join("", finalChars);\n\t}\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring expected = "_test_this is a _testtest_ to see if _testestest_ it works";\n\t\tstring output = Program.UnderscorifySubstring(\n\t\t\t"testthis is a testtest to see if testestest it works", "test");\n\t\tUtils.AssertTrue(expected.Equals(output));\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring expected = "_test_this is a _testtest_ to see if _testestest_ it works";\n\t\tstring output = Program.UnderscorifySubstring(\n\t\t\t"testthis is a testtest to see if testestest it works", "test");\n\t\tUtils.AssertTrue(expected.Equals(output));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            'package main\n\nfunc UnderscorifySubstring(str string, substring string) string {\n\t// Write your code here.\n\treturn ""\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport \"strings\"\n\ntype intervals []*interval\ntype interval struct {\n\tleft  int\n\tright int\n}\n\n// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nfunc UnderscorifySubstring(str string, substring string) string {\n\tlocations := getLocations(str, substring)\n\tlocations = locations.collapse()\n\treturn underscorify(str, locations)\n}\n\nfunc getLocations(str, substring string) intervals {\n\tresult := intervals{}\n\tfor start := 0; start < len(str); {\n\t\tnextIndex := strings.Index(str[start:], substring)\n\t\tif nextIndex == -1 {\n\t\t\tbreak\n\t\t}\n\t\tnextIndex += start\n\t\tresult = append(result, &interval{nextIndex, nextIndex + len(substring)})\n\t\tstart = nextIndex + 1\n\t}\n\treturn result\n}\n\nfunc (array intervals) collapse() intervals {\n\t// If the array is empty, nothing to do\n\tif len(array) == 0 {\n\t\treturn array\n\t}\n\n\tresult := intervals{array[0]}\n\tprevious := array[0]\n\tfor i := 1; i < len(array); i++ {\n\t\tcurrent := array[i]\n\t\tif current.left <= previous.right {\n\t\t\t// Collapse the two intervals\n\t\t\tprevious.right = current.right\n\t\t} else {\n\t\t\tresult = append(result, current)\n\t\t\tprevious = current\n\t\t}\n\t}\n\treturn result\n}\n\nfunc underscorify(str string, locations intervals) string {\n\tif len(locations) == 0 {\n\t\treturn str\n\t}\n\n\t// We know the resulting string will have an additional 2*len(intervals)\n\t// characters\n\tresult := make([]rune, len(str)+2*len(locations))\n\tresultIndex := 0\n\tlocationIndex := 0\n\tfor i, r := range str {\n\t\tlocation := locations[locationIndex]\n\t\tif i == location.left {\n\t\t\tresult[resultIndex] = '_'\n\t\t\tresultIndex += 1\n\t\t} else if i == location.right {\n\t\t\tresult[resultIndex] = '_'\n\t\t\tresultIndex += 1\n\t\t\tif locationIndex+1 < len(locations) {\n\t\t\t\tlocationIndex += 1\n\t\t\t}\n\t\t}\n\t\tresult[resultIndex] = r\n\t\tresultIndex += 1\n\t}\n\n\tif locations[locationIndex].right == len(str) {\n\t\tresult[len(result)-1] = '_'\n\t}\n\treturn string(result)\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "_test_this is a _testtest_ to see if _testestest_ it works"\n\toutput := UnderscorifySubstring("testthis is a testtest to see if testestest it works", "test")\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "_test_this is a _testtest_ to see if _testestest_ it works"\n\toutput := UnderscorifySubstring("testthis is a testtest to see if testestest it works", "test")\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            'import java.util.*;\n\nclass Program {\n  public static String underscorifySubstring(String str, String substring) {\n    // Write your code here.\n    return "";\n  }\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // Average case: O(n + m) | O(n) space - where n is the length\n  // of the main string and m is the length of the substring\n  public static String underscorifySubstring(String str, String substring) {\n    List<Integer[]> locations = collapse(getLocations(str, substring));\n    return underscorify(str, locations);\n  }\n\n  public static List<Integer[]> getLocations(String str, String substring) {\n    List<Integer[]> locations = new ArrayList<Integer[]>();\n    int startIdx = 0;\n    while (startIdx < str.length()) {\n      int nextIdx = str.indexOf(substring, startIdx);\n      if (nextIdx != -1) {\n        locations.add(new Integer[] {nextIdx, nextIdx + substring.length()});\n        startIdx = nextIdx + 1;\n      } else {\n        break;\n      }\n    }\n    return locations;\n  }\n\n  public static List<Integer[]> collapse(List<Integer[]> locations) {\n    if (locations.size() == 0) {\n      return locations;\n    }\n    List<Integer[]> newLocations = new ArrayList<Integer[]>();\n    newLocations.add(locations.get(0));\n    Integer[] previous = newLocations.get(0);\n    for (int i = 1; i < locations.size(); i++) {\n      Integer[] current = locations.get(i);\n      if (current[0] <= previous[1]) {\n        previous[1] = current[1];\n      } else {\n        newLocations.add(current);\n        previous = current;\n      }\n    }\n    return newLocations;\n  }\n\n  public static String underscorify(String str, List<Integer[]> locations) {\n    int locationsIdx = 0;\n    int stringIdx = 0;\n    boolean inBetweenUnderscores = false;\n    List<String> finalChars = new ArrayList<String>();\n    int i = 0;\n    while (stringIdx < str.length() && locationsIdx < locations.size()) {\n      if (stringIdx == locations.get(locationsIdx)[i]) {\n        finalChars.add("_");\n        inBetweenUnderscores = !inBetweenUnderscores;\n        if (!inBetweenUnderscores) {\n          locationsIdx++;\n        }\n        i = i == 1 ? 0 : 1;\n      }\n      finalChars.add(String.valueOf(str.charAt(stringIdx)));\n      stringIdx += 1;\n    }\n    if (locationsIdx < locations.size()) {\n      finalChars.add("_");\n    } else if (stringIdx < str.length()) {\n      finalChars.add(str.substring(stringIdx));\n    }\n    return String.join("", finalChars);\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String expected = "_test_this is a _testtest_ to see if _testestest_ it works";\n    String output =\n        Program.underscorifySubstring(\n            "testthis is a testtest to see if testestest it works", "test");\n    Utils.assertTrue(expected.equals(output));\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    String expected = "_test_this is a _testtest_ to see if _testestest_ it works";\n    String output =\n        Program.underscorifySubstring(\n            "testthis is a testtest to see if testestest it works", "test");\n    Utils.assertTrue(expected.equals(output));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function underscorifySubstring(string, substring) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.underscorifySubstring = underscorifySubstring;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nfunction underscorifySubstring(string, substring) {\n  const locations = collapse(getLocations(string, substring));\n  return underscorify(string, locations);\n}\n\nfunction getLocations(string, substring) {\n  const locations = [];\n  let startIdx = 0;\n  while (startIdx < string.length) {\n    const nextIdx = string.indexOf(substring, startIdx);\n    if (nextIdx !== -1) {\n      locations.push([nextIdx, nextIdx + substring.length]);\n      startIdx = nextIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return locations;\n}\n\nfunction collapse(locations) {\n  if (!locations.length) return locations;\n  const newLocations = [locations[0]];\n  let previous = newLocations[0];\n  for (let i = 1; i < locations.length; i++) {\n    const current = locations[i];\n    if (current[0] <= previous[1]) {\n      previous[1] = current[1];\n    } else {\n      newLocations.push(current);\n      previous = current;\n    }\n  }\n  return newLocations;\n}\n\nfunction underscorify(string, locations) {\n  let locationsIdx = 0;\n  let stringIdx = 0;\n  let inBetweenUnderscores = false;\n  const finalChars = [];\n  let i = 0;\n  while (stringIdx < string.length && locationsIdx < locations.length) {\n    if (stringIdx === locations[locationsIdx][i]) {\n      finalChars.push('_');\n      inBetweenUnderscores = !inBetweenUnderscores;\n      if (!inBetweenUnderscores) locationsIdx++;\n      i = i === 1 ? 0 : 1;\n    }\n    finalChars.push(string[stringIdx]);\n    stringIdx++;\n  }\n  if (locationsIdx < locations.length) {\n    finalChars.push('_');\n  } else if (stringIdx < string.length) {\n    finalChars.push(string.slice(stringIdx));\n  }\n  return finalChars.join('');\n}\n\nexports.underscorifySubstring = underscorifySubstring;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'))\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'))\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            'package com.algoexpert.program\n\nfun underscorifySubstring(string: String, substring: String): String {\n    // Write your code here.\n    return ""\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nfun underscorifySubstring(string: String, substring: String): String {\n    val locations = collapse(getLocations(string, substring))\n    return underscorify(string, locations)\n}\n\nfun getLocations(string: String, substring: String): MutableList<MutableList<Int>> {\n    val locations = mutableListOf<MutableList<Int>>()\n    var startIdx = 0\n    while (startIdx < string.length) {\n        val nextIdx = string.indexOf(substring, startIdx)\n        if (nextIdx != -1) {\n            locations.add(mutableListOf(nextIdx, nextIdx + substring.length))\n            startIdx = nextIdx + 1\n        } else {\n            break\n        }\n    }\n    return locations\n}\n\nfun collapse(locations: MutableList<MutableList<Int>>): MutableList<MutableList<Int>> {\n    if (locations.size == 0) return locations\n    val newLocations = mutableListOf(locations[0])\n    var previous = newLocations[0]\n    for (i in 1 until locations.size) {\n        val current = locations[i]\n        if (current[0] <= previous[1]) {\n            previous[1] = current[1]\n        } else {\n            newLocations.add(current)\n            previous = current\n        }\n    }\n    return newLocations\n}\n\nfun underscorify(string: String, locations: MutableList<MutableList<Int>>): String {\n    var locationsIdx = 0\n    var stringIdx = 0\n    var inBetweenUnderscores = false\n    val finalChars = mutableListOf<String>()\n    var i = 0\n    while (stringIdx < string.length && locationsIdx < locations.size) {\n        if (stringIdx == locations[locationsIdx][i]) {\n            finalChars.add("_")\n            inBetweenUnderscores = !inBetweenUnderscores\n            if (!inBetweenUnderscores) locationsIdx++\n            i = if (i == 1) 0 else 1\n        }\n        finalChars.add(string[stringIdx].toString())\n        stringIdx++\n    }\n    if (locationsIdx < locations.size) {\n        finalChars.add("_")\n    } else if (stringIdx < string.length) {\n        finalChars.add(string.substring(stringIdx))\n    }\n    return finalChars.joinToString("")\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.underscorifySubstring as underscorifySubstring\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(underscorifySubstring("testthis is a testtest to see if testestest it works", "test") == "_test_this is a _testtest_ to see if _testestest_ it works")\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.underscorifySubstring as underscorifySubstring\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(underscorifySubstring("testthis is a testtest to see if testestest it works", "test") == "_test_this is a _testtest_ to see if _testestest_ it works")\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def underscorifySubstring(string, substring):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# Average case: O(n + m) | O(n) space - where n is the length\n# of the main string and m is the length of the substring\ndef underscorifySubstring(string, substring):\n    locations = collapse(getLocations(string, substring))\n    return underscorify(string, locations)\n\n\ndef getLocations(string, substring):\n    locations = []\n    startIdx = 0\n    while startIdx < len(string):\n        nextIdx = string.find(substring, startIdx)\n        if nextIdx != -1:\n            locations.append([nextIdx, nextIdx + len(substring)])\n            startIdx = nextIdx + 1\n        else:\n            break\n    return locations\n\n\ndef collapse(locations):\n    if not len(locations):\n        return locations\n    newLocations = [locations[0]]\n    previous = newLocations[0]\n    for i in range(1, len(locations)):\n        current = locations[i]\n        if current[0] <= previous[1]:\n            previous[1] = current[1]\n        else:\n            newLocations.append(current)\n            previous = current\n    return newLocations\n\n\ndef underscorify(string, locations):\n    locationsIdx = 0\n    stringIdx = 0\n    inBetweenUnderscores = False\n    finalChars = []\n    i = 0\n    while stringIdx < len(string) and locationsIdx < len(locations):\n        if stringIdx == locations[locationsIdx][i]:\n            finalChars.append("_")\n            inBetweenUnderscores = not inBetweenUnderscores\n            if not inBetweenUnderscores:\n                locationsIdx += 1\n            i = 0 if i == 1 else 1\n        finalChars.append(string[stringIdx])\n        stringIdx += 1\n    if locationsIdx < len(locations):\n        finalChars.append("_")\n    elif stringIdx < len(string):\n        finalChars.append(string[stringIdx:])\n    return "".join(finalChars)\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.underscorifySubstring("testthis is a testtest to see if testestest it works", "test"),\n            "_test_this is a _testtest_ to see if _testestest_ it works",\n        )\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.underscorifySubstring("testthis is a testtest to see if testestest it works", "test"),\n            "_test_this is a _testtest_ to see if _testestest_ it works",\n        )\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            'class Program\n  def underscorifySubstring(string, substring)\n    # Write your code here.\n    return ""\n  end\nend\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def underscorifySubstring(string, substring)\n    # Write your code here.\n    return ""\n  end\nend\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.underscorifySubstring\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.underscorifySubstring\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            'class Program {\n  func underscorifySubstring(_ string: String, _ substring: String) -> String {\n    // Write your code here.\n    return ""\n  }\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Average case: O(n + m) | O(n) space - where n is the length\n  // of the main string and m is the length of the substring\n  func underscorifySubstring(_ string: String, _ substring: String) -> String {\n    let locations = getLocations(string, substring)\n    let collapsedLocations = collapse(locations)\n\n    return underscorify(string, collapsedLocations)\n  }\n\n  func getLocations(_ string: String, _ substring: String) -> [[String.Index]] {\n    var locations = [[String.Index]]()\n\n    var start = 0\n    var startIndex = string.index(string.startIndex, offsetBy: start)\n\n    while start < string.count {\n      if let rangeOfSubstring = string.range(of: substring, options: [], range: startIndex ..< string.endIndex, locale: nil) {\n        locations.append([rangeOfSubstring.lowerBound, rangeOfSubstring.upperBound])\n\n        let startPos = string.distance(from: string.startIndex, to: rangeOfSubstring.lowerBound)\n        start = startPos + 1\n        startIndex = string.index(string.startIndex, offsetBy: start)\n      } else {\n        break\n      }\n    }\n\n    return locations\n  }\n\n  func collapse(_ locations: [[String.Index]]) -> [[String.Index]] {\n    if locations.count == 0 {\n      return locations\n    }\n\n    var newLocations = [locations[0]]\n    var previousLocationIndex = 0\n    for i in 1 ..< locations.count {\n      let currentLocation = locations[i]\n\n      if currentLocation[0] <= newLocations[previousLocationIndex][1] {\n        newLocations[previousLocationIndex][1] = currentLocation[1]\n      } else {\n        newLocations.append(currentLocation)\n        previousLocationIndex += 1\n      }\n    }\n\n    return newLocations\n  }\n\n  func underscorify(_ string: String, _ locations: [[String.Index]]) -> String {\n    var subIndex = 0\n    var stringIndex = 0\n    var locationIndex = 0\n    var isInBetweenUnderscres = false\n    var currentIndex = string.index(string.startIndex, offsetBy: stringIndex)\n\n    var finalCharacters = [Character]()\n\n    while stringIndex < string.count, locationIndex < locations.count {\n      currentIndex = string.index(string.startIndex, offsetBy: stringIndex)\n\n      if currentIndex == locations[locationIndex][subIndex] {\n        finalCharacters.append("_")\n\n        isInBetweenUnderscres = !isInBetweenUnderscres\n\n        if !isInBetweenUnderscres {\n          locationIndex += 1\n        }\n\n        if subIndex == 0 {\n          subIndex = 1\n        } else {\n          subIndex = 0\n        }\n      }\n\n      finalCharacters.append(string[currentIndex])\n      stringIndex += 1\n    }\n\n    if locationIndex < locations.count {\n      finalCharacters.append("_")\n    } else if stringIndex < string.count {\n      currentIndex = string.index(string.startIndex, offsetBy: stringIndex)\n      let restOfCharacters = Array(string[currentIndex ..< string.endIndex])\n      finalCharacters.append(contentsOf: restOfCharacters)\n    }\n\n    let result = finalCharacters.compactMap { String($0) }.joined()\n    return result\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("_test_this is a _testtest_ to see if _testestest_ it works", program.underscorifySubstring("testthis is a testtest to see if testestest it works", "test"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("_test_this is a _testtest_ to see if _testestest_ it works", program.underscorifySubstring("testthis is a testtest to see if testestest it works", "test"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function underscorifySubstring(string: string, substring: string) {\n  // Write your code here.\n  return '';\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nexport function underscorifySubstring(string: string, substring: string) {\n  const locations = collapse(getLocations(string, substring));\n  return underscorify(string, locations);\n}\n\nfunction getLocations(string: string, substring: string) {\n  const locations: number[][] = [];\n  let startIdx = 0;\n  while (startIdx < string.length) {\n    const nextIdx = string.indexOf(substring, startIdx);\n    if (nextIdx !== -1) {\n      locations.push([nextIdx, nextIdx + substring.length]);\n      startIdx = nextIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return locations;\n}\n\nfunction collapse(locations: number[][]) {\n  if (!locations.length) return locations;\n  const newLocations = [locations[0]];\n  let previous = newLocations[0];\n  for (let i = 1; i < locations.length; i++) {\n    const current = locations[i];\n    if (current[0] <= previous[1]) {\n      previous[1] = current[1];\n    } else {\n      newLocations.push(current);\n      previous = current;\n    }\n  }\n  return newLocations;\n}\n\nfunction underscorify(string: string, locations: number[][]) {\n  let locationsIdx = 0;\n  let stringIdx = 0;\n  let inBetweenUnderscores = false;\n  const finalChars = [];\n  let i = 0;\n  while (stringIdx < string.length && locationsIdx < locations.length) {\n    if (stringIdx === locations[locationsIdx][i]) {\n      finalChars.push('_');\n      inBetweenUnderscores = !inBetweenUnderscores;\n      if (!inBetweenUnderscores) locationsIdx++;\n      i = i === 1 ? 0 : 1;\n    }\n    finalChars.push(string[stringIdx]);\n    stringIdx++;\n  }\n  if (locationsIdx < locations.length) {\n    finalChars.push('_');\n  } else if (stringIdx < string.length) {\n    finalChars.push(string.slice(stringIdx));\n  }\n  return finalChars.join('');\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'))\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'))\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "testthis is a testtest to see if testestest it works",
          schema: {
            type: "string",
          },
        },
        {
          name: "substring",
          example: "test",
          schema: {
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "testthis is a testtest to see if testestest it works",
          substring: "test",
        },
        {
          string: "this is a test to see if it works",
          substring: "test",
        },
        {
          string: "test this is a test to see if it works",
          substring: "test",
        },
        {
          string: "testthis is a test to see if it works",
          substring: "test",
        },
        {
          string: "testthis is a testest to see if testestes it works",
          substring: "test",
        },
        {
          string: "this is a test to see if it works and test",
          substring: "test",
        },
        {
          string: "this is a test to see if it works and test",
          substring: "bfjawkfja",
        },
        {
          string: "ttttttttttttttbtttttctatawtatttttastvb",
          substring: "ttt",
        },
        {
          string: "tzttztttz",
          substring: "ttt",
        },
        {
          string: "abababababababababababababaababaaabbababaa",
          substring: "a",
        },
        {
          string: "abcabcabcabcabcabcabcabcabcabcabcabcabcabc",
          substring: "abc",
        },
      ],
      jsonTests: [
        {
          string: "testthis is a testtest to see if testestest it works",
          substring: "test",
        },
        {
          string: "this is a test to see if it works",
          substring: "test",
        },
        {
          string: "test this is a test to see if it works",
          substring: "test",
        },
        {
          string: "testthis is a test to see if it works",
          substring: "test",
        },
        {
          string: "testthis is a testest to see if testestes it works",
          substring: "test",
        },
        {
          string: "this is a test to see if it works and test",
          substring: "test",
        },
        {
          string: "this is a test to see if it works and test",
          substring: "bfjawkfja",
        },
        {
          string: "ttttttttttttttbtttttctatawtatttttastvb",
          substring: "ttt",
        },
        {
          string: "tzttztttz",
          substring: "ttt",
        },
        {
          string: "abababababababababababababaababaaabbababaa",
          substring: "a",
        },
        {
          string: "abcabcabcabcabcabcabcabcabcabcabcabcabcabc",
          substring: "abc",
        },
      ],
      changelog: [],
      id: 1,
    },
    {
      uid: "quick-sort",
      testStrategy: "JSON",
      name: "Quick Sort",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Sorting",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 13217,
        failureCount: 4933,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "241820219",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 2137,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Quick Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Quick Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
      hints: [
        "<p>\nQuick Sort works by picking a \"pivot\" number from an array, positioning every other number in the array in sorted order with respect to the pivot (all smaller numbers to the pivot's left; all bigger numbers to the pivot's right), and then repeating the same two steps on both sides of the pivot until the entire array is sorted.\n</p>\n",
        "\n<p>\nPick a random number from the input array (the first number, for instance) and let that number be the pivot. Iterate through the rest of the array using two pointers, one starting at the left extremity of the array and progressively moving to the right, and the other one starting at the right extremity of the array and progressively moving to the left. As you iterate through the array, compare the left and right pointer numbers to the pivot. If the left number is greater than the pivot and the right number is less than the pivot, swap them; this will effectively sort these numbers with respect to the pivot at the end of the iteration. If the left number is ever less than or equal to the pivot, increment the left pointer; similarly, if the right number is ever greater than or equal to the pivot, decrement the right pointer. Do this until the pointers pass each other, at which point swapping the pivot with the right number should position the pivot in its final, sorted position, where every number to its left is smaller and every number to its right is greater.\n</p>\n",
        "\n<p>\nRepeat the process mentioned in Hint #2 on the respective subarrays located to the left and right of your pivot, and keep on repeating the process thereafter until the input array is fully sorted.\n</p>",
      ],
      spaceTime:
        "Best: O(nlog(n)) time | O(log(n)) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(log(n)) space - where n is the length of the input array\nWorst: O(n^2) time | O(log(n)) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> quickSort(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid quickSortHelper(vector<int> &array, int startIdx, int endIdx);\n\n// Best: O(nlog(n)) time | O(log(n)) space\n// Average: O(nlog(n)) time | O(log(n)) space\n// Worst: O(n^2) time | O(log(n)) space\nvector<int> quickSort(vector<int> array) {\n  quickSortHelper(array, 0, array.size() - 1);\n  return array;\n}\n\nvoid quickSortHelper(vector<int> &array, int startIdx, int endIdx) {\n  if (startIdx >= endIdx) {\n    return;\n  }\n  int pivotIdx = startIdx;\n  int leftIdx = startIdx + 1;\n  int rightIdx = endIdx;\n  while (rightIdx >= leftIdx) {\n    if (array.at(leftIdx) > array.at(pivotIdx) &&\n        array.at(rightIdx) < array.at(pivotIdx)) {\n      swap(array[leftIdx], array[rightIdx]);\n    }\n    if (array.at(leftIdx) <= array.at(pivotIdx)) {\n      leftIdx += 1;\n    }\n    if (array.at(rightIdx) >= array.at(pivotIdx)) {\n      rightIdx -= 1;\n    }\n  }\n  swap(array[pivotIdx], array[rightIdx]);\n  bool leftSubarrayIsSmaller =\n      rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n  if (leftSubarrayIsSmaller) {\n    quickSortHelper(array, startIdx, rightIdx - 1);\n    quickSortHelper(array, rightIdx + 1, endIdx);\n  } else {\n    quickSortHelper(array, rightIdx + 1, endIdx);\n    quickSortHelper(array, startIdx, rightIdx - 1);\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(quickSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(quickSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] QuickSort(int[] array) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// Best: O(nlog(n)) time | O(log(n)) space\n\t// Average: O(nlog(n)) time | O(log(n)) space\n\t// Worst: O(n^2) time | O(log(n)) space\n\tpublic static int[] QuickSort(int[] array) {\n\t\tQuickSort(array, 0, array.Length - 1);\n\t\treturn array;\n\t}\n\n\tpublic static void QuickSort(int[] array, int startIdx, int endIdx) {\n\t\tif (startIdx >= endIdx) {\n\t\t\treturn;\n\t\t}\n\t\tint pivotIdx = startIdx;\n\t\tint leftIdx = startIdx + 1;\n\t\tint rightIdx = endIdx;\n\t\twhile (rightIdx >= leftIdx) {\n\t\t\tif (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n\t\t\t\tswap(leftIdx, rightIdx, array);\n\t\t\t}\n\t\t\tif (array[leftIdx] <= array[pivotIdx]) {\n\t\t\t\tleftIdx += 1;\n\t\t\t}\n\t\t\tif (array[rightIdx] >= array[pivotIdx]) {\n\t\t\t\trightIdx -= 1;\n\t\t\t}\n\t\t}\n\t\tswap(pivotIdx, rightIdx, array);\n\t\tbool leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n\t\tif (leftSubarrayIsSmaller) {\n\t\t\tQuickSort(array, startIdx, rightIdx - 1);\n\t\t\tQuickSort(array, rightIdx + 1, endIdx);\n\t\t} else {\n\t\t\tQuickSort(array, rightIdx + 1, endIdx);\n\t\t\tQuickSort(array, startIdx, rightIdx - 1);\n\t\t}\n\t}\n\n\tpublic static void swap(int i, int j, int[] array) {\n\t\tint temp  = array[j];\n\t\tarray[j] = array[i];\n\t\tarray[i] = temp;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {2, 3, 5, 5, 6, 8, 9};\n\t\tint[] input = {8, 5, 2, 9, 5, 6, 3};\n\t\tUtils.AssertTrue(compare(Program.QuickSort(input), expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {2, 3, 5, 5, 6, 8, 9};\n\t\tint[] input = {8, 5, 2, 9, 5, 6, 3};\n\t\tUtils.AssertTrue(compare(Program.QuickSort(input), expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc QuickSort(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nfunc QuickSort(array []int) []int {\n\treturn helper(array, 0, len(array)-1)\n}\n\nfunc helper(array []int, start, end int) []int {\n\tif start >= end {\n\t\treturn array\n\t}\n\n\tpivot := start\n\tleft := start + 1\n\tright := end\n\tfor right >= left {\n\t\tif array[left] > array[pivot] && array[right] < array[pivot] {\n\t\t\tarray[left], array[right] = array[right], array[left]\n\t\t}\n\t\tif array[left] <= array[pivot] {\n\t\t\tleft += 1\n\t\t}\n\t\tif array[right] >= array[pivot] {\n\t\t\tright -= 1\n\t\t}\n\t}\n\n\tarray[pivot], array[right] = array[right], array[pivot]\n\n\tif right-1-start < end-(right+1) {\n\t\thelper(array, start, right-1)\n\t\thelper(array, right+1, end)\n\t} else {\n\t\thelper(array, right+1, end)\n\t\thelper(array, start, right-1)\n\t}\n\treturn array\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := QuickSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := QuickSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] quickSort(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time | O(log(n)) space\n  // Average: O(nlog(n)) time | O(log(n)) space\n  // Worst: O(n^2) time | O(log(n)) space\n  public static int[] quickSort(int[] array) {\n    quickSort(array, 0, array.length - 1);\n    return array;\n  }\n\n  public static void quickSort(int[] array, int startIdx, int endIdx) {\n    if (startIdx >= endIdx) {\n      return;\n    }\n    int pivotIdx = startIdx;\n    int leftIdx = startIdx + 1;\n    int rightIdx = endIdx;\n    while (rightIdx >= leftIdx) {\n      if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n        swap(leftIdx, rightIdx, array);\n      }\n      if (array[leftIdx] <= array[pivotIdx]) {\n        leftIdx += 1;\n      }\n      if (array[rightIdx] >= array[pivotIdx]) {\n        rightIdx -= 1;\n      }\n    }\n    swap(pivotIdx, rightIdx, array);\n    boolean leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n    if (leftSubarrayIsSmaller) {\n      quickSort(array, startIdx, rightIdx - 1);\n      quickSort(array, rightIdx + 1, endIdx);\n    } else {\n      quickSort(array, rightIdx + 1, endIdx);\n      quickSort(array, startIdx, rightIdx - 1);\n    }\n  }\n\n  public static void swap(int i, int j, int[] array) {\n    int temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.quickSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.quickSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function quickSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.quickSort = quickSort;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(log(n)) space\n// Average: O(nlog(n)) time | O(log(n)) space\n// Worst: O(n^2) time | O(log(n)) space\nfunction quickSort(array) {\n  quickSortHelper(array, 0, array.length - 1);\n  return array;\n}\n\nfunction quickSortHelper(array, startIdx, endIdx) {\n  if (startIdx >= endIdx) return;\n  const pivotIdx = startIdx;\n  let leftIdx = startIdx + 1;\n  let rightIdx = endIdx;\n  while (rightIdx >= leftIdx) {\n    if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n      swap(leftIdx, rightIdx, array);\n    }\n    if (array[leftIdx] <= array[pivotIdx]) leftIdx++;\n    if (array[rightIdx] >= array[pivotIdx]) rightIdx--;\n  }\n  swap(pivotIdx, rightIdx, array);\n  const leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n  if (leftSubarrayIsSmaller) {\n    quickSortHelper(array, startIdx, rightIdx - 1);\n    quickSortHelper(array, rightIdx + 1, endIdx);\n  } else {\n    quickSortHelper(array, rightIdx + 1, endIdx);\n    quickSortHelper(array, startIdx, rightIdx - 1);\n  }\n}\n\nfunction swap(i, j, array) {\n  let temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.quickSort = quickSort;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun quickSort(array: MutableList<Int>): List<Int> {\n    // Write your code here.\n    return array\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Best: O(nlog(n)) time | O(log(n)) space\n// Average: O(nlog(n)) time | O(log(n)) space\n// Worst: O(n^2) time | O(log(n)) space\nfun quickSort(array: MutableList<Int>): List<Int> {\n    quickSortHelper(array, 0, array.size - 1)\n    return array\n}\n\nfun quickSortHelper(array: MutableList<Int>, startIdx: Int, endIdx: Int) {\n    if (startIdx >= endIdx) return\n    val pivotIdx = startIdx\n    var leftIdx = startIdx + 1\n    var rightIdx = endIdx\n    while (rightIdx >= leftIdx) {\n        if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n            swap(leftIdx, rightIdx, array)\n        }\n        if (array[leftIdx] <= array[pivotIdx]) leftIdx++\n        if (array[rightIdx] >= array[pivotIdx]) rightIdx--\n    }\n    swap(pivotIdx, rightIdx, array)\n    val leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1)\n    if (leftSubarrayIsSmaller) {\n        quickSortHelper(array, startIdx, rightIdx - 1)\n        quickSortHelper(array, rightIdx + 1, endIdx)\n    } else {\n        quickSortHelper(array, rightIdx + 1, endIdx)\n        quickSortHelper(array, startIdx, rightIdx - 1)\n    }\n}\n\nfun swap(i: Int, j: Int, array: MutableList<Int>) {\n    val temp = array[j]\n    array[j] = array[i]\n    array[i] = temp\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.quickSort as quickSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(quickSort(input) == expected)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.quickSort as quickSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(quickSort(input) == expected)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def quickSort(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# Best: O(nlog(n)) time | O(log(n)) space\n# Average: O(nlog(n)) time | O(log(n)) space\n# Worst: O(n^2) time | O(log(n)) space\ndef quickSort(array):\n    quickSortHelper(array, 0, len(array) - 1)\n    return array\n\n\ndef quickSortHelper(array, startIdx, endIdx):\n    if startIdx >= endIdx:\n        return\n    pivotIdx = startIdx\n    leftIdx = startIdx + 1\n    rightIdx = endIdx\n    while rightIdx >= leftIdx:\n        if array[leftIdx] > array[pivotIdx] and array[rightIdx] < array[pivotIdx]:\n            swap(leftIdx, rightIdx, array)\n        if array[leftIdx] <= array[pivotIdx]:\n            leftIdx += 1\n        if array[rightIdx] >= array[pivotIdx]:\n            rightIdx -= 1\n    swap(pivotIdx, rightIdx, array)\n    leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1)\n    if leftSubarrayIsSmaller:\n        quickSortHelper(array, startIdx, rightIdx - 1)\n        quickSortHelper(array, rightIdx + 1, endIdx)\n    else:\n        quickSortHelper(array, rightIdx + 1, endIdx)\n        quickSortHelper(array, startIdx, rightIdx - 1)\n\n\ndef swap(i, j, array):\n    array[i], array[j] = array[j], array[i]\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.quickSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.quickSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def quickSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def quickSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.quickSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.quickSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func quickSort(_ array: inout [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time | O(log(n)) space\n  // Average: O(nlog(n)) time | O(log(n)) space\n  // Worst: O(n^2) time | O(log(n)) space\n  func quickSort(_ array: inout [Int]) -> [Int] {\n    quickSortHelper(&array, 0, array.count - 1)\n    return array\n  }\n\n  func quickSortHelper(_ array: inout [Int], _ startIndex: Int, _ endIndex: Int) {\n    if startIndex >= endIndex {\n      return\n    }\n\n    let pivotIndex = startIndex\n    var leftPointer = startIndex + 1\n    var rightPointer = endIndex\n\n    while leftPointer <= rightPointer {\n      if array[leftPointer] > array[pivotIndex], array[rightPointer] < array[pivotIndex] {\n        swap(&array, leftPointer, rightPointer)\n      }\n\n      if array[leftPointer] <= array[pivotIndex] {\n        leftPointer += 1\n      }\n\n      if array[rightPointer] >= array[pivotIndex] {\n        rightPointer -= 1\n      }\n    }\n\n    swap(&array, pivotIndex, rightPointer)\n\n    let leftLength = rightPointer - 1 - startIndex\n    let rightLength = endIndex - rightPointer + 1\n\n    let leftSubArrayIsSmaller = leftLength < rightLength\n\n    if leftSubArrayIsSmaller {\n      quickSortHelper(&array, startIndex, rightPointer - 1)\n      quickSortHelper(&array, rightPointer + 1, endIndex)\n    } else {\n      quickSortHelper(&array, rightPointer + 1, endIndex)\n      quickSortHelper(&array, startIndex, rightPointer - 1)\n    }\n  }\n\n  func swap(_ array: inout [Int], _ leftPointer: Int, _ rightPointer: Int) {\n    let temp = array[leftPointer]\n\n    array[leftPointer] = array[rightPointer]\n    array[rightPointer] = temp\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.quickSort(&arrayToSort))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.quickSort(&arrayToSort))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function quickSort(array: number[]) {\n  // Write your code here.\n  return array;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(log(n)) space\n// Average: O(nlog(n)) time | O(log(n)) space\n// Worst: O(n^2) time | O(log(n)) space\nexport function quickSort(array: number[]) {\n  quickSortHelper(array, 0, array.length - 1);\n  return array;\n}\n\nfunction quickSortHelper(array: number[], startIdx: number, endIdx: number) {\n  if (startIdx >= endIdx) return;\n  const pivotIdx = startIdx;\n  let leftIdx = startIdx + 1;\n  let rightIdx = endIdx;\n  while (rightIdx >= leftIdx) {\n    if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n      swap(leftIdx, rightIdx, array);\n    }\n    if (array[leftIdx] <= array[pivotIdx]) leftIdx++;\n    if (array[rightIdx] >= array[pivotIdx]) rightIdx--;\n  }\n  swap(pivotIdx, rightIdx, array);\n  const leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n  if (leftSubarrayIsSmaller) {\n    quickSortHelper(array, startIdx, rightIdx - 1);\n    quickSortHelper(array, rightIdx + 1, endIdx);\n  } else {\n    quickSortHelper(array, rightIdx + 1, endIdx);\n    quickSortHelper(array, startIdx, rightIdx - 1);\n  }\n}\n\nfunction swap(i: number, j: number, array: number[]) {\n  let temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [8, 5, 2, 9, 5, 6, 3],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [8, 5, 2, 9, 5, 6, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 3, 2],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [
            -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6,
            -7, 8,
          ],
        },
        {
          array: [
            -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
          ],
        },
        {
          array: [
            8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2,
            7, -2, 4,
          ],
        },
        {
          array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1],
        },
        {
          array: [
            2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9,
            8, 1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
          ],
        },
        {
          array: [
            4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
            -2, -7, 4,
          ],
        },
        {
          array: [
            427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246,
            12, -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348,
            -474, -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565,
            892, 970, -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
          ],
        },
        {
          array: [
            991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998,
            847, 80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435,
            -269, 652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980,
            913, -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519,
            906,
          ],
        },
        {
          array: [
            384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
            -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204,
            776, -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367,
            -609, 662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67,
            -389, 508, 777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755,
            -978, 515, -68, -559, 489, 732, -19, -489, 737, 924,
          ],
        },
        {
          array: [
            544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
            -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
            -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568,
            -702, 551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153,
            788, 844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150,
            -656, 528, 61, 94, -581,
          ],
        },
        {
          array: [
            -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
            268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437,
            -453, -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67,
            834, 619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296,
            -90, 401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505,
            -415, -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373,
            915, -885, 879, 391, -158, 588, -641, -937, 986, 949, -321,
          ],
        },
        {
          array: [
            -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
            842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
            -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
            892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
            341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800,
            -950, -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265,
            746, 355, -578, -441, -254, -941, -738, -469, -167, -420, -126,
            -410, 59,
          ],
        },
      ],
      jsonTests: [
        {
          array: [8, 5, 2, 9, 5, 6, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 3, 2],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [
            -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6,
            -7, 8,
          ],
        },
        {
          array: [
            -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
          ],
        },
        {
          array: [
            8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2,
            7, -2, 4,
          ],
        },
        {
          array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1],
        },
        {
          array: [
            2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9,
            8, 1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
          ],
        },
        {
          array: [
            4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
            -2, -7, 4,
          ],
        },
        {
          array: [
            427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246,
            12, -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348,
            -474, -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565,
            892, 970, -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
          ],
        },
        {
          array: [
            991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998,
            847, 80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435,
            -269, 652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980,
            913, -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519,
            906,
          ],
        },
        {
          array: [
            384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
            -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204,
            776, -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367,
            -609, 662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67,
            -389, 508, 777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755,
            -978, 515, -68, -559, 489, 732, -19, -489, 737, 924,
          ],
        },
        {
          array: [
            544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
            -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
            -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568,
            -702, 551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153,
            788, 844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150,
            -656, 528, 61, 94, -581,
          ],
        },
        {
          array: [
            -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
            268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437,
            -453, -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67,
            834, 619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296,
            -90, 401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505,
            -415, -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373,
            915, -885, 879, 391, -158, 588, -641, -937, 986, 949, -321,
          ],
        },
        {
          array: [
            -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
            842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
            -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
            892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
            341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800,
            -950, -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265,
            746, 355, -578, -441, -254, -941, -738, -469, -167, -420, -126,
            -410, 59,
          ],
        },
      ],
      changelog: [],
      id: 2,
    },
    {
      uid: "heap-sort",
      testStrategy: "JSON",
      name: "Heap Sort",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Sorting",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 6622,
        failureCount: 2299,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "227727990",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 988,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Heap Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Heap Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
      hints: [
        "<p>\nDivide the input array into two subarrays in place. The second subarray should be sorted at all times and should start with a length of 0, while the first subarray should be transformed into a max (or min) heap and should satisfy the heap property at all times.\n</p>\n",
        '\n<p>\nNote that the largest (or smallest) value of the heap should be at the very beginning of the newly-built heap. Start by swapping this value with the last value in the heap; the largest (or smallest) value in the array should now be in its correct position in the sorted subarray, which should now have a length of 1; the heap should now be one element smaller, with its first element out of place. Apply the "sift down" method of the heap to re-position this out-of-place value.\n</p>\n',
        "\n<p>\nRepeat the step mentioned in Hint #2 until the heap is left with only one value, at which point the entire array should be sorted.\n</p>",
      ],
      spaceTime:
        "Best: O(nlog(n)) time | O(1) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(1) space - where n is the length of the input array\nWorst: O(nlog(n)) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> heapSort(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid buildMaxHeap(vector<int> &array);\nvoid siftDown(int currentIdx, int endIdx, vector<int> &heap);\n\n// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nvector<int> heapSort(vector<int> array) {\n  buildMaxHeap(array);\n  for (int endIdx = array.size() - 1; endIdx > 0; endIdx--) {\n    swap(array[0], array[endIdx]);\n    siftDown(0, endIdx - 1, array);\n  }\n  return array;\n}\n\nvoid buildMaxHeap(vector<int> &array) {\n  int firstParentIdx = (array.size() - 2) / 2;\n  for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    siftDown(currentIdx, array.size() - 1, array);\n  }\n}\n\nvoid siftDown(int currentIdx, int endIdx, vector<int> &heap) {\n  int childOneIdx = currentIdx * 2 + 1;\n  while (childOneIdx <= endIdx) {\n    int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    int idxToSwap;\n    if (childTwoIdx != -1 && heap.at(childTwoIdx) > heap.at(childOneIdx)) {\n      idxToSwap = childTwoIdx;\n    } else {\n      idxToSwap = childOneIdx;\n    }\n    if (heap.at(idxToSwap) > heap.at(currentIdx)) {\n      swap(heap[currentIdx], heap[idxToSwap]);\n      currentIdx = idxToSwap;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(heapSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected = {2, 3, 5, 5, 6, 8, 9};\n      assert(heapSort({8, 5, 2, 9, 5, 6, 3}) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] HeapSort(int[] array) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// Best: O(nlog(n)) time | O(1) space\n\t// Average: O(nlog(n)) time | O(1) space\n\t// Worst: O(nlog(n)) time | O(1) space\n\tpublic static int[] HeapSort(int[] array) {\n\t\tbuildMaxHeap(array);\n\t\tfor (int endIdx = array.Length - 1; endIdx > 0; endIdx--) {\n\t\t\tswap(0, endIdx, array);\n\t\t\tsiftDown(0, endIdx - 1, array);\n\t\t}\n\t\treturn array;\n\t}\n\n\tpublic static void buildMaxHeap(int[] array) {\n\t\tint firstParentIdx = (array.Length - 2) / 2;\n\t\tfor (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n\t\t\tsiftDown(currentIdx, array.Length - 1, array);\n\t\t}\n\t}\n\n\tpublic static void siftDown(int currentIdx, int endIdx, int[] heap) {\n\t\tint childOneIdx = currentIdx * 2 + 1;\n\t\twhile (childOneIdx <= endIdx) {\n\t\t\tint childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n\t\t\tint idxToSwap;\n\t\t\tif (childTwoIdx != -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n\t\t\t\tidxToSwap = childTwoIdx;\n\t\t\t} else {\n\t\t\t\tidxToSwap = childOneIdx;\n\t\t\t}\n\t\t\tif (heap[idxToSwap] > heap[currentIdx]) {\n\t\t\t\tswap(currentIdx, idxToSwap, heap);\n\t\t\t\tcurrentIdx = idxToSwap;\n\t\t\t\tchildOneIdx = currentIdx * 2 + 1;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void swap(int i, int j, int[] array) {\n\t\tint temp = array[j];\n\t\tarray[j] = array[i];\n\t\tarray[i] = temp;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {2, 3, 5, 5, 6, 8, 9};\n\t\tint[] input = {8, 5, 2, 9, 5, 6, 3};\n\t\tUtils.AssertTrue(compare(Program.HeapSort(input), expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {2, 3, 5, 5, 6, 8, 9};\n\t\tint[] input = {8, 5, 2, 9, 5, 6, 3};\n\t\tUtils.AssertTrue(compare(Program.HeapSort(input), expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc HeapSort(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nfunc HeapSort(array []int) []int {\n\tbuildMaxHeap(array)\n\tfor endIndex := len(array) - 1; endIndex >= 1; endIndex-- {\n\t\tswap(0, endIndex, array)\n\t\tsiftDown(0, endIndex-1, array)\n\t}\n\treturn array\n}\n\nfunc buildMaxHeap(array []int) {\n\tfirst := (len(array) - 2) / 2\n\tfor currentIndex := first + 1; currentIndex >= 0; currentIndex-- {\n\t\tsiftDown(currentIndex, len(array)-1, array)\n\t}\n}\n\nfunc siftDown(currentIndex int, endIndex int, heap []int) {\n\tchildOneIndex := currentIndex*2 + 1\n\tfor childOneIndex <= endIndex {\n\t\tchildTwoIndex := -1\n\t\tif currentIndex*2+2 <= endIndex {\n\t\t\tchildTwoIndex = currentIndex*2 + 2\n\t\t}\n\t\tindexToSwap := childOneIndex\n\t\tif childTwoIndex > -1 && heap[childTwoIndex] > heap[childOneIndex] {\n\t\t\tindexToSwap = childTwoIndex\n\t\t}\n\t\tif heap[indexToSwap] > heap[currentIndex] {\n\t\t\tswap(currentIndex, indexToSwap, heap)\n\t\t\tcurrentIndex = indexToSwap\n\t\t\tchildOneIndex = currentIndex*2 + 1\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc swap(i, j int, array []int) {\n\tarray[i], array[j] = array[j], array[i]\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := HeapSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{2, 3, 5, 5, 6, 8, 9}\n\toutput := HeapSort([]int{8, 5, 2, 9, 5, 6, 3})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] heapSort(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time | O(1) space\n  // Average: O(nlog(n)) time | O(1) space\n  // Worst: O(nlog(n)) time | O(1) space\n  public static int[] heapSort(int[] array) {\n    buildMaxHeap(array);\n    for (int endIdx = array.length - 1; endIdx > 0; endIdx--) {\n      swap(0, endIdx, array);\n      siftDown(0, endIdx - 1, array);\n    }\n    return array;\n  }\n\n  public static void buildMaxHeap(int[] array) {\n    int firstParentIdx = (array.length - 2) / 2;\n    for (int currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      siftDown(currentIdx, array.length - 1, array);\n    }\n  }\n\n  public static void siftDown(int currentIdx, int endIdx, int[] heap) {\n    int childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      int childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      int idxToSwap;\n      if (childTwoIdx != -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] > heap[currentIdx]) {\n        swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  public static void swap(int i, int j, int[] array) {\n    int temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.heapSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {2, 3, 5, 5, 6, 8, 9};\n    int[] input = {8, 5, 2, 9, 5, 6, 3};\n    Utils.assertTrue(compare(Program.heapSort(input), expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function heapSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.heapSort = heapSort;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nfunction heapSort(array) {\n  buildMaxHeap(array);\n  for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n    swap(0, endIdx, array);\n    siftDown(0, endIdx - 1, array);\n  }\n  return array;\n}\n\nfunction buildMaxHeap(array) {\n  const firstParentIdx = Math.floor((array.length - 2) / 2);\n  for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    siftDown(currentIdx, array.length - 1, array);\n  }\n}\n\nfunction siftDown(currentIdx, endIdx, heap) {\n  let childOneIdx = currentIdx * 2 + 1;\n  while (childOneIdx <= endIdx) {\n    const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    let idxToSwap;\n    if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n      idxToSwap = childTwoIdx;\n    } else {\n      idxToSwap = childOneIdx;\n    }\n    if (heap[idxToSwap] > heap[currentIdx]) {\n      swap(currentIdx, idxToSwap, heap);\n      currentIdx = idxToSwap;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.heapSort = heapSort;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun heapSort(array: MutableList<Int>): List<Int> {\n    // Write your code here.\n    return array\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nfun heapSort(array: MutableList<Int>): List<Int> {\n    buildMaxHeap(array)\n    for (endIdx in array.size - 1 downTo 1) {\n        swap(0, endIdx, array)\n        siftDown(0, endIdx - 1, array)\n    }\n    return array\n}\n\nfun buildMaxHeap(array: MutableList<Int>) {\n    val firstParentIdx = (array.size - 2) / 2\n    for (currentIdx in firstParentIdx downTo 0) {\n        siftDown(currentIdx, array.size - 1, array)\n    }\n}\n\nfun siftDown(currentIdx: Int, endIdx: Int, heap: MutableList<Int>) {\n    var newCurrentIdx = currentIdx\n    var childOneIdx = currentIdx * 2 + 1\n    while (childOneIdx <= endIdx) {\n        val childTwoIdx = if (newCurrentIdx * 2 + 2 <= endIdx) newCurrentIdx * 2 + 2 else -1\n        var idxToSwap: Int\n        if (childTwoIdx != -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n            idxToSwap = childTwoIdx\n        } else {\n            idxToSwap = childOneIdx\n        }\n        if (heap[idxToSwap] > heap[newCurrentIdx]) {\n            swap(newCurrentIdx, idxToSwap, heap)\n            newCurrentIdx = idxToSwap\n            childOneIdx = newCurrentIdx * 2 + 1\n        } else {\n            return\n        }\n    }\n}\n\nfun swap(i: Int, j: Int, array: MutableList<Int>) {\n    val temp = array[j]\n    array[j] = array[i]\n    array[i] = temp\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.heapSort as heapSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(heapSort(input) == expected)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.heapSort as heapSort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = mutableListOf(2, 3, 5, 5, 6, 8, 9)\n        val input = mutableListOf(8, 5, 2, 9, 5, 6, 3)\n        assert(heapSort(input) == expected)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def heapSort(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# Best: O(nlog(n)) time | O(1) space\n# Average: O(nlog(n)) time | O(1) space\n# Worst: O(nlog(n)) time | O(1) space\ndef heapSort(array):\n    buildMaxHeap(array)\n    for endIdx in reversed(range(1, len(array))):\n        swap(0, endIdx, array)\n        siftDown(0, endIdx - 1, array)\n    return array\n\n\ndef buildMaxHeap(array):\n    firstParentIdx = (len(array) - 2) // 2\n    for currentIdx in reversed(range(firstParentIdx + 1)):\n        siftDown(currentIdx, len(array) - 1, array)\n\n\ndef siftDown(currentIdx, endIdx, heap):\n    childOneIdx = currentIdx * 2 + 1\n    while childOneIdx <= endIdx:\n        childTwoIdx = currentIdx * 2 + 2 if currentIdx * 2 + 2 <= endIdx else -1\n        if childTwoIdx > -1 and heap[childTwoIdx] > heap[childOneIdx]:\n            idxToSwap = childTwoIdx\n        else:\n            idxToSwap = childOneIdx\n        if heap[idxToSwap] > heap[currentIdx]:\n            swap(currentIdx, idxToSwap, heap)\n            currentIdx = idxToSwap\n            childOneIdx = currentIdx * 2 + 1\n        else:\n            return\n\n\ndef swap(i, j, array):\n    array[i], array[j] = array[j], array[i]\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.heapSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.heapSort([8, 5, 2, 9, 5, 6, 3]), [2, 3, 5, 5, 6, 8, 9])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def heapSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def heapSort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.heapSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.heapSort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func heapSort(_ array: [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(nlog(n)) time : O(1) space\n  // Average: O(nlog(n)) time : O(1) space\n  // Worst: O(nlog(n)) time : O(1) space\n  func heapSort(_ array: [Int]) -> [Int] {\n    var mutableArray = array\n\n    buildHeap(&mutableArray)\n\n    for index in stride(from: array.count - 1, to: 0, by: -1) {\n      swap(0, index, &mutableArray)\n\n      var startIndex = 0\n      var endIndex = index - 1\n\n      siftDown(&startIndex, &endIndex, &mutableArray)\n    }\n\n    return mutableArray\n  }\n\n  func buildHeap(_ array: inout [Int]) {\n    var firstParentIndex = Double((array.count - 2) / 2)\n    firstParentIndex = firstParentIndex.rounded(.down)\n\n    for var currentIndex in (0 ... Int(firstParentIndex)).reversed() {\n      var endIndex = array.count - 1\n      siftDown(&currentIndex, &endIndex, &array)\n    }\n  }\n\n  func siftDown(_ currentIndex: inout Int, _ endIndex: inout Int, _ heap: inout [Int]) {\n    var firstChildIndex = (currentIndex * 2) + 1\n\n    while firstChildIndex <= endIndex {\n      var secondChildIndex = -1\n\n      let potentialSecondChildIndex = (currentIndex * 2) + 2\n\n      if potentialSecondChildIndex <= endIndex {\n        secondChildIndex = potentialSecondChildIndex\n      }\n\n      var indexToSwap = -1\n\n      if secondChildIndex != -1, heap[secondChildIndex] > heap[firstChildIndex] {\n        indexToSwap = secondChildIndex\n      } else {\n        indexToSwap = firstChildIndex\n      }\n\n      if heap[indexToSwap] > heap[currentIndex] {\n        swap(currentIndex, indexToSwap, &heap)\n        currentIndex = indexToSwap\n        firstChildIndex = (currentIndex * 2) + 1\n      } else {\n        return\n      }\n    }\n  }\n\n  func swap(_ firstIndex: Int, _ secondIndex: Int, _ array: inout [Int]) {\n    let temp = array[firstIndex]\n\n    array[firstIndex] = array[secondIndex]\n    array[secondIndex] = temp\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.heapSort(arrayToSort))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var arrayToSort = [8, 5, 2, 9, 5, 6, 3]\n      try assertEqual([2, 3, 5, 5, 6, 8, 9], program.heapSort(arrayToSort))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function heapSort(array: number[]) {\n  // Write your code here.\n  return array;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nexport function heapSort(array: number[]) {\n  buildMaxHeap(array);\n  for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n    swap(0, endIdx, array);\n    siftDown(0, endIdx - 1, array);\n  }\n  return array;\n}\n\nfunction buildMaxHeap(array: number[]) {\n  const firstParentIdx = Math.floor((array.length - 2) / 2);\n  for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    siftDown(currentIdx, array.length - 1, array);\n  }\n}\n\nfunction siftDown(currentIdx: number, endIdx: number, heap: number[]) {\n  let childOneIdx = currentIdx * 2 + 1;\n  while (childOneIdx <= endIdx) {\n    const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    let idxToSwap;\n    if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n      idxToSwap = childTwoIdx;\n    } else {\n      idxToSwap = childOneIdx;\n    }\n    if (heap[idxToSwap] > heap[currentIdx]) {\n      swap(currentIdx, idxToSwap, heap);\n      currentIdx = idxToSwap;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction swap(i: number, j: number, array: number[]) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [8, 5, 2, 9, 5, 6, 3],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [8, 5, 2, 9, 5, 6, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 3, 2],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [
            -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6,
            -7, 8,
          ],
        },
        {
          array: [
            -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
          ],
        },
        {
          array: [
            8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2,
            7, -2, 4,
          ],
        },
        {
          array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1],
        },
        {
          array: [
            2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9,
            8, 1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
          ],
        },
        {
          array: [
            4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
            -2, -7, 4,
          ],
        },
        {
          array: [
            427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246,
            12, -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348,
            -474, -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565,
            892, 970, -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
          ],
        },
        {
          array: [
            991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998,
            847, 80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435,
            -269, 652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980,
            913, -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519,
            906,
          ],
        },
        {
          array: [
            384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
            -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204,
            776, -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367,
            -609, 662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67,
            -389, 508, 777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755,
            -978, 515, -68, -559, 489, 732, -19, -489, 737, 924,
          ],
        },
        {
          array: [
            544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
            -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
            -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568,
            -702, 551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153,
            788, 844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150,
            -656, 528, 61, 94, -581,
          ],
        },
        {
          array: [
            -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
            268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437,
            -453, -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67,
            834, 619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296,
            -90, 401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505,
            -415, -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373,
            915, -885, 879, 391, -158, 588, -641, -937, 986, 949, -321,
          ],
        },
        {
          array: [
            -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
            842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
            -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
            892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
            341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800,
            -950, -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265,
            746, 355, -578, -441, -254, -941, -738, -469, -167, -420, -126,
            -410, 59,
          ],
        },
      ],
      jsonTests: [
        {
          array: [8, 5, 2, 9, 5, 6, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 3, 2],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [
            -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6,
            -7, 8,
          ],
        },
        {
          array: [
            -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
          ],
        },
        {
          array: [
            8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2,
            7, -2, 4,
          ],
        },
        {
          array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1],
        },
        {
          array: [
            2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9,
            8, 1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
          ],
        },
        {
          array: [
            4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
            -2, -7, 4,
          ],
        },
        {
          array: [
            427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246,
            12, -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348,
            -474, -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565,
            892, 970, -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
          ],
        },
        {
          array: [
            991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998,
            847, 80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435,
            -269, 652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980,
            913, -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519,
            906,
          ],
        },
        {
          array: [
            384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
            -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204,
            776, -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367,
            -609, 662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67,
            -389, 508, 777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755,
            -978, 515, -68, -559, 489, 732, -19, -489, 737, 924,
          ],
        },
        {
          array: [
            544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
            -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
            -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568,
            -702, 551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153,
            788, 844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150,
            -656, 528, 61, 94, -581,
          ],
        },
        {
          array: [
            -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
            268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437,
            -453, -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67,
            834, 619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296,
            -90, 401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505,
            -415, -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373,
            915, -885, 879, 391, -158, 588, -641, -937, 986, 949, -321,
          ],
        },
        {
          array: [
            -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
            842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
            -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
            892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
            341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800,
            -950, -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265,
            746, 355, -578, -441, -254, -941, -738, -469, -167, -420, -126,
            -410, 59,
          ],
        },
      ],
      changelog: [],
      id: 3,
    },
    {
      uid: "reverse-linked-list",
      testStrategy: "JSON",
      name: "Reverse Linked List",
      version: 0,
      releaseDate: "2019-09-01T00:00:00Z",
      category: "Linked Lists",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 19640,
        failureCount: 6141,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "347174597",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1251,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List, reverses the\n  list in place (i.e., doesn\'t create a brand new list), and returns its new head.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node; in other\n  words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5 -> 4 -> 3 -> 2 -> 1 -> 0 <span class="CodeEditor-promptComment">// the new head node with value 5</span>\n</pre>\n</div>',
      hints: [
        "<p>\nYou can iterate through the Linked List from head to tail and reverse it in place along the way.\n</p>\n",
        "\n<p>\nYou'll need to manipulate three nodes at once at every step.\n</p>\n",
        '\n<p>\nImagine you have three variables pointing to three consecutive nodes in a Linked List. Start by setting the "next" property of the second node to the first node. Then, set the first variable to the second node, and set the second variable to the third node. Finally, set the third variable to the second variable\'s "next" property (at this point, the second variable is the original third node). Repeat this process until you\'re at the tail of the Linked List.\n</p>',
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the number of nodes in the Linked List",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: "linkedlist",
        outputType: "linkedlist",
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nclass LinkedList {\npublic:\n  int value;\n  LinkedList *next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\nLinkedList *reverseLinkedList(LinkedList *head) {\n  // Write your code here.\n  return nullptr;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass LinkedList {\npublic:\n  int value;\n  LinkedList *next;\n\n  LinkedList(int value) {\n    this->value = value;\n    this->next = nullptr;\n  }\n};\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nLinkedList *reverseLinkedList(LinkedList *head) {\n  LinkedList *previousNode = nullptr;\n  LinkedList *currentNode = head;\n  while (currentNode != nullptr) {\n    LinkedList *nextNode = currentNode->next;\n    currentNode->next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <vector>\n\nLinkedList *newLinkedList(vector<int> values);\nvector<int> toArray(LinkedList *ll);\nbool arraysEqual(vector<int> arr1, vector<int> arr2);\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      LinkedList *test = newLinkedList({0, 1, 2, 3, 4, 5});\n      vector<int> result = toArray(reverseLinkedList(test));\n      vector<int> expected = {5, 4, 3, 2, 1, 0};\n      assert(arraysEqual(result, expected));\n    });\n  }\n};\n\nLinkedList *newLinkedList(vector<int> values) {\n  LinkedList *ll = new LinkedList(values[0]);\n  LinkedList *current = ll;\n  for (int i = 1; i < values.size(); i++) {\n    current->next = new LinkedList(values[i]);\n    current = current->next;\n  }\n  return ll;\n}\n\nvector<int> toArray(LinkedList *ll) {\n  vector<int> arr = {};\n  LinkedList *current = ll;\n  while (current != nullptr) {\n    arr.push_back(current->value);\n    current = current->next;\n  }\n  return arr;\n}\n\nbool arraysEqual(vector<int> arr1, vector<int> arr2) {\n  if (arr1.size() != arr2.size())\n    return false;\n  for (int i = 0; i < arr1.size(); i++) {\n    if (arr1[i] != arr2[i])\n      return false;\n  }\n  return true;\n}\n',
          unitTests:
            '#include <vector>\n\nLinkedList *newLinkedList(vector<int> values);\nvector<int> toArray(LinkedList *ll);\nbool arraysEqual(vector<int> arr1, vector<int> arr2);\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      LinkedList *test = newLinkedList({0, 1, 2, 3, 4, 5});\n      vector<int> result = toArray(reverseLinkedList(test));\n      vector<int> expected = {5, 4, 3, 2, 1, 0};\n      assert(arraysEqual(result, expected));\n    });\n  }\n};\n\nLinkedList *newLinkedList(vector<int> values) {\n  LinkedList *ll = new LinkedList(values[0]);\n  LinkedList *current = ll;\n  for (int i = 1; i < values.size(); i++) {\n    current->next = new LinkedList(values[i]);\n    current = current->next;\n  }\n  return ll;\n}\n\nvector<int> toArray(LinkedList *ll) {\n  vector<int> arr = {};\n  LinkedList *current = ll;\n  while (current != nullptr) {\n    arr.push_back(current->value);\n    current = current->next;\n  }\n  return arr;\n}\n\nbool arraysEqual(vector<int> arr1, vector<int> arr2) {\n  if (arr1.size() != arr2.size())\n    return false;\n  for (int i = 0; i < arr1.size(); i++) {\n    if (arr1[i] != arr2[i])\n      return false;\n  }\n  return true;\n}\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static LinkedList ReverseLinkedList(LinkedList head) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n\n\tpublic class LinkedList {\n\t\tpublic int Value;\n\t\tpublic LinkedList Next = null;\n\n\t\tpublic LinkedList(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(1) space - where n is the number of nodes in the Linked List\n\tpublic static LinkedList ReverseLinkedList(LinkedList head) {\n\t\tLinkedList previousNode = null;\n\t\tLinkedList currentNode = head;\n\t\twhile (currentNode != null) {\n\t\t\tLinkedList nextNode = currentNode.Next;\n\t\t\tcurrentNode.Next = previousNode;\n\t\t\tpreviousNode = currentNode;\n\t\t\tcurrentNode = nextNode;\n\t\t}\n\t\treturn previousNode;\n\t}\n\n\tpublic class LinkedList {\n\t\tpublic int Value;\n\t\tpublic LinkedList Next = null;\n\n\t\tpublic LinkedList(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n\t\tList<int> result = toList(Program.ReverseLinkedList(test));\n\t\tint[] expected = new int[] {5, 4, 3, 2, 1, 0};\n\t\tUtils.AssertTrue(arraysEqual(result, expected));\n\t}\n\n\tpublic Program.LinkedList newLinkedList(int[] values) {\n\t\tProgram.LinkedList ll = new Program.LinkedList(values[0]);\n\t\tProgram.LinkedList current = ll;\n\t\tfor (int i = 1; i < values.Length; i++) {\n\t\t\tcurrent.Next = new Program.LinkedList(values[i]);\n\t\t\tcurrent = current.Next;\n\t\t}\n\t\treturn ll;\n\t}\n\n\tpublic List<int> toList(Program.LinkedList ll) {\n\t\tList<int> arr = new List<int>();\n\t\tProgram.LinkedList current = ll;\n\t\twhile (current != null) {\n\t\t\tarr.Add(current.Value);\n\t\t\tcurrent = current.Next;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tpublic bool arraysEqual(List<int> arr1, int[] arr2) {\n\t\tif (arr1.Count != arr2.Length) return false;\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          unitTests:
            "using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n\t\tList<int> result = toList(Program.ReverseLinkedList(test));\n\t\tint[] expected = new int[] {5, 4, 3, 2, 1, 0};\n\t\tUtils.AssertTrue(arraysEqual(result, expected));\n\t}\n\n\tpublic Program.LinkedList newLinkedList(int[] values) {\n\t\tProgram.LinkedList ll = new Program.LinkedList(values[0]);\n\t\tProgram.LinkedList current = ll;\n\t\tfor (int i = 1; i < values.Length; i++) {\n\t\t\tcurrent.Next = new Program.LinkedList(values[i]);\n\t\t\tcurrent = current.Next;\n\t\t}\n\t\treturn ll;\n\t}\n\n\tpublic List<int> toList(Program.LinkedList ll) {\n\t\tList<int> arr = new List<int>();\n\t\tProgram.LinkedList current = ll;\n\t\twhile (current != null) {\n\t\t\tarr.Add(current.Value);\n\t\t\tcurrent = current.Next;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tpublic bool arraysEqual(List<int> arr1, int[] arr2) {\n\t\tif (arr1.Count != arr2.Length) return false;\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\nfunc ReverseLinkedList(head *LinkedList) *LinkedList {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype LinkedList struct {\n\tValue int\n\tNext  *LinkedList\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunc ReverseLinkedList(head *LinkedList) *LinkedList {\n\tvar previousNode, currentNode *LinkedList = nil, head\n\tfor currentNode != nil {\n\t\tnextNode := currentNode.Next\n\t\tcurrentNode.Next = previousNode\n\t\tpreviousNode = currentNode\n\t\tcurrentNode = nextNode\n\t}\n\treturn previousNode\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewLinkedList(val int, others ...int) *LinkedList {\n\tll := &LinkedList{Value: val}\n\tcurrent := ll\n\tfor _, other := range others {\n\t\tcurrent.Next = &LinkedList{Value: other}\n\t\tcurrent = current.Next\n\t}\n\treturn ll\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\tvals := []int{}\n\tcurrent := ll\n\tfor current != nil {\n\t\tvals = append(vals, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn vals\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := NewLinkedList(0, 1, 2, 3, 4, 5)\n\toutput := ReverseLinkedList(input)\n\texpected := []int{5, 4, 3, 2, 1, 0}\n\trequire.NotNil(t, output)\n\trequire.Equal(t, expected, output.ToArray())\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewLinkedList(val int, others ...int) *LinkedList {\n\tll := &LinkedList{Value: val}\n\tcurrent := ll\n\tfor _, other := range others {\n\t\tcurrent.Next = &LinkedList{Value: other}\n\t\tcurrent = current.Next\n\t}\n\treturn ll\n}\n\nfunc (ll *LinkedList) ToArray() []int {\n\tvals := []int{}\n\tcurrent := ll\n\tfor current != nil {\n\t\tvals = append(vals, current.Value)\n\t\tcurrent = current.Next\n\t}\n\treturn vals\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := NewLinkedList(0, 1, 2, 3, 4, 5)\n\toutput := ReverseLinkedList(input)\n\texpected := []int{5, 4, 3, 2, 1, 0}\n\trequire.NotNil(t, output)\n\trequire.Equal(t, expected, output.ToArray())\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    // Write your code here.\n    return null;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space - where n is the number of nodes in the Linked List\n  public static LinkedList reverseLinkedList(LinkedList head) {\n    LinkedList previousNode = null;\n    LinkedList currentNode = head;\n    while (currentNode != null) {\n      LinkedList nextNode = currentNode.next;\n      currentNode.next = previousNode;\n      previousNode = currentNode;\n      currentNode = nextNode;\n    }\n    return previousNode;\n  }\n\n  static class LinkedList {\n    int value;\n    LinkedList next = null;\n\n    public LinkedList(int value) {\n      this.value = value;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n    List<Integer> result = toArrayList(Program.reverseLinkedList(test));\n    int[] expected = new int[] {5, 4, 3, 2, 1, 0};\n    Utils.assertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.length; i++) {\n      current.next = new Program.LinkedList(values[i]);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> toArrayList(Program.LinkedList ll) {\n    List<Integer> arr = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.add(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n\n  public boolean arraysEqual(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.LinkedList test = newLinkedList(new int[] {0, 1, 2, 3, 4, 5});\n    List<Integer> result = toArrayList(Program.reverseLinkedList(test));\n    int[] expected = new int[] {5, 4, 3, 2, 1, 0};\n    Utils.assertTrue(arraysEqual(result, expected));\n  }\n\n  public Program.LinkedList newLinkedList(int[] values) {\n    Program.LinkedList ll = new Program.LinkedList(values[0]);\n    Program.LinkedList current = ll;\n    for (int i = 1; i < values.length; i++) {\n      current.next = new Program.LinkedList(values[i]);\n      current = current.next;\n    }\n    return ll;\n  }\n\n  public List<Integer> toArrayList(Program.LinkedList ll) {\n    List<Integer> arr = new ArrayList<Integer>();\n    Program.LinkedList current = ll;\n    while (current != null) {\n      arr.add(current.value);\n      current = current.next;\n    }\n    return arr;\n  }\n\n  public boolean arraysEqual(List<Integer> arr1, int[] arr2) {\n    if (arr1.size() != arr2.length) return false;\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) return false;\n    }\n    return true;\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    // Write your code here.\n    return head\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nopen class LinkedList(value: Int) {\n    var value = value\n    var next: LinkedList? = null\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfun reverseLinkedList(head: LinkedList): LinkedList {\n    var previousNode: LinkedList? = null\n    var currentNode: LinkedList? = head\n    while (currentNode != null) {\n        val nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    }\n    return previousNode!!\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.reverseLinkedList as reverseLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5))\n        var reversedLinkedList = LinkedList(5)\n        addAll(reversedLinkedList, listOf(4, 3, 2, 1, 0))\n\n        var result = getNodeValuesInArray(reverseLinkedList(linkedList))\n        var expected = getNodeValuesInArray(reversedLinkedList)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n",
          unitTests:
            "import com.algoexpert.program.LinkedList as LinkedList\nimport com.algoexpert.program.reverseLinkedList as reverseLinkedList\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        var linkedList = LinkedList(0)\n        addAll(linkedList, listOf(1, 2, 3, 4, 5))\n        var reversedLinkedList = LinkedList(5)\n        addAll(reversedLinkedList, listOf(4, 3, 2, 1, 0))\n\n        var result = getNodeValuesInArray(reverseLinkedList(linkedList))\n        var expected = getNodeValuesInArray(reversedLinkedList)\n\n        assert(result == expected)\n    }\n}\n\nfun addAll(ll: LinkedList, values: List<Int>) {\n    var current = ll\n    for (value in values) {\n        val newLL = LinkedList(value)\n        current.next = newLL\n        current = newLL\n    }\n}\n\nfun getNodeValuesInArray(linkedList: LinkedList): List<Int> {\n    var values = mutableListOf<Int>()\n    var current: LinkedList? = linkedList\n    while (current != null) {\n        values.add(current.value)\n        current = current.next\n    }\n    return values\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef reverseLinkedList(head):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# This is an input class. Do not edit.\nclass LinkedList:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef reverseLinkedList(head):\n    previousNode, currentNode = None, head\n    while currentNode is not None:\n        nextNode = currentNode.next\n        currentNode.next = previousNode\n        previousNode = currentNode\n        currentNode = nextNode\n    return previousNode\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5])\n        result = program.reverseLinkedList(test).getNodesInArray()\n        expected = LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray()\n        self.assertEqual(result, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass LinkedList(program.LinkedList):\n    def addMany(self, values):\n        current = self\n        while current.next is not None:\n            current = current.next\n        for value in values:\n            current.next = LinkedList(value)\n            current = current.next\n        return self\n\n    def getNodesInArray(self):\n        nodes = []\n        current = self\n        while current is not None:\n            nodes.append(current.value)\n            current = current.next\n        return nodes\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        test = LinkedList(0).addMany([1, 2, 3, 4, 5])\n        result = program.reverseLinkedList(test).getNodesInArray()\n        expected = LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray()\n        self.assertEqual(result, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "# This is an input struct. Do not edit.\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\nclass Program\n  def reverseLinkedList(linkedList)\n    # Write your code here.\n    return nil\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass LinkedList\n  attr_accessor :value\n  attr_accessor :next\n\n  def initialize(value)\n    @value = value\n    @next = nil\n  end\nend\n\n# O(n) time | O(1) space - where n is the number of nodes in the Linked List\ndef reverseLinkedList(head)\n  previousNode, currentNode = nil, head\n  while currentNode != nil\n    nextNode = currentNode.next\n    currentNode.next = previousNode\n    previousNode = currentNode\n    currentNode = nextNode\n  end\n  return previousNode\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseLinkedList\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  // This is an input class. Do not edit.\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  func reverseLinkedList(_ head: LinkedList) -> LinkedList {\n    // Write your code here.\n    return head // replace me\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class LinkedList {\n    var value: Int\n    var next: LinkedList?\n\n    init(value: Int) {\n      self.value = value\n    }\n  }\n\n  // O(n) time | O(1) space\n  func reverseLinkedList(_ head: LinkedList) -> LinkedList {\n    var previousNode: LinkedList?\n    var currentNode: LinkedList? = head\n\n    while currentNode != nil {\n      let nextPointer = currentNode?.next\n      currentNode?.next = previousNode\n      previousNode = currentNode\n      currentNode = nextPointer\n    }\n\n    return previousNode!\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      try testReverseLinkedList(initialValue: 0, values: [1, 2, 3, 4, 5], reversedInitialValue: 5, reversedValues: [4, 3, 2, 1, 0])\n    }\n  }\n\n  func testReverseLinkedList(initialValue: Int, values: [Int], reversedInitialValue: Int, reversedValues: [Int]) throws {\n    let test = TestLinkedList(value: initialValue).addMany(values: values)\n    let result = program.reverseLinkedList(test) as! TestLinkedList\n    let expected = TestLinkedList(value: reversedInitialValue).addMany(values: reversedValues)\n    try assertEqual(expected.getNodesInArray(), result.getNodesInArray())\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current: Program.LinkedList? = self\n\n    while current?.next != nil {\n      current = current?.next\n    }\n\n    for value in values {\n      current?.next = TestLinkedList(value: value)\n      current = current?.next\n    }\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n    var current: Program.LinkedList? = self\n\n    while current != nil {\n      if let value = current?.value {\n        nodes.append(value)\n      }\n      current = current?.next\n    }\n\n    return nodes\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  let program = Program()\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      try testReverseLinkedList(initialValue: 0, values: [1, 2, 3, 4, 5], reversedInitialValue: 5, reversedValues: [4, 3, 2, 1, 0])\n    }\n  }\n\n  func testReverseLinkedList(initialValue: Int, values: [Int], reversedInitialValue: Int, reversedValues: [Int]) throws {\n    let test = TestLinkedList(value: initialValue).addMany(values: values)\n    let result = program.reverseLinkedList(test) as! TestLinkedList\n    let expected = TestLinkedList(value: reversedInitialValue).addMany(values: reversedValues)\n    try assertEqual(expected.getNodesInArray(), result.getNodesInArray())\n  }\n}\n\nclass TestLinkedList: Program.LinkedList {\n  func addMany(values: [Int]) -> TestLinkedList {\n    var current: Program.LinkedList? = self\n\n    while current?.next != nil {\n      current = current?.next\n    }\n\n    for value in values {\n      current?.next = TestLinkedList(value: value)\n      current = current?.next\n    }\n    return self\n  }\n\n  func getNodesInArray() -> [Int] {\n    var nodes = [Int]()\n    var current: Program.LinkedList? = self\n\n    while current != nil {\n      if let value = current?.value {\n        nodes.append(value)\n      }\n      current = current?.next\n    }\n\n    return nodes\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexport function reverseLinkedList(head: LinkedList) {\n  // Write your code here.\n  return head;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nexport class LinkedList {\n  value: number;\n  next: LinkedList | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nexport function reverseLinkedList(head: LinkedList) {\n  let previousNode: LinkedList | null = null;\n  let currentNode: LinkedList | null = head;\n  while (currentNode !== null) {\n    const nextNode: LinkedList | null = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode!;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\ntype LinkedList = program.LinkedList;\nconst {LinkedList} = program;\n\nit('Test Case #1', function () {\n  const test = addMany(new LinkedList(0), [1, 2, 3, 4, 5]);\n  const result = getNodesInArray(program.reverseLinkedList(test));\n  const expected = getNodesInArray(addMany(new LinkedList(5), [4, 3, 2, 1, 0]));\n  chai.expect(result).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: LinkedList) {\n  const nodes: number[] = [];\n  let current: LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\ntype LinkedList = program.LinkedList;\nconst {LinkedList} = program;\n\nit('Test Case #1', function () {\n  const test = addMany(new LinkedList(0), [1, 2, 3, 4, 5]);\n  const result = getNodesInArray(program.reverseLinkedList(test));\n  const expected = getNodesInArray(addMany(new LinkedList(5), [4, 3, 2, 1, 0]));\n  chai.expect(result).to.deep.equal(expected);\n});\n\nfunction addMany(linkedList: LinkedList, values: number[]) {\n  let current = linkedList;\n  while (current.next !== null) {\n    current = current.next;\n  }\n  for (const value of values) {\n    current.next = new LinkedList(value);\n    current = current.next;\n  }\n  return linkedList;\n}\n\nfunction getNodesInArray(linkedList: LinkedList) {\n  const nodes: number[] = [];\n  let current: LinkedList | null = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n",
        },
      },
      customInputVars: [
        {
          name: "linkedList",
          example: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: null,
                value: 5,
              },
            ],
          },
          schema: {
            description:
              "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
            properties: {
              head: {
                type: "string",
              },
              nodes: {
                items: {
                  properties: {
                    id: {
                      type: "string",
                    },
                    next: {
                      type: ["string", "null"],
                    },
                    value: {
                      type: "integer",
                    },
                  },
                  required: ["id", "value", "next"],
                  type: "object",
                },
                type: "array",
              },
            },
            required: ["head", "nodes"],
            type: "object",
          },
        },
      ],
      tests: [
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: null,
                value: 5,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: null,
                value: 0,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: null,
                value: 1,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: null,
                value: 2,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: null,
                value: 3,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: "6",
                value: 5,
              },
              {
                id: "6",
                next: null,
                value: 6,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: "6",
                value: 5,
              },
              {
                id: "6",
                next: "7",
                value: 6,
              },
              {
                id: "7",
                next: "8",
                value: 7,
              },
              {
                id: "8",
                next: "9",
                value: 8,
              },
              {
                id: "9",
                next: "10",
                value: 9,
              },
              {
                id: "10",
                next: "11",
                value: 10,
              },
              {
                id: "11",
                next: "12",
                value: 11,
              },
              {
                id: "12",
                next: null,
                value: 12,
              },
            ],
          },
        },
      ],
      jsonTests: [
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: null,
                value: 5,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: null,
                value: 0,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: null,
                value: 1,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: null,
                value: 2,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: null,
                value: 3,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: "6",
                value: 5,
              },
              {
                id: "6",
                next: null,
                value: 6,
              },
            ],
          },
        },
        {
          linkedList: {
            head: "0",
            nodes: [
              {
                id: "0",
                next: "1",
                value: 0,
              },
              {
                id: "1",
                next: "2",
                value: 1,
              },
              {
                id: "2",
                next: "3",
                value: 2,
              },
              {
                id: "3",
                next: "4",
                value: 3,
              },
              {
                id: "4",
                next: "5",
                value: 4,
              },
              {
                id: "5",
                next: "6",
                value: 5,
              },
              {
                id: "6",
                next: "7",
                value: 6,
              },
              {
                id: "7",
                next: "8",
                value: 7,
              },
              {
                id: "8",
                next: "9",
                value: 8,
              },
              {
                id: "9",
                next: "10",
                value: 9,
              },
              {
                id: "10",
                next: "11",
                value: 10,
              },
              {
                id: "11",
                next: "12",
                value: 11,
              },
              {
                id: "12",
                next: null,
                value: 12,
              },
            ],
          },
        },
      ],
      changelog: [],
      id: 4,
    },
    {
      uid: "balanced-brackets",
      testStrategy: "JSON",
      name: "Balanced Brackets",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Stacks",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 21141,
        failureCount: 8508,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "227727657",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 921,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a string made up of brackets (<span>(</span>,\n  <span>[</span>, <span>{</span>, <span>)</span>, <span>]</span>, and\n  <span>}</span>) and other optional characters. The function should return a\n  boolean representing whether the string is balanced with regards to brackets.\n</p>\n<p>\n  A string is said to be balanced if it has as many opening brackets of a\n  certain type as it has closing brackets of that type and if no bracket is\n  unmatched. Note that an opening bracket can\'t match a corresponding closing\n  bracket that comes before it, and similarly, a closing bracket can\'t match a\n  corresponding opening bracket that comes after it. Also, brackets can\'t\n  overlap each other as in\n  <span>[(])</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "([])(){}(())()()"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// it\'s balanced</span>\n</pre>\n</div>',
      hints: [
        "<p>\nIf you iterate through the input string one character at a time, there are two scenarios in which the string will be unbalanced: either you run into a closing bracket with no prior matching opening bracket or you get to the end of the string with some opening brackets that haven't been matched. Can you use an auxiliary data structure to keep track of all the brackets and efficiently check if you run into a unbalanced scenario at every iteration?\n</p>\n",
        "\n<p>\nConsider using a stack to store opening brackets as you traverse the string. The Last-In-First-Out property of the stack should allow you to match any closing brackets that you run into against the most recent opening bracket, if one exists, in which case you can simply pop it out of the stack. How can you check that there are no unmatched opening bracket once you've finished traversing through the string?\n</p>",
      ],
      spaceTime:
        "O(n) time | O(n) space - where n is the length of the input string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nbool balancedBrackets(string str) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <stack>\n\nusing namespace std;\n\n// O(n) time | O(n) space\nbool balancedBrackets(string str) {\n  string openingBrackets = \"([{\";\n  string closingBrackets = \")]}\";\n  unordered_map<char, char> matchingBrackets{\n      {')', '('}, {']', '['}, {'}', '{'}};\n  stack<char> stack;\n  for (char character : str) {\n    if (openingBrackets.find(character) != string::npos) {\n      stack.push(character);\n    } else if (closingBrackets.find(character) != string::npos) {\n      if (stack.size() == 0) {\n        return false;\n      }\n      if (stack.top() == matchingBrackets[character]) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.size() == 0;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(balancedBrackets("([])(){}(())()()") == true); });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(balancedBrackets("([])(){}(())()()") == true); });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static bool BalancedBrackets(string str) {\n\t\t// Write your code here.\n\t\treturn false;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static bool BalancedBrackets(string str) {\n\t\tstring openingBrackets = \"([{\";\n\t\tstring closingBrackets = \")]}\";\n\t\tDictionary<char, char> matchingBrackets = new Dictionary<char, char>();\n\t\tmatchingBrackets.Add(')', '(');\n\t\tmatchingBrackets.Add(']', '[');\n\t\tmatchingBrackets.Add('}', '{');\n\t\tList<char> stack = new List<char>();\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tchar letter = str[i];\n\t\t\tif (openingBrackets.IndexOf(letter) != -1) {\n\t\t\t\tstack.Add(letter);\n\t\t\t} else if (closingBrackets.IndexOf(letter) != -1) {\n\t\t\t\tif (stack.Count == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (stack[stack.Count - 1] == matchingBrackets[letter]) {\n\t\t\t\t\tstack.RemoveAt(stack.Count - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.Count == 0;\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring input = "([])(){}(())()()";\n\t\tUtils.AssertTrue(Program.BalancedBrackets(input));\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring input = "([])(){}(())()()";\n\t\tUtils.AssertTrue(Program.BalancedBrackets(input));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc BalancedBrackets(s string) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nvar opening = map[rune]bool{\n\t'(': true,\n\t'[': true,\n\t'{': true,\n}\n\nvar closing = map[rune]bool{\n\t')': true,\n\t']': true,\n\t'}': true,\n}\n\nvar matching = map[rune]rune{\n\t')': '(',\n\t']': '[',\n\t'}': '{',\n}\n\n// O(n) time | O(n) space\nfunc BalancedBrackets(s string) bool {\n\tstack := []rune{}\n\tfor _, char := range s {\n\t\tif _, found := opening[char]; found {\n\t\t\tstack = append(stack, char)\n\t\t\tcontinue\n\t\t}\n\t\tif _, found := closing[char]; found {\n\t\t\tif len(stack) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif stack[len(stack)-1] == matching[char] {\n\t\t\t\tstack = stack[0 : len(stack)-1]\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn len(stack) == 0\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := true\n\toutput := BalancedBrackets("([])(){}(())()()")\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := true\n\toutput := BalancedBrackets("([])(){}(())()()")\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static boolean balancedBrackets(String str) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space\n  public static boolean balancedBrackets(String str) {\n    String openingBrackets = \"([{\";\n    String closingBrackets = \")]}\";\n    Map<Character, Character> matchingBrackets = new HashMap<Character, Character>();\n    matchingBrackets.put(')', '(');\n    matchingBrackets.put(']', '[');\n    matchingBrackets.put('}', '{');\n    List<Character> stack = new ArrayList<Character>();\n    for (int i = 0; i < str.length(); i++) {\n      char letter = str.charAt(i);\n      if (openingBrackets.indexOf(letter) != -1) {\n        stack.add(letter);\n      } else if (closingBrackets.indexOf(letter) != -1) {\n        if (stack.size() == 0) {\n          return false;\n        }\n        if (stack.get(stack.size() - 1) == matchingBrackets.get(letter)) {\n          stack.remove(stack.size() - 1);\n        } else {\n          return false;\n        }\n      }\n    }\n    return stack.size() == 0;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String input = "([])(){}(())()()";\n    Utils.assertTrue(Program.balancedBrackets(input));\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    String input = "([])(){}(())()()";\n    Utils.assertTrue(Program.balancedBrackets(input));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function balancedBrackets(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.balancedBrackets = balancedBrackets;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction balancedBrackets(string) {\n  const openingBrackets = '([{';\n  const closingBrackets = ')]}';\n  const matchingBrackets = {')': '(', ']': '[', '}': '{'};\n  const stack = [];\n  for (const char of string) {\n    if (openingBrackets.includes(char)) {\n      stack.push(char);\n    } else if (closingBrackets.includes(char)) {\n      if (stack.length == 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === matchingBrackets[char]) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0;\n}\n\nexports.balancedBrackets = balancedBrackets;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun balancedBrackets(str: String): Boolean {\n    // Write your code here.\n    return false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.Stack\n\n// O(n) time | O(n) space\nfun balancedBrackets(string: String): Boolean {\n    val openingBrackets = \"([{\"\n    val closingBrackets = \")]}\"\n    val matchingBrackets = mapOf(')' to '(', ']' to '[', '}' to '{')\n    val stack = Stack<Char>()\n    for (char in string) {\n        if (openingBrackets.contains(char)) {\n            stack.add(char)\n        } else if (closingBrackets.contains(char)) {\n            if (stack.size == 0) {\n                return false\n            }\n            if (stack.peek() == matchingBrackets[char]) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.size == 0\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.balancedBrackets\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = "([])(){}(())()()"\n        assert(balancedBrackets(input))\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.balancedBrackets\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = "([])(){}(())()()"\n        assert(balancedBrackets(input))\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def balancedBrackets(string):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef balancedBrackets(string):\n    openingBrackets = "([{"\n    closingBrackets = ")]}"\n    matchingBrackets = {")": "(", "]": "[", "}": "{"}\n    stack = []\n    for char in string:\n        if char in openingBrackets:\n            stack.append(char)\n        elif char in closingBrackets:\n            if len(stack) == 0:\n                return False\n            if stack[-1] == matchingBrackets[char]:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.balancedBrackets("([])(){}(())()()"), True)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.balancedBrackets("([])(){}(())()()"), True)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def balancedBrackets(string)\n    # Write your code here.\n    return false\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def balancedBrackets(string)\n    # Write your code here.\n    return false\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.balancedBrackets\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.balancedBrackets\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func balancedBrackets(string: String) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func balancedBrackets(string: String) -> Bool {\n    let openingBrackets = "([{"\n    let closingBrackets = ")]}"\n    let matchingBrackets: [Character: Character] = [")": "(", "]": "[", "}": "{"]\n\n    var stack = [Character]()\n\n    for character in string {\n      if openingBrackets.contains(character) {\n        stack.append(character)\n      } else if closingBrackets.contains(character) {\n        if stack.count == 0 {\n          return false\n        } else {\n          if let lastCharacter = stack.last, lastCharacter == matchingBrackets[character] {\n            stack.popLast()\n          } else {\n            return false\n          }\n        }\n      }\n    }\n\n    return stack.count == 0\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.balancedBrackets(string: "([])(){}(())()()"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.balancedBrackets(string: "([])(){}(())()()"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function balancedBrackets(string: string) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function balancedBrackets(string: string) {\n  const openingBrackets = '([{';\n  const closingBrackets = ')]}';\n  const matchingBrackets: {[key: string]: string} = {')': '(', ']': '[', '}': '{'};\n  const stack: string[] = [];\n  for (const char of string) {\n    if (openingBrackets.includes(char)) {\n      stack.push(char);\n    } else if (closingBrackets.includes(char)) {\n      if (stack.length == 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === matchingBrackets[char]) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "([])(){}(())()()",
          schema: {
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "([])(){}(())()()",
        },
        {
          string: "()[]{}{",
        },
        {
          string: "(((((({{{{{[[[[[([)])]]]]]}}}}}))))))",
        },
        {
          string: "()()[{()})]",
        },
        {
          string: "(()())((()()()))",
        },
        {
          string: "{}()",
        },
        {
          string: "()([])",
        },
        {
          string: "((){{{{[]}}}})",
        },
        {
          string: "((({})()))",
        },
        {
          string: "(([]()()){})",
        },
        {
          string:
            "(((((([[[[[[{{{{{{{{{{{{()}}}}}}}}}}}}]]]]]]))))))((([])({})[])[])[]([]){}(())",
        },
        {
          string: "{[[[[({(}))]]]]}",
        },
        {
          string: "[((([])([]){}){}){}([])[]((())",
        },
        {
          string: ")[]}",
        },
        {
          string: "(a)",
        },
        {
          string: "(a(",
        },
        {
          string: "(141[])(){waga}((51afaw))()hh()",
        },
        {
          string: "aafwgaga()[]a{}{gggg",
        },
        {
          string: "(((((({{{{{safaf[[[[[([)]safsafsa)]]]]]}}}gawga}}))))))",
        },
        {
          string: "()(agawg)[{()gawggaw})]",
        },
        {
          string: "(()agwg())((()agwga()())gawgwgag)",
        },
        {
          string: "{}gawgw()",
        },
        {
          string: "(agwgg)([ghhheah%&@Q])",
        },
      ],
      jsonTests: [
        {
          string: "([])(){}(())()()",
        },
        {
          string: "()[]{}{",
        },
        {
          string: "(((((({{{{{[[[[[([)])]]]]]}}}}}))))))",
        },
        {
          string: "()()[{()})]",
        },
        {
          string: "(()())((()()()))",
        },
        {
          string: "{}()",
        },
        {
          string: "()([])",
        },
        {
          string: "((){{{{[]}}}})",
        },
        {
          string: "((({})()))",
        },
        {
          string: "(([]()()){})",
        },
        {
          string:
            "(((((([[[[[[{{{{{{{{{{{{()}}}}}}}}}}}}]]]]]]))))))((([])({})[])[])[]([]){}(())",
        },
        {
          string: "{[[[[({(}))]]]]}",
        },
        {
          string: "[((([])([]){}){}){}([])[]((())",
        },
        {
          string: ")[]}",
        },
        {
          string: "(a)",
        },
        {
          string: "(a(",
        },
        {
          string: "(141[])(){waga}((51afaw))()hh()",
        },
        {
          string: "aafwgaga()[]a{}{gggg",
        },
        {
          string: "(((((({{{{{safaf[[[[[([)]safsafsa)]]]]]}}}gawga}}))))))",
        },
        {
          string: "()(agawg)[{()gawggaw})]",
        },
        {
          string: "(()agwg())((()agwga()())gawgwgag)",
        },
        {
          string: "{}gawgw()",
        },
        {
          string: "(agwgg)([ghhheah%&@Q])",
        },
      ],
      changelog: [],
      id: 5,
    },
    {
      uid: "depth-first-search",
      testStrategy: "JSON",
      name: "Depth-first Search",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Graphs",
      difficulty: 1,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 48953,
        failureCount: 16650,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226842577",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 719,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re given a <span>Node</span> class that has a <span>name</span> and an\n  array of optional <span>children</span> nodes. When put together, nodes form\n  an acyclic tree-like structure.\n</p>\n<p>\n  Implement the <span>depthFirstSearch</span> method on the\n  <span>Node</span> class, which takes in an empty array, traverses the tree\n  using the Depth-first Search approach (specifically navigating the tree from\n  left to right), stores all of the nodes\' names in the input array, and returns\n  it.\n</p>\n<p>\n  If you\'re unfamiliar with Depth-first Search, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">graph</span> = A\n     /  |  \\\n    B   C   D\n   / \\     / \\\n  E   F   G   H\n     / \\   \\\n    I   J   K\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"]\n</pre>\n</div>',
      hints: [
        "<p>\nThe Depth-first Search algorithm works by traversing a graph branch by branch. In other words, before traversing any Node's sibling Nodes, its children nodes must be traversed. How can you simply and effectively keep track of Nodes' sibling Nodes as you traverse them, all the while retaining the order in which you must traverse them?\n</p>\n",
        "\n<p>\nStart at the root Node and try simply calling the depthFirstSearch method on all of its children Nodes. Then, call the depthFirstSearch method on all children Nodes of each child node. Keep applying this logic until the entire graph has been traversed. Don't forget to add the current Node's name to the input array at every call of depthFirstSearch.\n</p>",
      ],
      spaceTime:
        "O(v + e) time | O(v) space - where v is the number of vertices of the input graph and e is the number of edges of the input graph",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\npublic:\n  string name;\n  vector<Node *> children;\n\n  Node(string str) { name = str; }\n\n  vector<string> depthFirstSearch(vector<string> *array) {\n    // Write your code here.\n    return {};\n  }\n\n  Node *addChild(string name) {\n    Node *child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n  string name;\n  vector<Node *> children;\n\n  Node(string name) { this->name = name; }\n\n  // O(v + e) time | O(v) space\n  vector<string> depthFirstSearch(vector<string> *array) {\n    array->push_back(this->name);\n    for (int i = 0; i < this->children.size(); i++) {\n      children[i]->depthFirstSearch(array);\n    }\n    return *array;\n  }\n\n  Node *addChild(string name) {\n    Node *child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      Node graph("A");\n      graph.addChild("B")->addChild("C")->addChild("D");\n      graph.children[0]->addChild("E")->addChild("F");\n      graph.children[2]->addChild("G")->addChild("H");\n      graph.children[0]->children[1]->addChild("I")->addChild("J");\n      graph.children[2]->children[0]->addChild("K");\n\n      vector<string> expected{"A", "B", "E", "F", "I", "J",\n                              "C", "D", "G", "K", "H"};\n      vector<string> inputArray{};\n      assert(graph.depthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      Node graph("A");\n      graph.addChild("B")->addChild("C")->addChild("D");\n      graph.children[0]->addChild("E")->addChild("F");\n      graph.children[2]->addChild("G")->addChild("H");\n      graph.children[0]->children[1]->addChild("I")->addChild("J");\n      graph.children[2]->children[0]->addChild("K");\n\n      vector<string> expected{"A", "B", "E", "F", "I", "J",\n                              "C", "D", "G", "K", "H"};\n      vector<string> inputArray{};\n      assert(graph.depthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// Do not edit the class below except\n\t// for the DepthFirstSearch method.\n\t// Feel free to add new properties\n\t// and methods to the class.\n\tpublic class Node {\n\t\tpublic string name;\n\t\tpublic List<Node> children = new List<Node>();\n\n\t\tpublic Node(string name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic List<string> DepthFirstSearch(List<string> array) {\n\t\t\t// Write your code here.\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Node AddChild(string name) {\n\t\t\tNode child = new Node(name);\n\t\t\tchildren.Add(child);\n\t\t\treturn this;\n\t\t}\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic class Node {\n\t\tpublic string name;\n\t\tpublic List<Node> children = new List<Node>();\n\n\t\tpublic Node(string name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t// O(v + e) time | O(v) space\n\t\tpublic List<string> DepthFirstSearch(List<string> array) {\n\t\t\tarray.Add(this.name);\n\t\t\tfor (int i = 0; i < children.Count; i++) {\n\t\t\t\tchildren[i].DepthFirstSearch(array);\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Node AddChild(string name) {\n\t\t\tNode child = new Node(name);\n\t\t\tchildren.Add(child);\n\t\t\treturn this;\n\t\t}\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.Node graph = new Program.Node("A");\n\t\tgraph.AddChild("B").AddChild("C").AddChild("D");\n\t\tgraph.children[0].AddChild("E").AddChild("F");\n\t\tgraph.children[2].AddChild("G").AddChild("H");\n\t\tgraph.children[0].children[1].AddChild("I").AddChild("J");\n\t\tgraph.children[2].children[0].AddChild("K");\n\t\tstring[] expected = {"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"};\n\t\tList<string> inputArray = new List<string>();\n\t\tUtils.AssertTrue(compare(graph.DepthFirstSearch(inputArray), expected));\n\t}\n\n\tpublic static bool compare(List<string> arr1, string[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (!arr1[i].Equals(arr2[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n',
          unitTests:
            'using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.Node graph = new Program.Node("A");\n\t\tgraph.AddChild("B").AddChild("C").AddChild("D");\n\t\tgraph.children[0].AddChild("E").AddChild("F");\n\t\tgraph.children[2].AddChild("G").AddChild("H");\n\t\tgraph.children[0].children[1].AddChild("I").AddChild("J");\n\t\tgraph.children[2].children[0].AddChild("K");\n\t\tstring[] expected = {"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"};\n\t\tList<string> inputArray = new List<string>();\n\t\tUtils.AssertTrue(compare(graph.DepthFirstSearch(inputArray), expected));\n\t}\n\n\tpublic static bool compare(List<string> arr1, string[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (!arr1[i].Equals(arr2[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\nfunc (n *Node) DepthFirstSearch(array []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\n// O(v + e) time | O(v) space\nfunc (n *Node) DepthFirstSearch(array []string) []string {\n\tarray = append(array, n.Name)\n\tfor _, child := range n.Children {\n\t\tarray = child.DepthFirstSearch(array)\n\t}\n\treturn array\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode("A").AddChildren("B", "C", "D")\n\tgraph.Children[0].AddChildren("E").AddChildren("F")\n\tgraph.Children[2].AddChildren("G").AddChildren("H")\n\tgraph.Children[0].Children[1].AddChildren("I").AddChildren("J")\n\tgraph.Children[2].Children[0].AddChildren("K")\n\toutput := graph.DepthFirstSearch([]string{})\n\texpected := []string{"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"}\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode("A").AddChildren("B", "C", "D")\n\tgraph.Children[0].AddChildren("E").AddChildren("F")\n\tgraph.Children[2].AddChildren("G").AddChildren("H")\n\tgraph.Children[0].Children[1].AddChildren("I").AddChildren("J")\n\tgraph.Children[2].Children[0].AddChildren("K")\n\toutput := graph.DepthFirstSearch([]string{})\n\texpected := []string{"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"}\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  // Do not edit the class below except\n  // for the depthFirstSearch method.\n  // Feel free to add new properties\n  // and methods to the class.\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    public List<String> depthFirstSearch(List<String> array) {\n      // Write your code here.\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    // O(v + e) time | O(v) space\n    public List<String> depthFirstSearch(List<String> array) {\n      array.add(this.name);\n      for (int i = 0; i < children.size(); i++) {\n        children.get(i).depthFirstSearch(array);\n      }\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node("A");\n    graph.addChild("B").addChild("C").addChild("D");\n    graph.children.get(0).addChild("E").addChild("F");\n    graph.children.get(2).addChild("G").addChild("H");\n    graph.children.get(0).children.get(1).addChild("I").addChild("J");\n    graph.children.get(2).children.get(0).addChild("K");\n    String[] expected = {"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.depthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node("A");\n    graph.addChild("B").addChild("C").addChild("D");\n    graph.children.get(0).addChild("E").addChild("F");\n    graph.children.get(2).addChild("G").addChild("H");\n    graph.children.get(0).children.get(1).addChild("I").addChild("J");\n    graph.children.get(2).children.get(0).addChild("K");\n    String[] expected = {"A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.depthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  depthFirstSearch(array) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  depthFirstSearch(array) {\n    array.push(this.name);\n    for (const child of this.children) {\n      child.depthFirstSearch(array);\n    }\n    return array;\n  }\n}\n\nexports.Node = Node;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.depthFirstSearch([])).to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.depthFirstSearch([])).to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    fun depthFirstSearch(): List<String> {\n        // Write your code here.\n        return listOf()\n    }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    // O(v + e) time | O(v) space\n    fun depthFirstSearch(): List<String> {\n        return depthFirstSearch(mutableListOf())\n    }\n\n    fun depthFirstSearch(array: MutableList<String>): List<String> {\n        array.add(this.name)\n        for (child in this.children) {\n            child.depthFirstSearch(array)\n        }\n        return array\n    }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node("I")\n        val j = Node("J")\n        val k = Node("K")\n\n        val e = Node("E")\n        val f = Node("F")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node("G")\n        g.children.add(k)\n\n        val h = Node("H")\n\n        val b = Node("B")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node("C")\n\n        val d = Node("D")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node("A")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf("A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H")\n        val output = graph.depthFirstSearch()\n        assert(expected == output)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node("I")\n        val j = Node("J")\n        val k = Node("K")\n\n        val e = Node("E")\n        val f = Node("F")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node("G")\n        g.children.add(k)\n\n        val h = Node("H")\n\n        val b = Node("B")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node("C")\n\n        val d = Node("D")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node("A")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf("A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H")\n        val output = graph.depthFirstSearch()\n        assert(expected == output)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "# Do not edit the class below except\n# for the depthFirstSearch method.\n# Feel free to add new properties\n# and methods to the class.\nclass Node:\n    def __init__(self, name):\n        self.children = []\n        self.name = name\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    def depthFirstSearch(self, array):\n        # Write your code here.\n        pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, name):\n        self.children = []\n        self.name = name\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    # O(v + e) time | O(v) space\n    def depthFirstSearch(self, array):\n        array.append(self.name)\n        for child in self.children:\n            child.depthFirstSearch(array)\n        return array\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node("A")\n        graph.addChild("B").addChild("C").addChild("D")\n        graph.children[0].addChild("E").addChild("F")\n        graph.children[2].addChild("G").addChild("H")\n        graph.children[0].children[1].addChild("I").addChild("J")\n        graph.children[2].children[0].addChild("K")\n        self.assertEqual(graph.depthFirstSearch([]), ["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"])\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node("A")\n        graph.addChild("B").addChild("C").addChild("D")\n        graph.children[0].addChild("E").addChild("F")\n        graph.children[2].addChild("G").addChild("H")\n        graph.children[0].children[1].addChild("I").addChild("J")\n        graph.children[2].children[0].addChild("K")\n        self.assertEqual(graph.depthFirstSearch([]), ["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"])\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  class Node {\n    let name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    func depthFirstSearch(array: inout [String]) -> [String] {\n      // Write your code here.\n      return []\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Node {\n    let name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    // O(v + e) time | O(v) space\n    func depthFirstSearch(array: inout [String]) -> [String] {\n      array.append(name)\n\n      for child in children {\n        child.depthFirstSearch(array: &array)\n      }\n\n      return array\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let graph = Program.Node(name: "A")\n      graph.addChild(name: "B").addChild(name: "C").addChild(name: "D")\n      graph.children[0].addChild(name: "E").addChild(name: "F")\n      graph.children[2].addChild(name: "G").addChild(name: "H")\n      graph.children[0].children[1].addChild(name: "I").addChild(name: "J")\n      graph.children[2].children[0].addChild(name: "K")\n\n      var arrayToReturn = [String]()\n      try assertEqual(["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"], graph.depthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let graph = Program.Node(name: "A")\n      graph.addChild(name: "B").addChild(name: "C").addChild(name: "D")\n      graph.children[0].addChild(name: "E").addChild(name: "F")\n      graph.children[2].addChild(name: "G").addChild(name: "H")\n      graph.children[0].children[1].addChild(name: "I").addChild(name: "J")\n      graph.children[2].children[0].addChild(name: "K")\n\n      var arrayToReturn = [String]()\n      try assertEqual(["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"], graph.depthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  depthFirstSearch(array: string[]) {\n    // Write your code here.\n    return array;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  depthFirstSearch(array: string[]) {\n    array.push(this.name);\n    for (const child of this.children) {\n      child.depthFirstSearch(array);\n    }\n    return array;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.depthFirstSearch([])).to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.depthFirstSearch([])).to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "graph",
          example: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
          schema: {
            description:
              "For the purpose of this question, a <span>graph</span> is represented by a list of <span>nodes</span> and a <span>startNode</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes' lists of <span>children</span> and by the <span>startNode</span>.\nThe searching function will be called on the <span>startNode</span>.<br />\nRemember that your graph shouldn't have cycles!\n",
            properties: {
              nodes: {
                items: {
                  properties: {
                    children: {
                      items: {
                        type: "string",
                      },
                      type: "array",
                      uniqueItems: true,
                    },
                    id: {
                      type: "string",
                    },
                    value: {
                      type: "string",
                    },
                  },
                  required: ["id", "value", "children"],
                  type: "object",
                },
                type: "array",
              },
              startNode: {
                type: "string",
              },
            },
            required: ["startNode", "nodes"],
            type: "object",
          },
        },
      ],
      tests: [
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C"],
                id: "A",
                value: "A",
              },
              {
                children: ["D"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E"],
                id: "A",
                value: "A",
              },
              {
                children: [],
                id: "B",
                value: "B",
              },
              {
                children: ["F"],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B"],
                id: "A",
                value: "A",
              },
              {
                children: ["C"],
                id: "B",
                value: "B",
              },
              {
                children: ["D", "E"],
                id: "C",
                value: "C",
              },
              {
                children: ["F"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E", "F"],
                id: "A",
                value: "A",
              },
              {
                children: ["G", "H", "I"],
                id: "B",
                value: "B",
              },
              {
                children: ["J"],
                id: "C",
                value: "C",
              },
              {
                children: ["K", "L"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["M", "N"],
                id: "F",
                value: "F",
              },
              {
                children: [],
                id: "G",
                value: "G",
              },
              {
                children: ["O", "P", "Q", "R"],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: ["S"],
                id: "K",
                value: "K",
              },
              {
                children: [],
                id: "L",
                value: "L",
              },
              {
                children: [],
                id: "M",
                value: "M",
              },
              {
                children: [],
                id: "N",
                value: "N",
              },
              {
                children: [],
                id: "O",
                value: "O",
              },
              {
                children: ["T", "U"],
                id: "P",
                value: "P",
              },
              {
                children: [],
                id: "Q",
                value: "Q",
              },
              {
                children: ["V"],
                id: "R",
                value: "R",
              },
              {
                children: [],
                id: "S",
                value: "S",
              },
              {
                children: [],
                id: "T",
                value: "T",
              },
              {
                children: [],
                id: "U",
                value: "U",
              },
              {
                children: ["W", "X", "Y"],
                id: "V",
                value: "V",
              },
              {
                children: [],
                id: "W",
                value: "W",
              },
              {
                children: ["Z"],
                id: "X",
                value: "X",
              },
              {
                children: [],
                id: "Y",
                value: "Y",
              },
              {
                children: [],
                id: "Z",
                value: "Z",
              },
            ],
            startNode: "A",
          },
        },
      ],
      jsonTests: [
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C"],
                id: "A",
                value: "A",
              },
              {
                children: ["D"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E"],
                id: "A",
                value: "A",
              },
              {
                children: [],
                id: "B",
                value: "B",
              },
              {
                children: ["F"],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B"],
                id: "A",
                value: "A",
              },
              {
                children: ["C"],
                id: "B",
                value: "B",
              },
              {
                children: ["D", "E"],
                id: "C",
                value: "C",
              },
              {
                children: ["F"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E", "F"],
                id: "A",
                value: "A",
              },
              {
                children: ["G", "H", "I"],
                id: "B",
                value: "B",
              },
              {
                children: ["J"],
                id: "C",
                value: "C",
              },
              {
                children: ["K", "L"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["M", "N"],
                id: "F",
                value: "F",
              },
              {
                children: [],
                id: "G",
                value: "G",
              },
              {
                children: ["O", "P", "Q", "R"],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: ["S"],
                id: "K",
                value: "K",
              },
              {
                children: [],
                id: "L",
                value: "L",
              },
              {
                children: [],
                id: "M",
                value: "M",
              },
              {
                children: [],
                id: "N",
                value: "N",
              },
              {
                children: [],
                id: "O",
                value: "O",
              },
              {
                children: ["T", "U"],
                id: "P",
                value: "P",
              },
              {
                children: [],
                id: "Q",
                value: "Q",
              },
              {
                children: ["V"],
                id: "R",
                value: "R",
              },
              {
                children: [],
                id: "S",
                value: "S",
              },
              {
                children: [],
                id: "T",
                value: "T",
              },
              {
                children: [],
                id: "U",
                value: "U",
              },
              {
                children: ["W", "X", "Y"],
                id: "V",
                value: "V",
              },
              {
                children: [],
                id: "W",
                value: "W",
              },
              {
                children: ["Z"],
                id: "X",
                value: "X",
              },
              {
                children: [],
                id: "Y",
                value: "Y",
              },
              {
                children: [],
                id: "Z",
                value: "Z",
              },
            ],
            startNode: "A",
          },
        },
      ],
      changelog: [],
      id: 6,
    },
    {
      uid: "reverse-words-in-string",
      testStrategy: "JSON",
      name: "Reverse Words In String",
      version: 0,
      releaseDate: "2021-01-31T00:00:00Z",
      category: "Strings",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 12484,
        failureCount: 4893,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "503731346",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1751,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a string of words separated by one or more\n  whitespaces and returns a string that has these words in reverse order. For\n  example, given the string <span>"tim is great"</span>, your function should\n  return <span>"great is tim"</span>.\n</p>\n<p>\n  For this problem, a word can contain special characters, punctuation, and\n  numbers. The words in the string will be separated by one or more whitespaces,\n  and the reversed string must contain the same whitespaces as the original\n  string. For example, given the string\n  <span>"whitespaces    4"</span> you would be expected to return\n  <span>"4    whitespaces"</span>.\n</p>\n<p>\n  Note that you\'re <b><i>not</i></b> allowed to to use any built-in\n  <span>split</span> or <span>reverse</span> methods/functions. However, you\n  <b><i>are</i></b> allowed to use a built-in <span>join</span> method/function.\n</p>\n<p>Also note that the input string isn\'t guaranteed to always contain words.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "AlgoExpert is the best!"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"best! the is AlgoExpert"\n</pre>\n</div>',
      hints: [
        "<p>\n  There are at least two ways to solve this problem, and both require locating\n  the words in the string. How can you find all of the words in the string?\n</p>\n",
        "\n<p>\n  If you're able to locate all of the words in the string, the next step is to\n  figure out how many spaces are between them. If you can create a list that\n  contains all of the words in the string and all of the spaces between them,\n  then all you need to do is reverse the list and recreate the string using the\n  reversed list.\n</p>\n",
        "\n<p>\n  A potentially easier approach to this problem is to start by reversing the\n  entire string. Once the entire string has been reversed, the words will be in\n  the correct order, but each word will also be reversed. From here, all you\n  have to do is reverse all of the individual words in this new string. By doing\n  this, you'll restore each reversed word back to its original order, and\n  you'll have the desired output.\n</p>",
      ],
      spaceTime: "O(n) time | O(n) space - where n is the length of the string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            'using namespace std;\n\nstring reverseWordsInString(string str) {\n  // Write your code here.\n  return "";\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid reverseList(vector<string> &list);\n\n// O(n) time | O(n) space - where n is the length of the string\nstring reverseWordsInString(string str) {\n  vector<string> words;\n  int startOfWord = 0;\n  for (int idx = 0; idx < str.size(); idx++) {\n    char character = str[idx];\n\n    if (character == ' ') {\n      words.push_back(str.substr(startOfWord, idx - startOfWord));\n      startOfWord = idx;\n    } else if (str[startOfWord] == ' ') {\n      words.push_back(\" \");\n      startOfWord = idx;\n    }\n  }\n\n  words.push_back(str.substr(startOfWord));\n\n  reverseList(words);\n  string output;\n  for (auto word : words) {\n    output += word;\n  }\n  return output;\n}\n\nvoid reverseList(vector<string> &list) {\n  int start = 0;\n  int end = list.size() - 1;\n  while (start < end) {\n    string temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid reverseListRange(vector<char> &list, int start, int end);\n\n// O(n) time | O(n) space - where n is the length of the string\nstring reverseWordsInString(string str) {\n  vector<char> characters;\n  for (auto character : str) {\n    characters.push_back(character);\n  }\n  reverseListRange(characters, 0, characters.size() - 1);\n\n  int startOfWord = 0;\n  while (startOfWord < characters.size()) {\n    int endOfWord = startOfWord;\n    while (endOfWord < characters.size() && characters[endOfWord] != ' ') {\n      endOfWord++;\n    }\n\n    reverseListRange(characters, startOfWord, endOfWord - 1);\n    startOfWord = endOfWord + 1;\n  }\n\n  string output;\n  for (auto character : characters) {\n    output += character;\n  }\n  return output;\n}\n\nvoid reverseListRange(vector<char> &list, int start, int end) {\n  while (start < end) {\n    char temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string input = "AlgoExpert is the best!";\n      ;\n      string expected = "best! the is AlgoExpert";\n      auto actual = reverseWordsInString(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string input = "AlgoExpert is the best!";\n      ;\n      string expected = "best! the is AlgoExpert";\n      auto actual = reverseWordsInString(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            'using System;\n\n\npublic class Program {\n\n\tpublic string ReverseWordsInString(string str) {\n\t\t// Write your code here.\n\t\treturn "";\n\t}\n}\n\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(n) time | O(n) space - where n is the length of the string\n\tpublic string ReverseWordsInString(string str) {\n\t\tList<string> words = new List<string>();\n\t\tint startOfWord = 0;\n\n\t\tfor (int idx = 0; idx < str.Length; idx++) {\n\t\t\tchar character = str[idx];\n\n\t\t\tif (character == ' ') {\n\t\t\t\twords.Add(str.Substring(startOfWord, idx-startOfWord));\n\t\t\t\tstartOfWord = idx;\n\t\t\t} else if (str[startOfWord] == ' ') {\n\t\t\t\twords.Add(\" \");\n\t\t\t\tstartOfWord = idx;\n\t\t\t}\n\t\t}\n\n\t\twords.Add(str.Substring(startOfWord));\n\t\twords.Reverse();\n\t\treturn String.Join(\"\", words);\n\t}\n}\n\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(n) time | O(n) space - where n is the length of the string\n\tpublic string ReverseWordsInString(string str) {\n\t\tchar[] characters = str.ToCharArray();\n\t\treverseListRange(characters, 0, characters.Length - 1);\n\n\t\tint startOfWord = 0;\n\t\twhile (startOfWord < characters.Length) {\n\t\t\tint endOfWord = startOfWord;\n\t\t\twhile (endOfWord < characters.Length && characters[endOfWord] != ' ') {\n\t\t\t\tendOfWord += 1;\n\t\t\t}\n\n\t\t\treverseListRange(characters, startOfWord, endOfWord - 1);\n\t\t\tstartOfWord = endOfWord + 1;\n\t\t}\n\n\t\treturn new string(characters);\n\t}\n\n\tpublic char[] reverseListRange(char[] list, int start, int end) {\n\t\twhile (start < end) {\n\t\t\tchar temp = list[start];\n\t\t\tlist[start] = list[end];\n\t\t\tlist[end] = temp;\n\t\t\tstart += 1;\n\t\t\tend -= 1;\n\t\t}\n\n\t\treturn list;\n\t}\n}\n\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring input = "AlgoExpert is the best!";\n\t\tstring expected = "best! the is AlgoExpert";\n\t\tstring actual = new Program().ReverseWordsInString(input);\n\t\tUtils.AssertTrue(expected.Equals(actual));\n\t}\n}',
          unitTests:
            'using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring input = "AlgoExpert is the best!";\n\t\tstring expected = "best! the is AlgoExpert";\n\t\tstring actual = new Program().ReverseWordsInString(input);\n\t\tUtils.AssertTrue(expected.Equals(actual));\n\t}\n}',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            'package main\n\nfunc ReverseWordsInString(str string) string {\n\t// Write your code here.\n\treturn ""\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"strings"\n)\n\n// O(n) time | O(n) space - where n is the length of the string\nfunc ReverseWordsInString(str string) string {\n\twords := make([]string, 0)\n\tstartOfWord := 0\n\tfor idx, character := range str {\n\t\tif character == \' \' {\n\t\t\twords = append(words, str[startOfWord:idx])\n\t\t\tstartOfWord = idx\n\t\t} else if str[startOfWord] == \' \' {\n\t\t\twords = append(words, " ")\n\t\t\tstartOfWord = idx\n\t\t}\n\t}\n\n\twords = append(words, str[startOfWord:])\n\treverseList(words)\n\treturn strings.Join(words, "")\n}\n\nfunc reverseList(list []string) {\n\tstart := 0\n\tend := len(list) - 1\n\tfor start < end {\n\t\ttemp := list[start]\n\t\tlist[start] = list[end]\n\t\tlist[end] = temp\n\t\tstart += 1\n\t\tend -= 1\n\t}\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the length of the string\nfunc ReverseWordsInString(str string) string {\n\tcharacters := make([]byte, 0)\n\tfor _, char := range []byte(str) {\n\t\tcharacters = append(characters, char)\n\t}\n\treverseListRange(characters, 0, len(characters)-1)\n\n\tstartOfWord := 0\n\tfor startOfWord < len(characters) {\n\t\tendOfWord := startOfWord\n\t\tfor endOfWord < len(characters) && characters[endOfWord] != ' ' {\n\t\t\tendOfWord += 1\n\t\t}\n\n\t\treverseListRange(characters, startOfWord, endOfWord-1)\n\t\tstartOfWord = endOfWord + 1\n\t}\n\n\treturn string(characters)\n}\n\nfunc reverseListRange(list []byte, rangeStart, rangeEnd int) {\n\tstart := rangeStart\n\tend := rangeEnd\n\tfor start < end {\n\t\ttemp := list[start]\n\t\tlist[start] = list[end]\n\t\tlist[end] = temp\n\t\tstart += 1\n\t\tend -= 1\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := "AlgoExpert is the best!"\n\texpected := "best! the is AlgoExpert"\n\tactual := ReverseWordsInString(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := "AlgoExpert is the best!"\n\texpected := "best! the is AlgoExpert"\n\tactual := ReverseWordsInString(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            'import java.util.*;\n\nclass Program {\n\n  public String reverseWordsInString(String string) {\n    // Write your code here.\n    return "";\n  }\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n) time | O(n) space - where n is the length of the string\n  public String reverseWordsInString(String string) {\n    ArrayList<String> words = new ArrayList<String>();\n    int startOfWord = 0;\n\n    for (int idx = 0; idx < string.length(); idx++) {\n      char character = string.charAt(idx);\n\n      if (character == ' ') {\n        words.add(string.substring(startOfWord, idx));\n        startOfWord = idx;\n      } else if (string.charAt(startOfWord) == ' ') {\n        words.add(\" \");\n        startOfWord = idx;\n      }\n    }\n\n    words.add(string.substring(startOfWord));\n\n    Collections.reverse(words);\n    return String.join(\"\", words);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n) time | O(n) space - where n is the length of the string\n  public String reverseWordsInString(String string) {\n    char[] characters = string.toCharArray();\n    reverseListRange(characters, 0, characters.length - 1);\n\n    int startOfWord = 0;\n    while (startOfWord < characters.length) {\n      int endOfWord = startOfWord;\n      while (endOfWord < characters.length && characters[endOfWord] != ' ') {\n        endOfWord += 1;\n      }\n\n      reverseListRange(characters, startOfWord, endOfWord - 1);\n      startOfWord = endOfWord + 1;\n    }\n\n    return new String(characters);\n  }\n\n  public char[] reverseListRange(char[] list, int start, int end) {\n    while (start < end) {\n      char temp = list[start];\n      list[start] = list[end];\n      list[end] = temp;\n      start += 1;\n      end -= 1;\n    }\n\n    return list;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String input = "AlgoExpert is the best!";\n    String expected = "best! the is AlgoExpert";\n    String actual = new Program().reverseWordsInString(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String input = "AlgoExpert is the best!";\n    String expected = "best! the is AlgoExpert";\n    String actual = new Program().reverseWordsInString(input);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function reverseWordsInString(string) {\n  // Write your code here.\n  return '';\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the string\nfunction reverseWordsInString(string) {\n  const words = [];\n  let startOfWord = 0;\n  for (let idx = 0; idx < string.length; idx++) {\n    const character = string[idx];\n\n    if (character === ' ') {\n      words.push(string.slice(startOfWord, idx));\n      startOfWord = idx;\n    } else if (string[startOfWord] === ' ') {\n      words.push(' ');\n      startOfWord = idx;\n    }\n  }\n\n  words.push(string.slice(startOfWord));\n\n  reverseList(words);\n  return words.join('');\n}\n\nfunction reverseList(list) {\n  let start = 0,\n    end = list.length - 1;\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the string\nfunction reverseWordsInString(string) {\n  const characters = [];\n  for (const char of string) {\n    characters.push(char);\n  }\n  reverseListRange(characters, 0, characters.length - 1);\n\n  let startOfWord = 0;\n  while (startOfWord < characters.length) {\n    let endOfWord = startOfWord;\n    while (endOfWord < characters.length && characters[endOfWord] != ' ') {\n      endOfWord++;\n    }\n\n    reverseListRange(characters, startOfWord, endOfWord - 1);\n    startOfWord = endOfWord + 1;\n  }\n  return characters.join('');\n}\n\nfunction reverseListRange(list, start, end) {\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun reverseWordsInString(string: String): String {\n    // Write your code here.\n    return string\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the length of the string\nfun reverseWordsInString(string: String): String {\n    val words = mutableListOf<String>()\n    var startOfWord = 0\n    for (idx in 0 until string.length) {\n        val character = string[idx]\n\n        if (character == ' ') {\n            words.add(string.substring(startOfWord, idx))\n            startOfWord = idx\n        } else if (string[startOfWord] == ' ') {\n            words.add(\" \")\n            startOfWord = idx\n        }\n    }\n\n    words.add(string.substring(startOfWord))\n\n    reverseList(words)\n    return words.joinToString(\"\")\n}\n\nfun reverseList(list: MutableList<String>) {\n    var start = 0\n    var end = list.size - 1\n    while (start < end) {\n        val temp = list[start]\n        list[start] = list[end]\n        list[end] = temp\n        start += 1\n        end -= 1\n    }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the length of the string\nfun reverseWordsInString(string: String): String {\n    val characters = mutableListOf<Char>()\n    for (char in string) {\n        characters.add(char)\n    }\n    reverseListRange(characters, 0, characters.size - 1)\n\n    var startOfWord = 0\n    while (startOfWord < characters.size) {\n        var endOfWord = startOfWord\n        while (endOfWord < characters.size && characters[endOfWord] != ' ') {\n            endOfWord += 1\n        }\n\n        reverseListRange(characters, startOfWord, endOfWord - 1)\n        startOfWord = endOfWord + 1\n    }\n\n    return characters.joinToString(\"\")\n}\n\nfun reverseListRange(list: MutableList<Char>, rangeStart: Int, rangeEnd: Int) {\n    var start = rangeStart\n    var end = rangeEnd\n    while (start < end) {\n        val temp = list[start]\n        list[start] = list[end]\n        list[end] = temp\n        start += 1\n        end -= 1\n    }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.reverseWordsInString\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = "AlgoExpert is the best!"\n        val expected = "best! the is AlgoExpert"\n        val output = reverseWordsInString(input)\n        assert(expected == output)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.reverseWordsInString\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = "AlgoExpert is the best!"\n        val expected = "best! the is AlgoExpert"\n        val output = reverseWordsInString(input)\n        assert(expected == output)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            'def reverseWordsInString(string):\n    # Write your code here.\n    return ""\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the string\ndef reverseWordsInString(string):\n    words = []\n    startOfWord = 0\n    for idx in range(len(string)):\n        character = string[idx]\n\n        if character == " ":\n            words.append(string[startOfWord:idx])\n            startOfWord = idx\n        elif string[startOfWord] == " ":\n            words.append(" ")\n            startOfWord = idx\n\n    words.append(string[startOfWord:])\n\n    reverseList(words)\n    return "".join(words)\n\n\ndef reverseList(list):\n    start, end = 0, len(list) - 1\n    while start < end:\n        list[start], list[end] = list[end], list[start]\n        start += 1\n        end -= 1\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the string\ndef reverseWordsInString(string):\n    characters = [char for char in string]\n    reverseListRange(characters, 0, len(characters) - 1)\n\n    startOfWord = 0\n    while startOfWord < len(characters):\n        endOfWord = startOfWord\n        while endOfWord < len(characters) and characters[endOfWord] != " ":\n            endOfWord += 1\n\n        reverseListRange(characters, startOfWord, endOfWord - 1)\n        startOfWord = endOfWord + 1\n\n    return "".join(characters)\n\n\ndef reverseListRange(list, start, end):\n    while start < end:\n        list[start], list[end] = list[end], list[start]\n        start += 1\n        end -= 1\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = "AlgoExpert is the best!"\n        expected = "best! the is AlgoExpert"\n        actual = program.reverseWordsInString(input)\n        self.assertEqual(actual, expected)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = "AlgoExpert is the best!"\n        expected = "best! the is AlgoExpert"\n        actual = program.reverseWordsInString(input)\n        self.assertEqual(actual, expected)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            'class Program\n  def reverseWordsInString(string)\n    # Write your code here.\n    return ""\n  end\nend\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def reverseWordsInString(string)\n    # Write your code here.\n    return ""\n  end\nend\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def reverseWordsInString(string)\n    # Write your code here.\n    return ""\n  end\nend\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseWordsInString\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.reverseWordsInString\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            'class Program {\n  func reverseWordsInString(_ string: String) -> String {\n    // Write your code here.\n    return ""\n  }\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the string\n  func reverseWordsInString(_ string: String) -> String {\n    var words = [String]()\n    let indexedString = Array(string)\n    var startOfWord = 0\n    for (idx, character) in indexedString.enumerated() {\n      if character == " " {\n        words.append(String(indexedString[startOfWord ..< idx]))\n        startOfWord = idx\n      } else if indexedString[startOfWord] == " " {\n        words.append(" ")\n        startOfWord = idx\n      }\n    }\n\n    words.append(String(indexedString[startOfWord...]))\n    reverseList(&words)\n    return words.joined(separator: "")\n  }\n\n  func reverseList(_ list: inout [String]) {\n    var start = 0\n    var end = list.count - 1\n    while start < end {\n      let temp = list[start]\n      list[start] = list[end]\n      list[end] = temp\n      start += 1\n      end -= 1\n    }\n  }\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the string\n  func reverseWordsInString(_ string: String) -> String {\n    var characters = Array(string)\n    reverseListRange(&characters, 0, characters.count - 1)\n\n    var startOfWord = 0\n    while startOfWord < characters.count {\n      var endOfWord = startOfWord\n      while endOfWord < characters.count, characters[endOfWord] != " " {\n        endOfWord += 1\n      }\n\n      reverseListRange(&characters, startOfWord, endOfWord - 1)\n      startOfWord = endOfWord + 1\n    }\n\n    return String(characters)\n  }\n\n  func reverseListRange(_ list: inout [Character], _ rangeStart: Int, _ rangeEnd: Int) {\n    var start = rangeStart\n    var end = rangeEnd\n    while start < end {\n      let temp = list[start]\n      list[start] = list[end]\n      list[end] = temp\n      start += 1\n      end -= 1\n    }\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = "AlgoExpert is the best!"\n      var expected = "best! the is AlgoExpert"\n      var actual = Program().reverseWordsInString(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = "AlgoExpert is the best!"\n      var expected = "best! the is AlgoExpert"\n      var actual = Program().reverseWordsInString(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function reverseWordsInString(string: string) {\n  // Write your code here.\n  return string;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the string\nexport function reverseWordsInString(string: string) {\n  const words: string[] = [];\n  let startOfWord = 0;\n  for (let idx = 0; idx < string.length; idx++) {\n    const character = string[idx];\n\n    if (character === ' ') {\n      words.push(string.slice(startOfWord, idx));\n      startOfWord = idx;\n    } else if (string[startOfWord] === ' ') {\n      words.push(' ');\n      startOfWord = idx;\n    }\n  }\n\n  words.push(string.slice(startOfWord));\n\n  reverseList(words);\n  return words.join('');\n}\n\nfunction reverseList(list: string[]) {\n  let start = 0,\n    end = list.length - 1;\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the string\nexport function reverseWordsInString(string: string) {\n  const characters: string[] = [];\n  for (const char of string) {\n    characters.push(char);\n  }\n  reverseListRange(characters, 0, characters.length - 1);\n\n  let startOfWord = 0;\n  while (startOfWord < characters.length) {\n    let endOfWord = startOfWord;\n    while (endOfWord < characters.length && characters[endOfWord] != ' ') {\n      endOfWord++;\n    }\n\n    reverseListRange(characters, startOfWord, endOfWord - 1);\n    startOfWord = endOfWord + 1;\n  }\n  return characters.join('');\n}\n\nfunction reverseListRange(list: string[], start: number, end: number) {\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "AlgoExpert is the best!",
          schema: {
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "AlgoExpert is the best!",
        },
        {
          string: "Reverse These Words",
        },
        {
          string: "..H,, hello 678",
        },
        {
          string: "this this words this this this words this",
        },
        {
          string: "1 12 23 34 56",
        },
        {
          string: "APPLE PEAR PLUM ORANGE",
        },
        {
          string: "this-is-one-word",
        },
        {
          string: "a",
        },
        {
          string: "ab",
        },
        {
          string: "",
        },
        {
          string:
            "algoexpert is the best platform to use to prepare for coding interviews!",
        },
        {
          string: "words, separated, by, commas",
        },
        {
          string: "this      string     has a     lot of   whitespace",
        },
        {
          string: "a ab a",
        },
        {
          string: "test        ",
        },
        {
          string: " ",
        },
      ],
      jsonTests: [
        {
          string: "AlgoExpert is the best!",
        },
        {
          string: "Reverse These Words",
        },
        {
          string: "..H,, hello 678",
        },
        {
          string: "this this words this this this words this",
        },
        {
          string: "1 12 23 34 56",
        },
        {
          string: "APPLE PEAR PLUM ORANGE",
        },
        {
          string: "this-is-one-word",
        },
        {
          string: "a",
        },
        {
          string: "ab",
        },
        {
          string: "",
        },
        {
          string:
            "algoexpert is the best platform to use to prepare for coding interviews!",
        },
        {
          string: "words, separated, by, commas",
        },
        {
          string: "this      string     has a     lot of   whitespace",
        },
        {
          string: "a ab a",
        },
        {
          string: "test        ",
        },
        {
          string: " ",
        },
      ],
      changelog: [],
      id: 7,
    },
    {
      uid: "caesar-cipher-encryptor",
      testStrategy: "JSON",
      name: "Caesar Cipher Encryptor",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Strings",
      difficulty: 1,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 40680,
        failureCount: 16440,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "225759200",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 979,
      },
      prompt:
        '<div class="html">\n<p>\n  Given a non-empty string of lowercase letters and a non-negative integer\n  representing a key, write a function that returns a new string obtained by\n  shifting every letter in the input string by k positions in the alphabet,\n  where k is the key.\n</p>\n<p>\n  Note that letters should "wrap" around the alphabet; in other words, the\n  letter <span>z</span> shifted by one returns the letter <span>a</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "xyz"\n<span class="CodeEditor-promptParameter">key</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"zab"\n</pre>\n</div>',
      hints: [
        "<p>\nMost languages have built-in functions that give you the Unicode value of a character as well as the character corresponding to a Unicode value. Consider using such functions to determine which letters the input string's letters should be mapped to.\n</p>\n",
        "\n<p>\nTry creating your own mapping of letters to codes. In other words, try associating each letter in the alphabet with a specific number - its position in the alphabet, for instance - and using that to determine which letters the input string's letters should be mapped to.\n</p>\n",
        "\n<p>\nHow do you handle cases where a letter gets shifted to a position that requires wrapping around the alphabet? What about cases where the key is very large and causes multiple wrappings around the alphabet? The modulo operator should be your friend here.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(n) space - where n is the length of the input string",
      notes:
        '<div class="html">\n<p>\n  For <b>Solution 2</b> of this problem, in the video explanation, we update the\n  <span>newLetterCode</span> with the following formula if it\'s greater than\n  <span>25</span>:\n</p>\n<pre>\n-1 + newLetterCode % 25\n</pre>\n<p>\n  This logic is actually flawed, because if\n  <span>newLetterCode % 25</span> happens to be equal to <span>0</span>, then\n  we\'ll be accessing a letter in the <span>alphabet</span> at index\n  <span>-1</span>, which will throw an error in a lot of languages or simply\n  return an incorrect answer in other languages.\n</p>\n<p>\n  For example, this edge-case issue will occur with these inputs:\n</p>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "z"\n<span class="CodeEditor-promptParameter">key</span> = 25\n</pre>\n<p>\n  Instead, we need to use the following formula if the\n  <span>newLetterCode</span> is greater than <span>25</span>:\n</p>\n<pre>\nnewLetterCode % 26\n</pre>\n<p class="CodeEditor-notesQuestion">\n  Why isn\'t this an issue in <b>Solution 1</b>?\n</p>\n<p>In <b>Solution 1</b>, our formula is:</p>\n<pre>\n96 + newLetterCode % 122\n</pre>\n<p>\n  Since we only actually apply this formula if <span>newLetterCode</span> is\n  greater than 122, and since the key that\'s used to initially compute\n  <span>newLetterCode</span> is always less than <span>26</span> (because it\'s\n  modded by <span>26</span> at the beginning of the algorithm), we know that\n  <span>newLetterCode % 122</span> will never be equal to <span>0</span> (<span\n    >newLetterCode</span\n  >\n  will always be between <span>123</span> and <span>147</span>).\n</p>\n<p>\n  Thus, we\'ll never compute a character from the char code <span>96</span>,\n  which would be equivalent to accessing a letter at index <span>-1</span> in\n  <b>Solution 2</b>.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            'using namespace std;\n\nstring caesarCypherEncryptor(string str, int key) {\n  // Write your code here.\n  return "";\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nchar getNewLetter(char letter, int key);\n\n// O(n) time | O(n) space\nstring caesarCypherEncryptor(string str, int key) {\n  vector<char> newLetters;\n  int newKey = key % 26;\n  for (int i = 0; i < str.length(); i++) {\n    newLetters.push_back(getNewLetter(str[i], newKey));\n  }\n  return string(newLetters.begin(), newLetters.end());\n}\n\nchar getNewLetter(char letter, int key) {\n  int newLetterCode = letter + key;\n  return newLetterCode <= 122 ? newLetterCode : 96 + newLetterCode % 122;\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nchar getNewLetter(char letter, int key, string alphabet);\n\n// O(n) time | O(n) space\nstring caesarCypherEncryptor(string str, int key) {\n  vector<char> newLetters;\n  int newKey = key % 26;\n  string alphabet = "abcdefghijklmnopqrstuvwxyz";\n  for (int i = 0; i < str.length(); i++) {\n    newLetters.push_back(getNewLetter(str[i], newKey, alphabet));\n  }\n  return string(newLetters.begin(), newLetters.end());\n}\n\nchar getNewLetter(char letter, int key, string alphabet) {\n  int newLetterCode = alphabet.find(letter) + key;\n  return alphabet[newLetterCode % 26];\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(caesarCypherEncryptor("xyz", 2) == "zab"); });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(caesarCypherEncryptor("xyz", 2) == "zab"); });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            'using System;\n\npublic class Program {\n\tpublic static string CaesarCypherEncryptor(string str, int key) {\n\t\t// Write your code here.\n\t\treturn "";\n\t}\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static string CaesarCypherEncryptor(string str, int key) {\n\t\tchar[] newLetters = new char[str.Length];\n\t\tint newKey = key % 26;\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tnewLetters[i] = getNewLetter(str[i], newKey);\n\t\t}\n\t\treturn new string(newLetters);\n\t}\n\n\tpublic static char getNewLetter(char letter, int key) {\n\t\tint newLetterCode = letter + key;\n\t\treturn newLetterCode <=\n\t\t       122 ? (char)newLetterCode : (char)(96 + newLetterCode % 122);\n\t}\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static string CaesarCypherEncryptor(string str, int key) {\n\t\tchar[] newLetters = new char[str.Length];\n\t\tint newKey = key % 26;\n\t\tstring alphabet = "abcdefghijklmnopqrstuvwxyz";\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tnewLetters[i] = getNewLetter(str[i], newKey, alphabet);\n\t\t}\n\t\treturn new string(newLetters);\n\t}\n\n\tpublic static char getNewLetter(char letter, int key, string alphabet) {\n\t\tint newLetterCode = alphabet.IndexOf(letter) + key;\n\t\treturn alphabet[newLetterCode % 26];\n\t}\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.CaesarCypherEncryptor("xyz", 2).Equals("zab"));\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.CaesarCypherEncryptor("xyz", 2).Equals("zab"));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            'package main\n\nfunc CaesarCipherEncryptor(str string, key int) string {\n\t// Write your code here.\n\treturn ""\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space\nfunc CaesarCipherEncryptor(str string, key int) string {\n\tshift, offset := rune(key%26), rune(26)\n\trunes := []rune(str)\n\tfor i, char := range runes {\n\t\tif char >= 'a' && char+shift <= 'z' {\n\t\t\tchar += shift\n\t\t} else {\n\t\t\tchar += shift - offset\n\t\t}\n\t\trunes[i] = char\n\t}\n\treturn string(runes)\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"strings"\n)\n\n// O(n) time | O(n) space\nfunc CaesarCipherEncryptor(str string, key int) string {\n\trunes := []rune(str)\n\talphabet := "abcdefghijklmnopqrstuvwxyz"\n\tfor i, char := range runes {\n\t\tindex := strings.Index(alphabet, string(char))\n\t\tif index == -1 {\n\t\t\treturn "" // Bad input\n\t\t}\n\t\tnewindex := (index + key) % 26\n\t\trunes[i] = rune(alphabet[newindex])\n\t}\n\treturn string(runes)\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "zab"\n\toutput := CaesarCipherEncryptor("xyz", 2)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "zab"\n\toutput := CaesarCipherEncryptor("xyz", 2)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            'import java.util.*;\n\nclass Program {\n  public static String caesarCypherEncryptor(String str, int key) {\n    // Write your code here.\n    return "";\n  }\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  public static String caesarCypherEncryptor(String str, int key) {\n    char[] newLetters = new char[str.length()];\n    int newKey = key % 26;\n    for (int i = 0; i < str.length(); i++) {\n      newLetters[i] = getNewLetter(str.charAt(i), newKey);\n    }\n    return new String(newLetters);\n  }\n\n  public static char getNewLetter(char letter, int key) {\n    int newLetterCode = letter + key;\n    return newLetterCode <= 122 ? (char) newLetterCode : (char) (96 + newLetterCode % 122);\n  }\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  public static String caesarCypherEncryptor(String str, int key) {\n    char[] newLetters = new char[str.length()];\n    int newKey = key % 26;\n    String alphabet = "abcdefghijklmnopqrstuvwxyz";\n    for (int i = 0; i < str.length(); i++) {\n      newLetters[i] = getNewLetter(str.charAt(i), newKey, alphabet);\n    }\n    return new String(newLetters);\n  }\n\n  public static char getNewLetter(char letter, int key, String alphabet) {\n    int newLetterCode = alphabet.indexOf(letter) + key;\n    return alphabet.charAt(newLetterCode % 26);\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.caesarCypherEncryptor("xyz", 2).equals("zab"));\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.caesarCypherEncryptor("xyz", 2).equals("zab"));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function caesarCipherEncryptor(string, key) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction caesarCipherEncryptor(string, key) {\n  const newLetters = [];\n  const newKey = key % 26;\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter, key) {\n  const newLetterCode = letter.charCodeAt() + key;\n  return newLetterCode <= 122 ? String.fromCharCode(newLetterCode) : String.fromCharCode(96 + (newLetterCode % 122));\n}\n\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction caesarCipherEncryptor(string, key) {\n  const newLetters = [];\n  const newKey = key % 26;\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey, alphabet));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter, key, alphabet) {\n  const newLetterCode = alphabet.indexOf(letter) + key;\n  return alphabet[newLetterCode % 26];\n}\n\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            'package com.algoexpert.program\n\nfun caesarCipherEncryptor(string: String, key: Int): String {\n    // Write your code here.\n    return ""\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space\nfun caesarCipherEncryptor(string: String, key: Int): String {\n    val newLetters = mutableListOf<Char>()\n    val newKey = key % 26\n    for (letter in string) {\n        newLetters.add(getNewLetter(letter, newKey))\n    }\n    return newLetters.joinToString("")\n}\n\nfun getNewLetter(letter: Char, key: Int): Char {\n    val newLetterCode = letter.toInt() + key\n    return if (newLetterCode <= 122) newLetterCode.toChar() else (96 + newLetterCode % 122).toChar()\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space\nfun caesarCipherEncryptor(string: String, key: Int): String {\n    val newLetters = mutableListOf<Char>()\n    val newKey = key % 26\n    val alphabet = "abcdefghijklmnopqrstuvwxyz".toCharArray()\n    for (letter in string) {\n        newLetters.add(getNewLetter(letter, newKey, alphabet))\n    }\n    return newLetters.joinToString("")\n}\n\nfun getNewLetter(letter: Char, key: Int, alphabet: CharArray): Char {\n    val newLetterCode = alphabet.indexOf(letter) + key\n    return alphabet[newLetterCode % 26]\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.caesarCipherEncryptor as caesarCipherEncryptor\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(caesarCipherEncryptor("xyz", 2) == "zab")\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.caesarCipherEncryptor as caesarCipherEncryptor\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(caesarCipherEncryptor("xyz", 2) == "zab")\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def caesarCipherEncryptor(string, key):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef caesarCipherEncryptor(string, key):\n    newLetters = []\n    newKey = key % 26\n    for letter in string:\n        newLetters.append(getNewLetter(letter, newKey))\n    return "".join(newLetters)\n\n\ndef getNewLetter(letter, key):\n    newLetterCode = ord(letter) + key\n    return chr(newLetterCode) if newLetterCode <= 122 else chr(96 + newLetterCode % 122)\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef caesarCipherEncryptor(string, key):\n    newLetters = []\n    newKey = key % 26\n    alphabet = list("abcdefghijklmnopqrstuvwxyz")\n    for letter in string:\n        newLetters.append(getNewLetter(letter, newKey, alphabet))\n    return "".join(newLetters)\n\n\ndef getNewLetter(letter, key, alphabet):\n    newLetterCode = alphabet.index(letter) + key\n    return alphabet[newLetterCode % 26]\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.caesarCipherEncryptor("xyz", 2), "zab")\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.caesarCipherEncryptor("xyz", 2), "zab")\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            'class Program\n  def caesarCipherEncryptor(string, key)\n    # Write your code here.\n    return ""\n  end\nend\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def caesarCipherEncryptor(string, key)\n    # Write your code here.\n    return ""\n  end\nend\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def caesarCipherEncryptor(string, key)\n    # Write your code here.\n    return ""\n  end\nend\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.caesarCipherEncryptor\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.caesarCipherEncryptor\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            'class Program {\n  func caesarCipherEncryptor(string: String, key: UInt32) -> String {\n    // Write your code here.\n    return ""\n  }\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func caesarCipherEncryptor(string: String, key: UInt32) -> String {\n    var newLetters = [Character]()\n    let newKey = key % 26\n\n    for letter in string {\n      newLetters.append(getNewLetter(letter, newKey))\n    }\n\n    return String(newLetters)\n  }\n\n  func getNewLetter(_ letter: Character, _ key: UInt32) -> Character {\n    let newLetterCode = letter.unicodeScalars.first!.value + key\n\n    let code: UnicodeScalar?\n\n    if newLetterCode <= 122 {\n      code = UnicodeScalar(newLetterCode)\n    } else {\n      code = UnicodeScalar(96 + newLetterCode % 122)\n    }\n\n    return Character(code!)\n  }\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func caesarCipherEncryptor(string: String, key: UInt32) -> String {\n    var newLetters = [Character]()\n    let newKey = key % 26\n\n    let alphabet = Array("abcdefghijklmnopqrstuvwxyz")\n\n    for letter in string {\n      newLetters.append(getNewLetter(letter, newKey, alphabet))\n    }\n\n    return String(newLetters)\n  }\n\n  func getNewLetter(_ letter: Character, _ key: UInt32, _ alphabet: [Character]) -> Character {\n    let newLetterCode = alphabet.firstIndex(of: letter)! + Int(key)\n    return alphabet[newLetterCode % 26]\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("zab", program.caesarCipherEncryptor(string: "xyz", key: 2))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("zab", program.caesarCipherEncryptor(string: "xyz", key: 2))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function caesarCipherEncryptor(string: string, key: number) {\n  // Write your code here.\n  return '';\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function caesarCipherEncryptor(string: string, key: number) {\n  const newLetters = [];\n  const newKey = key % 26;\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter: string, key: number) {\n  const newLetterCode = letter.charCodeAt(0) + key;\n  return newLetterCode <= 122 ? String.fromCharCode(newLetterCode) : String.fromCharCode(96 + (newLetterCode % 122));\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function caesarCipherEncryptor(string: string, key: number) {\n  const newLetters = [];\n  const newKey = key % 26;\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey, alphabet));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter: string, key: number, alphabet: string[]) {\n  const newLetterCode = alphabet.indexOf(letter) + key;\n  return alphabet[newLetterCode % 26];\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "xyz",
          schema: {
            minLength: 1,
            pattern: "^[a-z]+$",
            type: "string",
          },
        },
        {
          name: "key",
          example: 2,
          schema: {
            minimum: 0,
            type: "integer",
          },
        },
      ],
      tests: [
        {
          key: 2,
          string: "xyz",
        },
        {
          key: 0,
          string: "abc",
        },
        {
          key: 3,
          string: "abc",
        },
        {
          key: 5,
          string: "xyz",
        },
        {
          key: 26,
          string: "abc",
        },
        {
          key: 52,
          string: "abc",
        },
        {
          key: 57,
          string: "abc",
        },
        {
          key: 25,
          string: "xyz",
        },
        {
          key: 25,
          string: "iwufqnkqkqoolxzzlzihqfm",
        },
        {
          key: 52,
          string: "ovmqkwtujqmfkao",
        },
        {
          key: 7,
          string: "mvklahvjcnbwqvtutmfafkwiuagjkzmzwgf",
        },
        {
          key: 15,
          string: "kjwmntauvjjnmsagwgawkagfuaugjhawgnawgjhawjgawbfawghesh",
        },
      ],
      jsonTests: [
        {
          key: 2,
          string: "xyz",
        },
        {
          key: 0,
          string: "abc",
        },
        {
          key: 3,
          string: "abc",
        },
        {
          key: 5,
          string: "xyz",
        },
        {
          key: 26,
          string: "abc",
        },
        {
          key: 52,
          string: "abc",
        },
        {
          key: 57,
          string: "abc",
        },
        {
          key: 25,
          string: "xyz",
        },
        {
          key: 25,
          string: "iwufqnkqkqoolxzzlzihqfm",
        },
        {
          key: 52,
          string: "ovmqkwtujqmfkao",
        },
        {
          key: 7,
          string: "mvklahvjcnbwqvtutmfafkwiuagjkzmzwgf",
        },
        {
          key: 15,
          string: "kjwmntauvjjnmsagwgawkagfuaugjhawgnawgjhawjgawbfawghesh",
        },
      ],
      changelog: [],
      id: 8,
    },
    {
      uid: "single-cycle-check",
      testStrategy: "JSON",
      name: "Single Cycle Check",
      version: 0,
      releaseDate: "2019-05-04T00:00:00Z",
      category: "Graphs",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 24228,
        failureCount: 11120,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "330773483",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 727,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re given an array of integers where each integer represents a jump of its\n  value in the array. For instance, the integer <span>2</span> represents a jump\n  of two indices forward in the array; the integer <span>-3</span> represents a\n  jump of three indices backward in the array.\n</p>\n<p>\n  If a jump spills past the array\'s bounds, it wraps over to the other side. For\n  instance, a jump of <span>-1</span> at index <span>0</span> brings us to the last index in\n  the array. Similarly, a jump of <span>1</span> at the last index in the array brings us to\n  index <span>0</span>.\n</p>\n<p>\n  Write a function that returns a boolean representing whether the jumps in the\n  array form a single cycle. A single cycle occurs if, starting at any index in\n  the array and following the jumps, every element in the array is visited\n  exactly once before landing back on the starting index.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 3, 1, -4, -4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
      hints: [
        "<p>\nIn order to check if the input array has a single cycle, you have to jump through all of the elements in the array. Could you keep a counter, jump through elements in the array, and stop once you've jumped through as many elements as are contained in the array?\n</p>\n",
        "\n<p>\nAssume the input array has length n. If you start at index 0 and jump through n elements, what are the simplest conditions that you can check to see if the array doesn't have a single cycle?\n</p>\n",
        "\n<p>\nGiven Hint #2, there are 2 conditions that need to be met for the input array to have a single cycle. First, the starting element (in this case, the element at index 0) cannot be jumped through more than once, at the very beginning, so long as you haven't jumped through all of the other elements in the array. Second, the (n + 1)th element you jump through, where n is the length of the array, must be the first element you visited: the element at index 0 in this case.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input array",
      notes:
        '<div class="html">\n<p>\n  In the video explanation of this question, we explain that we need to handle\n  negative values for the <span>nextIdx</span> calculated in our helper method.\n</p>\n<pre>\nnextIdx = (currentIdx + jump) % len(array)\nreturn nextIdx if nextIdx >= 0 else nextIdx + len(array)\n</pre>\n<p>\n  In most programming languages, this is necessary because, if\n  <span>currentIdx + jump</span> is negative, then\n  <span>(currentIdx + jump) % len(array)</span> will also be negative.\n</p>\n<p>\n  In Python, however, "the modulo operator always yields a result with the same\n  sign as its second operand (or zero)"\n  <a\n    href="https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations"\n    target="_blank"\n    >[Python Docs]</a\n  >. In other words, in Python, the modulo operation to compute the\n  <span>nextIdx</span> will always return a number with the sign of\n  <span>len(array)</span>, which is naturally positive.\n</p>\n<p>\n  More specifically, the modulo operator in Python behaves as follows when used\n  with a negative first operand:\n</p>\n<pre>\n-x % y == -(x % y) + y\n</pre>\n<p>\n  The Python modulo operator effectively does, by default, what we do in our\n  code to handle negative values.\n</p>\n<p>\n  Thus, in Python, we can just return\n  <span>(currentIdx + jump) % len(array)</span> for the <span>nextIdx</span>,\n  without needing to handle negative values.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nbool hasSingleCycle(vector<int> array) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint getNextIdx(int currentIdx, vector<int> array);\n\n// O(n) time | O(1) space - where n is the length of the input array\nbool hasSingleCycle(vector<int> array) {\n  int numElementsVisited = 0;\n  int currentIdx = 0;\n  while (numElementsVisited < array.size()) {\n    if (numElementsVisited > 0 && currentIdx == 0)\n      return false;\n    numElementsVisited++;\n    currentIdx = getNextIdx(currentIdx, array);\n  }\n  return currentIdx == 0;\n}\n\nint getNextIdx(int currentIdx, vector<int> array) {\n  int jump = array[currentIdx];\n  int nextIdx = (currentIdx + jump) % (int)array.size();\n  return nextIdx >= 0 ? nextIdx : nextIdx + array.size();\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(hasSingleCycle({2, 3, 1, -4, -4, 2}) == true);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(hasSingleCycle({2, 3, 1, -4, -4, 2}) == true);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static bool HasSingleCycle(int[] array) {\n\t\t// Write your code here.\n\t\treturn false;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(1) space - where n is the length of the input array\n\tpublic static bool HasSingleCycle(int[] array) {\n\t\tint numElementsVisited = 0;\n\t\tint currentIdx = 0;\n\t\twhile (numElementsVisited < array.Length) {\n\t\t\tif (numElementsVisited > 0 && currentIdx == 0) return false;\n\t\t\tnumElementsVisited++;\n\t\t\tcurrentIdx = getNextIdx(currentIdx, array);\n\t\t}\n\t\treturn currentIdx == 0;\n\t}\n\n\tpublic static int getNextIdx(int currentIdx, int[] array) {\n\t\tint jump = array[currentIdx];\n\t\tint nextIdx = (currentIdx + jump) % array.Length;\n\t\treturn nextIdx >= 0 ? nextIdx : nextIdx + array.Length;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.HasSingleCycle(new int[] {2, 3, 1, -4, -4, 2}));\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.HasSingleCycle(new int[] {2, 3, 1, -4, -4, 2}));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc HasSingleCycle(array []int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunc HasSingleCycle(array []int) bool {\n\tnumElementsVisited := 0\n\tcurrentIdx := 0\n\tfor numElementsVisited < len(array) {\n\t\tif numElementsVisited > 0 && currentIdx == 0 {\n\t\t\treturn false\n\t\t}\n\t\tnumElementsVisited++\n\t\tcurrentIdx = getNextIdx(currentIdx, array)\n\t}\n\treturn currentIdx == 0\n}\n\nfunc getNextIdx(currentIdx int, array []int) int {\n\tjump := array[currentIdx]\n\tnextIdx := (currentIdx + jump) % len(array)\n\tif nextIdx >= 0 {\n\t\treturn nextIdx\n\t}\n\treturn nextIdx + len(array)\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 3, 1, -4, -4, 2}\n\toutput := HasSingleCycle(input)\n\texpected := true\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 3, 1, -4, -4, 2}\n\toutput := HasSingleCycle(input)\n\texpected := true\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static boolean hasSingleCycle(int[] array) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space - where n is the length of the input array\n  public static boolean hasSingleCycle(int[] array) {\n    int numElementsVisited = 0;\n    int currentIdx = 0;\n    while (numElementsVisited < array.length) {\n      if (numElementsVisited > 0 && currentIdx == 0) return false;\n      numElementsVisited++;\n      currentIdx = getNextIdx(currentIdx, array);\n    }\n    return currentIdx == 0;\n  }\n\n  public static int getNextIdx(int currentIdx, int[] array) {\n    int jump = array[currentIdx];\n    int nextIdx = (currentIdx + jump) % array.length;\n    return nextIdx >= 0 ? nextIdx : nextIdx + array.length;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.hasSingleCycle(new int[] {2, 3, 1, -4, -4, 2}));\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.hasSingleCycle(new int[] {2, 3, 1, -4, -4, 2}));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function hasSingleCycle(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.hasSingleCycle = hasSingleCycle;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunction hasSingleCycle(array) {\n  let numElementsVisited = 0;\n  let currentIdx = 0;\n  while (numElementsVisited < array.length) {\n    if (numElementsVisited > 0 && currentIdx === 0) return false;\n    numElementsVisited++;\n    currentIdx = getNextIdx(currentIdx, array);\n  }\n  return currentIdx === 0;\n}\n\nfunction getNextIdx(currentIdx, array) {\n  const jump = array[currentIdx];\n  const nextIdx = (currentIdx + jump) % array.length;\n  return nextIdx >= 0 ? nextIdx : nextIdx + array.length;\n}\n\nexports.hasSingleCycle = hasSingleCycle;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun hasSingleCycle(array: List<Int>): Boolean {\n    // Write your code here.\n    return false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(1) space - where n is the length of the input array\nfun hasSingleCycle(array: List<Int>): Boolean {\n    var numElementsVisited = 0\n    var currentIdx = 0\n    while (numElementsVisited < array.size) {\n        if (numElementsVisited > 0 && currentIdx == 0) return false\n        numElementsVisited++\n        currentIdx = getNextIdx(currentIdx, array)\n    }\n    return currentIdx == 0\n}\n\nfun getNextIdx(currentIdx: Int, array: List<Int>): Int {\n    val jump = array[currentIdx]\n    val nextIdx = (currentIdx + jump) % array.size\n    return if (nextIdx >= 0) nextIdx else nextIdx + array.size\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.hasSingleCycle as hasSingleCycle\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(hasSingleCycle(listOf(2, 3, 1, -4, -4, 2)))\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.hasSingleCycle as hasSingleCycle\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(hasSingleCycle(listOf(2, 3, 1, -4, -4, 2)))\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def hasSingleCycle(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space - where n is the length of the input array\ndef hasSingleCycle(array):\n    numElementsVisited = 0\n    currentIdx = 0\n    while numElementsVisited < len(array):\n        if numElementsVisited > 0 and currentIdx == 0:\n            return False\n        numElementsVisited += 1\n        currentIdx = getNextIdx(currentIdx, array)\n    return currentIdx == 0\n\n\ndef getNextIdx(currentIdx, array):\n    jump = array[currentIdx]\n    nextIdx = (currentIdx + jump) % len(array)\n    return nextIdx if nextIdx >= 0 else nextIdx + len(array)\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.hasSingleCycle([2, 3, 1, -4, -4, 2]), True)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.hasSingleCycle([2, 3, 1, -4, -4, 2]), True)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def hasSingleCycle(array)\n    # Write your code here.\n    return false\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def hasSingleCycle(array)\n    # Write your code here.\n    return false\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.hasSingleCycle\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.hasSingleCycle\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func hasSingleCycle(array: [Int]) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  func hasSingleCycle(array: [Int]) -> Bool {\n    var currentIndex = 0\n    var numberOfElementsVisited = 0\n\n    var innerArray = array\n    while numberOfElementsVisited < array.count {\n      if currentIndex == 0, numberOfElementsVisited > 0 {\n        return false\n      }\n\n      numberOfElementsVisited += 1\n      currentIndex = getNextIndex(&currentIndex, array: &innerArray)\n    }\n\n    return currentIndex == 0\n  }\n\n  func getNextIndex(_ currentIndex: inout Int, array: inout [Int]) -> Int {\n    let jump = array[currentIndex]\n    let nextIndex = (jump + currentIndex) % array.count\n\n    if nextIndex >= 0 {\n      return nextIndex\n    } else {\n      return nextIndex + array.count\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.hasSingleCycle(array: [2, 3, 1, -4, -4, 2]))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.hasSingleCycle(array: [2, 3, 1, -4, -4, 2]))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function hasSingleCycle(array: number[]) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nexport function hasSingleCycle(array: number[]) {\n  let numElementsVisited = 0;\n  let currentIdx = 0;\n  while (numElementsVisited < array.length) {\n    if (numElementsVisited > 0 && currentIdx === 0) return false;\n    numElementsVisited++;\n    currentIdx = getNextIdx(currentIdx, array);\n  }\n  return currentIdx === 0;\n}\n\nfunction getNextIdx(currentIdx: number, array: number[]) {\n  const jump = array[currentIdx];\n  const nextIdx = (currentIdx + jump) % array.length;\n  return nextIdx >= 0 ? nextIdx : nextIdx + array.length;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [2, 3, 1, -4, -4, 2],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [2, 3, 1, -4, -4, 2],
        },
        {
          array: [2, 2, -1],
        },
        {
          array: [2, 2, 2],
        },
        {
          array: [1, 1, 1, 1, 1],
        },
        {
          array: [-1, 2, 2],
        },
        {
          array: [0, 1, 1, 1, 1],
        },
        {
          array: [1, 1, 0, 1, 1],
        },
        {
          array: [1, 1, 1, 1, 2],
        },
        {
          array: [3, 5, 6, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2],
        },
        {
          array: [3, 5, 5, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, 1],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, -8],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, -26],
        },
        {
          array: [10, 11, -6, -23, -2, 3, 88, 908, -26],
        },
        {
          array: [10, 11, -6, -23, -2, 3, 88, 909, -26],
        },
        {
          array: [1, -1, 1, -1],
        },
      ],
      jsonTests: [
        {
          array: [2, 3, 1, -4, -4, 2],
        },
        {
          array: [2, 2, -1],
        },
        {
          array: [2, 2, 2],
        },
        {
          array: [1, 1, 1, 1, 1],
        },
        {
          array: [-1, 2, 2],
        },
        {
          array: [0, 1, 1, 1, 1],
        },
        {
          array: [1, 1, 0, 1, 1],
        },
        {
          array: [1, 1, 1, 1, 2],
        },
        {
          array: [3, 5, 6, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2],
        },
        {
          array: [3, 5, 5, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, 1],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, -8],
        },
        {
          array: [1, 2, 3, 4, -2, 3, 7, 8, -26],
        },
        {
          array: [10, 11, -6, -23, -2, 3, 88, 908, -26],
        },
        {
          array: [10, 11, -6, -23, -2, 3, 88, 909, -26],
        },
        {
          array: [1, -1, 1, -1],
        },
      ],
      changelog: [],
      id: 9,
    },
    {
      uid: "longest-substring-without-duplication",
      testStrategy: "JSON",
      name: "Longest Substring Without Duplication",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Strings",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 12003,
        failureCount: 4642,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "225764436",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1309,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a string and returns its longest substring\n  without duplicate characters.\n</p>\n<p>You can assume that there will only be one longest substring without duplication.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "clementisacap"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"mentisac"\n</pre>\n</div>',
      hints: [
        "<p>\nTry traversing the input string and storing the last position at which you see each character in a hash table. How can this help you solve the given problem?\n</p>\n",
        "\n<p>\nAs you traverse the input string, keep track of a starting index variable. This variable, as its name suggests, should represent the most recent index from which you could start a substring with no duplicate characters, ending at your current index. Use the hash table mentioned in Hint #1 to update this variable correctly, and update the longest substring as you go.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(min(n, a)) space - where n is the length of the input string and a is the length of the character alphabet represented in the input string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            'using namespace std;\n\nstring longestSubstringWithoutDuplication(string str) {\n  // Write your code here.\n  return "";\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n// O(n) time | O(min(n, a)) space\nstring longestSubstringWithoutDuplication(string str) {\n  unordered_map<char, int> lastSeen;\n  vector<int> longest{0, 1};\n  int startIdx = 0;\n  for (int i = 0; i < str.length(); i++) {\n    char character = str[i];\n    if (lastSeen.find(character) != lastSeen.end()) {\n      startIdx = max(startIdx, lastSeen[character] + 1);\n    }\n    if (longest[1] - longest[0] < i + 1 - startIdx) {\n      longest = {startIdx, i + 1};\n    }\n    lastSeen[character] = i;\n  }\n  string result = str.substr(longest[0], longest[1] - longest[0]);\n  return result;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(longestSubstringWithoutDuplication("clementisacap") == "mentisac");\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(longestSubstringWithoutDuplication("clementisacap") == "mentisac");\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            'using System;\n\npublic class Program {\n\tpublic static string LongestSubstringWithoutDuplication(string str) {\n\t\t// Write your code here\n\t\treturn "";\n\t}\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n) time | O(min(n, a)) space\n\tpublic static string LongestSubstringWithoutDuplication(string str) {\n\t\tDictionary<char, int> lastSeen = new Dictionary<char, int>();\n\t\tint[] longest = {0, 1};\n\t\tint startIdx = 0;\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tchar c = str[i];\n\t\t\tif (lastSeen.ContainsKey(c)) {\n\t\t\t\tstartIdx = Math.Max(startIdx, lastSeen[c] + 1);\n\t\t\t}\n\t\t\tif (longest[1] - longest[0] < i + 1 - startIdx) {\n\t\t\t\tlongest = new int[] {startIdx, i + 1};\n\t\t\t}\n\t\t\tlastSeen[c] = i;\n\t\t}\n\t\tstring result = str.Substring(longest[0], longest[1] - longest[0]);\n\t\treturn result;\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.LongestSubstringWithoutDuplication("clementisacap").Equals(\n\t\t\t  "mentisac"));\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.LongestSubstringWithoutDuplication("clementisacap").Equals(\n\t\t\t  "mentisac"));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            'package main\n\nfunc LongestSubstringWithoutDuplication(str string) string {\n\t// Write your code here.\n\treturn ""\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype substring struct {\n\tleft  int\n\tright int\n}\n\nfunc (ss substring) length() int { return ss.right - ss.left }\n\n// O(n) time | O(min(n, a)) space\nfunc LongestSubstringWithoutDuplication(str string) string {\n\tlastSeen := map[rune]int{}\n\tlongest := substring{0, 1}\n\tstartIndex := 0\n\tfor i, char := range str {\n\t\tif seenIndex, found := lastSeen[char]; found &&\n\t\t\tstartIndex < seenIndex+1 {\n\t\t\tstartIndex = seenIndex + 1\n\t\t}\n\t\tif longest.length() < i+1-startIndex {\n\t\t\tlongest = substring{startIndex, i + 1}\n\t\t}\n\t\tlastSeen[char] = i\n\t}\n\treturn str[longest.left:longest.right]\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "mentisac"\n\toutput := LongestSubstringWithoutDuplication("clementisacap")\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := "mentisac"\n\toutput := LongestSubstringWithoutDuplication("clementisacap")\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            'import java.util.*;\n\nclass Program {\n  public static String longestSubstringWithoutDuplication(String str) {\n    // Write your code here\n    return "";\n  }\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(min(n, a)) space\n  public static String longestSubstringWithoutDuplication(String str) {\n    Map<Character, Integer> lastSeen = new HashMap<Character, Integer>();\n    int[] longest = {0, 1};\n    int startIdx = 0;\n    for (int i = 0; i < str.length(); i++) {\n      char c = str.charAt(i);\n      if (lastSeen.containsKey(c)) {\n        startIdx = Math.max(startIdx, lastSeen.get(c) + 1);\n      }\n      if (longest[1] - longest[0] < i + 1 - startIdx) {\n        longest = new int[] {startIdx, i + 1};\n      }\n      lastSeen.put(c, i);\n    }\n    String result = str.substring(longest[0], longest[1]);\n    return result;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.longestSubstringWithoutDuplication("clementisacap").equals("mentisac"));\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.longestSubstringWithoutDuplication("clementisacap").equals("mentisac"));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function longestSubstringWithoutDuplication(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestSubstringWithoutDuplication = longestSubstringWithoutDuplication;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(min(n, a)) space\nfunction longestSubstringWithoutDuplication(string) {\n  const lastSeen = {};\n  let longest = [0, 1];\n  let startIdx = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char in lastSeen) {\n      startIdx = Math.max(startIdx, lastSeen[char] + 1);\n    }\n    if (longest[1] - longest[0] < i + 1 - startIdx) {\n      longest = [startIdx, i + 1];\n    }\n    lastSeen[char] = i;\n  }\n  return string.slice(longest[0], longest[1]);\n}\n\nexports.longestSubstringWithoutDuplication = longestSubstringWithoutDuplication;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestSubstringWithoutDuplication('clementisacap')).to.deep.equal('mentisac');\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestSubstringWithoutDuplication('clementisacap')).to.deep.equal('mentisac');\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            'package com.algoexpert.program\n\nfun longestSubstringWithoutDuplication(string: String): String {\n    // Write your code here.\n    return ""\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(n) time | O(min(n, a)) space\nfun longestSubstringWithoutDuplication(string: String): String {\n    val lastSeen = mutableMapOf<Char, Int>()\n    var longest = Pair(0, 1)\n    var startIdx = 0\n    for (i in 0 until string.length) {\n        val char = string[i]\n        if (char in lastSeen) {\n            startIdx = max(startIdx, lastSeen[char]!! + 1)\n        }\n        if (longest.second - longest.first < i + 1 - startIdx) {\n            longest = Pair(startIdx, i + 1)\n        }\n        lastSeen[char] = i\n    }\n    return string.substring(longest.first, longest.second)\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestSubstringWithoutDuplication as longestSubstringWithoutDuplication\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(longestSubstringWithoutDuplication("clementisacap") == "mentisac")\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.longestSubstringWithoutDuplication as longestSubstringWithoutDuplication\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(longestSubstringWithoutDuplication("clementisacap") == "mentisac")\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def longestSubstringWithoutDuplication(string):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(min(n, a)) space\ndef longestSubstringWithoutDuplication(string):\n    lastSeen = {}\n    longest = [0, 1]\n    startIdx = 0\n    for i, char in enumerate(string):\n        if char in lastSeen:\n            startIdx = max(startIdx, lastSeen[char] + 1)\n        if longest[1] - longest[0] < i + 1 - startIdx:\n            longest = [startIdx, i + 1]\n        lastSeen[char] = i\n    return string[longest[0] : longest[1]]\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.longestSubstringWithoutDuplication("clementisacap"), "mentisac")\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.longestSubstringWithoutDuplication("clementisacap"), "mentisac")\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            'class Program\n  def longestSubstringWithoutDuplication(string)\n    # Write your code here.\n    return ""\n  end\nend\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestSubstringWithoutDuplication(string)\n    # Write your code here.\n    return ""\n  end\nend\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestSubstringWithoutDuplication\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestSubstringWithoutDuplication\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            'class Program {\n  func longestSubstringWithoutDuplication(_ string: String) -> String {\n    // Write your code here.\n    return ""\n  }\n}\n',
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(min(n, a)) space\n  func longestSubstringWithoutDuplication(_ string: String) -> String {\n    var startingPointer = 0\n    var indicesOfLongestSubstring = [0, 1]\n    var indicesDictionary = [Character: Int]()\n\n    for (index, character) in string.enumerated() {\n      if let index = indicesDictionary[character] {\n        startingPointer = max(startingPointer, index + 1)\n      }\n\n      if indicesOfLongestSubstring[1] - indicesOfLongestSubstring[0] < index + 1 - startingPointer {\n        indicesOfLongestSubstring = [startingPointer, index + 1]\n      }\n\n      indicesDictionary[character] = index\n    }\n\n    let start = indicesOfLongestSubstring[0]\n    let startingIndex = string.index(string.startIndex, offsetBy: start)\n\n    let end = indicesOfLongestSubstring[1]\n    let endingIndex = string.index(string.startIndex, offsetBy: end)\n\n    return String(string[startingIndex ..< endingIndex])\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("mentisac", program.longestSubstringWithoutDuplication("clementisacap"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual("mentisac", program.longestSubstringWithoutDuplication("clementisacap"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function longestSubstringWithoutDuplication(string: string) {\n  // Write your code here.\n  return '';\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(min(n, a)) space\nexport function longestSubstringWithoutDuplication(string: string) {\n  const lastSeen: {[key: string]: number} = {};\n  let longest = [0, 1];\n  let startIdx = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char in lastSeen) {\n      startIdx = Math.max(startIdx, lastSeen[char] + 1);\n    }\n    if (longest[1] - longest[0] < i + 1 - startIdx) {\n      longest = [startIdx, i + 1];\n    }\n    lastSeen[char] = i;\n  }\n  return string.slice(longest[0], longest[1]);\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.longestSubstringWithoutDuplication('clementisacap')).to.deep.equal('mentisac');\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.longestSubstringWithoutDuplication('clementisacap')).to.deep.equal('mentisac');\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "clementisacap",
          schema: {
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "clementisacap",
        },
        {
          string: "a",
        },
        {
          string: "abc",
        },
        {
          string: "abcb",
        },
        {
          string: "abcdeabcdefc",
        },
        {
          string: "abccdeaabbcddef",
        },
        {
          string: "abacacacaaabacaaaeaaafa",
        },
        {
          string: "abcdabcef",
        },
        {
          string: "abcbde",
        },
        {
          string: "clementisanarm",
        },
      ],
      jsonTests: [
        {
          string: "clementisacap",
        },
        {
          string: "a",
        },
        {
          string: "abc",
        },
        {
          string: "abcb",
        },
        {
          string: "abcdeabcdefc",
        },
        {
          string: "abccdeaabbcddef",
        },
        {
          string: "abacacacaaabacaaaeaaafa",
        },
        {
          string: "abcdabcef",
        },
        {
          string: "abcbde",
        },
        {
          string: "clementisanarm",
        },
      ],
      changelog: [],
      id: 10,
    },
    {
      uid: "count-inversions",
      testStrategy: "JSON",
      name: "Count Inversions",
      version: 0,
      releaseDate: "2021-04-01T00:00:00Z",
      category: "Sorting",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 1791,
        failureCount: 553,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "524085085",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1643,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns the number of\n  inversions in the array. An inversion occurs if for any valid indices\n  <span>i</span> and <span>j</span>, <span>i &lt; j</span> and\n  <span>array[i] > array[j]</span>.\n</p>\n<p>\n  For example, given <span>array = [3, 4, 1, 2]</span>, there are\n  <span>4</span> inversions. The following pairs of indices represent\n  inversions: <span>[0, 2], [0, 3], [1, 2], [1, 3]</span>.\n</p>\n<p>\n  Intuitively, the number of inversions is a measure of how unsorted the array\n  is.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 3, 3, 1, 9, 5, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n<span class="CodeEditor-promptComment">// The following pairs of indices represent inversions:</span>\n<span class="CodeEditor-promptComment">// [0, 3], [1, 3], [2, 3], [4, 5], [4, 6]</span>\n</pre>\n</div>',
      hints: [
        "<p>\n  The brute-force approach to solve this problem is to simply compare every pair\n  of indices in the array and to determine how many of them represent\n  inversions. This approach takes <span>O(n^2)</span> time, where n is the\n  length of the array. Can you do better than this?\n</p>\n",
        "\n<p>\n  If the number of inversions is the degree to which the array is unsorted, and\n  it if it takes <span>O(nlog(n))</span> time to sort an array using an optimal\n  sorting algorithm, can you determine how unsorted the array is with a solution\n  that runs in that time complexity?\n</p>\n",
        "\n<p>\n  Try thinking about how you would solve this problem if, instead of being given\n  one array, you were given two separate arrays representing the main array's\n  two halves. You would need to determine the number of inversions in the array\n  created by merging the left array and the right array. The number of\n  inversions in this example is actually equal to the number of inversions in\n  the left array, the number of inversions in the right array, <b>and</b> the\n  number of inversions when you merge the <b>sorted</b> left array and the\n  <b>sorted</b> right array. Recall how Merge Sort works for a hint about how\n  you can solve this problem.\n</p>\n",
        "\n<p>\n  Once you understand the information stated in Hint #3, you can use an\n  algorithm that's very similar to Merge Sort to determine the number of\n  inversions in any array. You'll recursively determine the number of inversions\n  in the left and right halves of an array while sorting both the left and right\n  halves, just like you do in Merge Sort. Once your two halves are sorted,\n  you'll merge them together and count the number of inversions in the merged\n  array. Take the example of these two sorted arrays:\n  <span>a1 = [1, 3, 4]</span> and <span>a2 = [2, 2, 5]</span>. When you merge\n  these two sorted arrays, you insert elements from the left and right array\n  into one larger array. Whenever you insert an element from the right array\n  before inserting an element from the left array, that means an inversion or\n  multiple inversions have occurred. This is because elements in the right array\n  are positioned after all elements in the left array (if these two arrays were\n  originally left and right halves of another array). The remaining elements to\n  be inserted from the left array when we insert an element from the right array\n  are all inverted with this right-array element. See the Conceptual Overview\n  section of this question's video explanation for a more in-depth explanation.\n</p>",
      ],
      spaceTime:
        "O(nlogn) time | O(n) space - where n is the length of the array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint countInversions(vector<int> array) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint countSubArrayInversions(vector<int> &array, int start, int end);\nint mergeSortAndCountInversions(vector<int> &array, int start, int middle,\n                                int end);\n\n// O(nlogn) time | O(n) space - where n is the length of the array\nint countInversions(vector<int> array) {\n  return countSubArrayInversions(array, 0, array.size());\n}\n\nint countSubArrayInversions(vector<int> &array, int start, int end) {\n  if (end - start <= 1)\n    return 0;\n\n  int middle = start + ((end - start) / 2);\n  int leftInversions = countSubArrayInversions(array, start, middle);\n  int rightInversions = countSubArrayInversions(array, middle, end);\n  int mergedArrayInversions =\n      mergeSortAndCountInversions(array, start, middle, end);\n  return leftInversions + rightInversions + mergedArrayInversions;\n}\n\nint mergeSortAndCountInversions(vector<int> &array, int start, int middle,\n                                int end) {\n  vector<int> sortedArray;\n  int left = start;\n  int right = middle;\n  int inversions = 0;\n\n  while (left < middle && right < end) {\n    if (array[left] <= array[right]) {\n      sortedArray.push_back(array[left]);\n      left++;\n    } else {\n      inversions += middle - left;\n      sortedArray.push_back(array[right]);\n      right++;\n    }\n  }\n\n  for (int idx = left; idx < middle; idx++) {\n    sortedArray.push_back(array[idx]);\n  }\n\n  for (int idx = right; idx < end; idx++) {\n    sortedArray.push_back(array[idx]);\n  }\n\n  for (int idx = 0; idx < sortedArray.size(); idx++) {\n    int num = sortedArray[idx];\n    array[start + idx] = num;\n  }\n\n  return inversions;\n}",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      auto input = {2, 3, 3, 1, 9, 5, 6};\n      auto expected = 5;\n      auto actual = countInversions(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      auto input = {2, 3, 3, 1, 9, 5, 6};\n      auto expected = 5;\n      auto actual = countInversions(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic int CountInversions(int[] array) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(nlogn) time | O(n) space - where n is the length of the array\n\tpublic int CountInversions(int[] array) {\n\t\treturn countSubArrayInversions(array, 0, array.Length);\n\t}\n\n\tpublic int countSubArrayInversions(int[] array, int start, int end) {\n\t\tif (end - start <= 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint middle = start + (end - start) / 2;\n\t\tint leftInversions = countSubArrayInversions(array, start, middle);\n\t\tint rightInversions = countSubArrayInversions(array, middle, end);\n\t\tint mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end);\n\t\treturn leftInversions + rightInversions + mergedArrayInversions;\n\t}\n\n\tpublic int mergeSortAndCountInversions(int[] array, int start, int middle, int end) {\n\t\tList<int> sortedArray = new List<int>();\n\t\tint left = start;\n\t\tint right = middle;\n\t\tint inversions = 0;\n\n\t\twhile (left < middle && right < end) {\n\t\t\tif (array[left] <= array[right]) {\n\t\t\t\tsortedArray.Add(array[left]);\n\t\t\t\tleft += 1;\n\t\t\t} else {\n\t\t\t\tinversions += middle - left;\n\t\t\t\tsortedArray.Add(array[right]);\n\t\t\t\tright += 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int idx = left; idx < middle; idx++) {\n\t\t\tsortedArray.Add(array[idx]);\n\t\t}\n\n\t\tfor (int idx = right; idx < end; idx++) {\n\t\t\tsortedArray.Add(array[idx]);\n\t\t}\n\n\t\tfor (int idx = 0; idx < sortedArray.Count; idx++) {\n\t\t\tint num = sortedArray[idx];\n\t\t\tarray[start + idx] = num;\n\t\t}\n\n\t\treturn inversions;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = new int[] { 2, 3, 3, 1, 9, 5, 6 };\n\t\tvar expected = 5;\n\t\tvar actual = new Program().CountInversions(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = new int[] { 2, 3, 3, 1, 9, 5, 6 };\n\t\tvar expected = 5;\n\t\tvar actual = new Program().CountInversions(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc CountInversions(array []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(nlogn) time | O(n) space - where n is the length of the array\nfunc CountInversions(array []int) int {\n\treturn countSubArrayInversions(array, 0, len(array))\n}\n\nfunc countSubArrayInversions(array []int, start, end int) int {\n\tif end-start <= 1 {\n\t\treturn 0\n\t}\n\n\tmiddle := start + (end-start)/2\n\tleftInversions := countSubArrayInversions(array, start, middle)\n\trightInversions := countSubArrayInversions(array, middle, end)\n\tmergedArrayInversions := mergeSortAndCountInversions(array, start, middle, end)\n\treturn leftInversions + rightInversions + mergedArrayInversions\n}\n\nfunc mergeSortAndCountInversions(array []int, start, middle, end int) int {\n\tsortedArray := make([]int, 0)\n\tleft := start\n\tright := middle\n\tinversions := 0\n\n\tfor left < middle && right < end {\n\t\tif array[left] <= array[right] {\n\t\t\tsortedArray = append(sortedArray, array[left])\n\t\t\tleft += 1\n\t\t} else {\n\t\t\tinversions += middle - left\n\t\t\tsortedArray = append(sortedArray, array[right])\n\t\t\tright += 1\n\t\t}\n\t}\n\n\tsortedArray = append(sortedArray, array[left:middle]...)\n\tsortedArray = append(sortedArray, array[right:end]...)\n\tfor idx := range sortedArray {\n\t\tnum := sortedArray[idx]\n\t\tarray[start+idx] = num\n\t}\n\n\treturn inversions\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 3, 3, 1, 9, 5, 6}\n\texpected := 5\n\tactual := CountInversions(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 3, 3, 1, 9, 5, 6}\n\texpected := 5\n\tactual := CountInversions(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public int countInversions(int[] array) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(nlogn) time | O(n) space - where n is the length of the array\n  public int countInversions(int[] array) {\n    return countSubArrayInversions(array, 0, array.length);\n  }\n\n  public int countSubArrayInversions(int[] array, int start, int end) {\n    if (end - start <= 1) {\n      return 0;\n    }\n\n    int middle = start + (end - start) / 2;\n    int leftInversions = countSubArrayInversions(array, start, middle);\n    int rightInversions = countSubArrayInversions(array, middle, end);\n    int mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end);\n    return leftInversions + rightInversions + mergedArrayInversions;\n  }\n\n  public int mergeSortAndCountInversions(int[] array, int start, int middle, int end) {\n    List<Integer> sortedArray = new ArrayList<Integer>();\n    int left = start;\n    int right = middle;\n    int inversions = 0;\n\n    while (left < middle && right < end) {\n      if (array[left] <= array[right]) {\n        sortedArray.add(array[left]);\n        left += 1;\n      } else {\n        inversions += middle - left;\n        sortedArray.add(array[right]);\n        right += 1;\n      }\n    }\n\n    for (int idx = left; idx < middle; idx++) {\n      sortedArray.add(array[idx]);\n    }\n\n    for (int idx = right; idx < end; idx++) {\n      sortedArray.add(array[idx]);\n    }\n\n    for (int idx = 0; idx < sortedArray.size(); idx++) {\n      int num = sortedArray.get(idx);\n      array[start + idx] = num;\n    }\n\n    return inversions;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = new int[] {2, 3, 3, 1, 9, 5, 6};\n    var expected = 5;\n    var actual = new Program().countInversions(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = new int[] {2, 3, 3, 1, 9, 5, 6};\n    var expected = 5;\n    var actual = new Program().countInversions(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function countInversions(array) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.countInversions = countInversions;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(n) space - where n is the length of the array\nfunction countInversions(array) {\n  return countSubArrayInversions(array, 0, array.length);\n}\n\nfunction countSubArrayInversions(array, start, end) {\n  if (end - start <= 1) return 0;\n\n  const middle = start + Math.floor((end - start) / 2);\n  const leftInversions = countSubArrayInversions(array, start, middle);\n  const rightInversions = countSubArrayInversions(array, middle, end);\n  const mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end);\n  return leftInversions + rightInversions + mergedArrayInversions;\n}\n\nfunction mergeSortAndCountInversions(array, start, middle, end) {\n  const sortedArray = [];\n  let left = start;\n  let right = middle;\n  let inversions = 0;\n\n  while (left < middle && right < end) {\n    if (array[left] <= array[right]) {\n      sortedArray.push(array[left]);\n      left++;\n    } else {\n      inversions += middle - left;\n      sortedArray.push(array[right]);\n      right++;\n    }\n  }\n\n  sortedArray.push(...array.slice(left, middle), ...array.slice(right, end));\n  for (let idx = 0; idx < sortedArray.length; idx++) {\n    const num = sortedArray[idx];\n    array[start + idx] = num;\n  }\n\n  return inversions;\n}\n\n// Do not edit the line below.\nexports.countInversions = countInversions;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun countInversions(array: MutableList<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nlogn) time | O(n) space - where n is the length of the array\nfun countInversions(array: MutableList<Int>): Int {\n    return countSubArrayInversions(array, 0, array.size)\n}\n\nfun countSubArrayInversions(array: MutableList<Int>, start: Int, end: Int): Int {\n    if (end - start <= 1) return 0\n\n    val middle = start + (end - start) / 2\n    val leftInversions = countSubArrayInversions(array, start, middle)\n    val rightInversions = countSubArrayInversions(array, middle, end)\n    val mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end)\n    return leftInversions + rightInversions + mergedArrayInversions\n}\n\nfun mergeSortAndCountInversions(array: MutableList<Int>, start: Int, middle: Int, end: Int): Int {\n    val sortedArray = mutableListOf<Int>()\n    var left = start\n    var right = middle\n    var inversions = 0\n\n    while (left < middle && right < end) {\n        if (array[left] <= array[right]) {\n            sortedArray.add(array[left])\n            left += 1\n        } else {\n            inversions += middle - left\n            sortedArray.add(array[right])\n            right += 1\n        }\n    }\n\n    sortedArray += array.subList(left, middle) + array.subList(right, end)\n    for (idx in 0 until sortedArray.size) {\n        val num = sortedArray[idx]\n        array[start + idx] = num\n    }\n\n    return inversions\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.countInversions\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(2, 3, 3, 1, 9, 5, 6)\n        val expected = 5\n        val output = countInversions(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.countInversions\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(2, 3, 3, 1, 9, 5, 6)\n        val expected = 5\n        val output = countInversions(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def countInversions(array):\n    # Write your code here.\n    return 0\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nlogn) time | O(n) space - where n is the length of the array\ndef countInversions(array):\n    return countSubArrayInversions(array, 0, len(array))\n\n\ndef countSubArrayInversions(array, start, end):\n    if end - start <= 1:\n        return 0\n\n    middle = start + (end - start) // 2\n    leftInversions = countSubArrayInversions(array, start, middle)\n    rightInversions = countSubArrayInversions(array, middle, end)\n    mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end)\n    return leftInversions + rightInversions + mergedArrayInversions\n\n\ndef mergeSortAndCountInversions(array, start, middle, end):\n    sortedArray = []\n    left = start\n    right = middle\n    inversions = 0\n\n    while left < middle and right < end:\n        if array[left] <= array[right]:\n            sortedArray.append(array[left])\n            left += 1\n        else:\n            inversions += middle - left\n            sortedArray.append(array[right])\n            right += 1\n\n    sortedArray += array[left:middle] + array[right:end]\n    for idx, num in enumerate(sortedArray):\n        array[start + idx] = num\n\n    return inversions\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [2, 3, 3, 1, 9, 5, 6]\n        expected = 5\n        actual = program.countInversions(input)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [2, 3, 3, 1, 9, 5, 6]\n        expected = 5\n        actual = program.countInversions(input)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: false,
          startingCode:
            "class Program\n  def countInversions(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def countInversions(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.countInversions\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.countInversions\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func countInversions(_ array: inout [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlogn) time | O(n) space - where n is the length of the array\n  func countInversions(_ array: inout [Int]) -> Int {\n    return countSubArrayInversions(&array, 0, array.count)\n  }\n\n  func countSubArrayInversions(_ array: inout [Int], _ start: Int, _ end: Int) -> Int {\n    if end - start <= 1 {\n      return 0\n    }\n\n    let middle = start + (end - start) / 2\n    let leftInversions = countSubArrayInversions(&array, start, middle)\n    let rightInversions = countSubArrayInversions(&array, middle, end)\n    let mergedArrayInversions = mergeSortAndCountInversions(&array, start, middle, end)\n    return leftInversions + rightInversions + mergedArrayInversions\n  }\n\n  func mergeSortAndCountInversions(_ array: inout [Int], _ start: Int, _ middle: Int, _ end: Int) -> Int {\n    var sortedArray = [Int]()\n    var left = start\n    var right = middle\n    var inversions = 0\n\n    while left < middle, right < end {\n      if array[left] <= array[right] {\n        sortedArray.append(array[left])\n        left += 1\n      } else {\n        inversions += middle - left\n        sortedArray.append(array[right])\n        right += 1\n      }\n    }\n\n    sortedArray += array[left ..< middle] + array[right ..< end]\n    for idx in 0 ..< sortedArray.count {\n      let num = sortedArray[idx]\n      array[start + idx] = num\n    }\n\n    return inversions\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [2, 3, 3, 1, 9, 5, 6]\n      var expected = 5\n      var actual = Program().countInversions(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [2, 3, 3, 1, 9, 5, 6]\n      var expected = 5\n      var actual = Program().countInversions(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function countInversions(array: number[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(n) space - where n is the length of the array\nexport function countInversions(array: number[]) {\n  return countSubArrayInversions(array, 0, array.length);\n}\n\nfunction countSubArrayInversions(array: number[], start: number, end: number): number {\n  if (end - start <= 1) return 0;\n\n  const middle = start + Math.floor((end - start) / 2);\n  const leftInversions = countSubArrayInversions(array, start, middle);\n  const rightInversions = countSubArrayInversions(array, middle, end);\n  const mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end);\n  return leftInversions + rightInversions + mergedArrayInversions;\n}\n\nfunction mergeSortAndCountInversions(array: number[], start: number, middle: number, end: number) {\n  const sortedArray: number[] = [];\n  let left = start;\n  let right = middle;\n  let inversions = 0;\n\n  while (left < middle && right < end) {\n    if (array[left] <= array[right]) {\n      sortedArray.push(array[left]);\n      left++;\n    } else {\n      inversions += middle - left;\n      sortedArray.push(array[right]);\n      right++;\n    }\n  }\n\n  sortedArray.push(...array.slice(left, middle), ...array.slice(right, end));\n  for (let idx = 0; idx < sortedArray.length; idx++) {\n    const num = sortedArray[idx];\n    array[start + idx] = num;\n  }\n\n  return inversions;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [2, 3, 3, 1, 9, 5, 6],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [2, 3, 3, 1, 9, 5, 6],
        },
        {
          array: [],
        },
        {
          array: [1, 2, 3, 4, 5, 6, -1],
        },
        {
          array: [0, 2, 4, 5, 76],
        },
        {
          array: [54, 1, 2, 3, 4],
        },
        {
          array: [1, 10, 2, 8, 3, 7, 4, 6, 5],
        },
        {
          array: [2, -18],
        },
        {
          array: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
        },
        {
          array: [5, -1, 2, -4, 3, 4, 19, 87, 762, -8, 0],
        },
        {
          array: [1, 1, 1, 1, 1, 1, 1, 1],
        },
        {
          array: [1, 1, 1, 1, 0, 1, 1, 1],
        },
        {
          array: [2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [3, 2, 1, 1],
        },
        {
          array: [
            10, 7, 2, 3, 1, -9, -86, -862, 234, 312, 3421, 23, 0, 2, 1, 2,
          ],
        },
      ],
      jsonTests: [
        {
          array: [2, 3, 3, 1, 9, 5, 6],
        },
        {
          array: [],
        },
        {
          array: [1, 2, 3, 4, 5, 6, -1],
        },
        {
          array: [0, 2, 4, 5, 76],
        },
        {
          array: [54, 1, 2, 3, 4],
        },
        {
          array: [1, 10, 2, 8, 3, 7, 4, 6, 5],
        },
        {
          array: [2, -18],
        },
        {
          array: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
        },
        {
          array: [5, -1, 2, -4, 3, 4, 19, 87, 762, -8, 0],
        },
        {
          array: [1, 1, 1, 1, 1, 1, 1, 1],
        },
        {
          array: [1, 1, 1, 1, 0, 1, 1, 1],
        },
        {
          array: [2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3],
        },
        {
          array: [3, 1, 2],
        },
        {
          array: [3, 2, 1, 1],
        },
        {
          array: [
            10, 7, 2, 3, 1, -9, -86, -862, 234, 312, 3421, 23, 0, 2, 1, 2,
          ],
        },
      ],
      changelog: [],
      id: 11,
    },
    {
      uid: "breadth-first-search",
      testStrategy: "JSON",
      name: "Breadth-first Search",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Graphs",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 27320,
        failureCount: 8616,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226842858",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 932,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re given a <span>Node</span> class that has a <span>name</span> and an\n  array of optional <span>children</span> nodes. When put together, nodes form\n  an acyclic tree-like structure.\n</p>\n<p>\n  Implement the <span>breadthFirstSearch</span> method on the\n  <span>Node</span> class, which takes in an empty array, traverses the tree\n  using the Breadth-first Search approach (specifically navigating the tree from\n  left to right), stores all of the nodes\' names in the input array, and returns\n  it.\n</p>\n<p>\n  If you\'re unfamiliar with Breadth-first Search, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">graph</span> = A\n     /  |  \\\n    B   C   D\n   / \\     / \\\n  E   F   G   H\n     / \\   \\\n    I   J   K\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"]\n</pre>\n</div>',
      hints: [
        "<p>\nThe Breadth-first Search algorithm works by traversing a graph level by level. In other words, before traversing any Node's children Nodes, its sibling nodes must be traversed. How can you simply and effectively keep track of Nodes' children Nodes as you traverse them, all the while retaining the order in which you must traverse them?\n</p>\n",
        "\n<p>\nTry using a queue to store all of the future Nodes that you will need to explore as your traverse the graph. By adding Nodes' children Nodes to the queue every time you explore them and by using the First-In-First-Out property of the queue, you can traverse the graph in a Breadth-first Search way. Don't forget to add every Node's name to the input array as you traverse the graph.\n</p>",
      ],
      spaceTime:
        "O(v + e) time | O(v) space - where v is the number of vertices of the input graph and e is the number of edges of the input graph",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\n// Do not edit the class below except\n// for the breadthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\npublic:\n  string name;\n  vector<Node *> children;\n\n  Node(string str) { name = str; }\n\n  vector<string> breadthFirstSearch(vector<string> *array) {\n    // Write your code here.\n    return {};\n  }\n\n  Node *addChild(string name) {\n    Node *child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <deque>\nusing namespace std;\n\nclass Node {\npublic:\n  string name;\n  vector<Node *> children;\n\n  Node(string name) { this->name = name; }\n\n  // O(v + e) time | O(v) space\n  vector<string> breadthFirstSearch(vector<string> *array) {\n    deque<Node *> queue{this};\n    while (!queue.empty()) {\n      Node current = *queue.front();\n      queue.pop_front();\n      array->push_back(current.name);\n      for (int i = 0; i < current.children.size(); i++) {\n        queue.push_back(current.children[i]);\n      }\n    }\n    return *array;\n  }\n\n  Node *addChild(string name) {\n    Node *child = new Node(name);\n    children.push_back(child);\n    return this;\n  }\n};\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      Node graph("A");\n      graph.addChild("B")->addChild("C")->addChild("D");\n      graph.children[0]->addChild("E")->addChild("F");\n      graph.children[2]->addChild("G")->addChild("H");\n      graph.children[0]->children[1]->addChild("I")->addChild("J");\n      graph.children[2]->children[0]->addChild("K");\n\n      vector<string> expected{"A", "B", "C", "D", "E", "F",\n                              "G", "H", "I", "J", "K"};\n      vector<string> inputArray{};\n      assert(graph.breadthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      Node graph("A");\n      graph.addChild("B")->addChild("C")->addChild("D");\n      graph.children[0]->addChild("E")->addChild("F");\n      graph.children[2]->addChild("G")->addChild("H");\n      graph.children[0]->children[1]->addChild("I")->addChild("J");\n      graph.children[2]->children[0]->addChild("K");\n\n      vector<string> expected{"A", "B", "C", "D", "E", "F",\n                              "G", "H", "I", "J", "K"};\n      vector<string> inputArray{};\n      assert(graph.breadthFirstSearch(&inputArray) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// Do not edit the class below except\n\t// for the BreadthFirstSearch method.\n\t// Feel free to add new properties\n\t// and methods to the class.\n\tpublic class Node {\n\t\tpublic string name;\n\t\tpublic List<Node> children = new List<Node>();\n\n\t\tpublic Node(string name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic List<string> BreadthFirstSearch(List<string> array) {\n\t\t\t// Write your code here.\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Node AddChild(string name) {\n\t\t\tNode child = new Node(name);\n\t\t\tchildren.Add(child);\n\t\t\treturn this;\n\t\t}\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic class Node {\n\t\tpublic string name;\n\t\tpublic List<Node> children = new List<Node>();\n\n\t\tpublic Node(string name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t// O(v + e) time | O(v) space\n\t\tpublic List<string> BreadthFirstSearch(List<string> array) {\n\t\t\tQueue<Node> queue = new Queue<Node>();\n\t\t\tqueue.Enqueue(this);\n\t\t\twhile (queue.Count > 0) {\n\t\t\t\tNode current = queue.Dequeue();\n\t\t\t\tarray.Add(current.name);\n\t\t\t\tcurrent.children.ForEach(o => queue.Enqueue(o));\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Node AddChild(string name) {\n\t\t\tNode child = new Node(name);\n\t\t\tchildren.Add(child);\n\t\t\treturn this;\n\t\t}\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.Node graph = new Program.Node("A");\n\t\tgraph.AddChild("B").AddChild("C").AddChild("D");\n\t\tgraph.children[0].AddChild("E").AddChild("F");\n\t\tgraph.children[2].AddChild("G").AddChild("H");\n\t\tgraph.children[0].children[1].AddChild("I").AddChild("J");\n\t\tgraph.children[2].children[0].AddChild("K");\n\t\tstring[] expected = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"};\n\t\tList<string> inputArray = new List<string>();\n\t\tUtils.AssertTrue(compare(graph.BreadthFirstSearch(inputArray), expected));\n\t}\n\n\tpublic static bool compare(List<string> arr1, string[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (!arr1[i].Equals(arr2[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n',
          unitTests:
            'using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.Node graph = new Program.Node("A");\n\t\tgraph.AddChild("B").AddChild("C").AddChild("D");\n\t\tgraph.children[0].AddChild("E").AddChild("F");\n\t\tgraph.children[2].AddChild("G").AddChild("H");\n\t\tgraph.children[0].children[1].AddChild("I").AddChild("J");\n\t\tgraph.children[2].children[0].AddChild("K");\n\t\tstring[] expected = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"};\n\t\tList<string> inputArray = new List<string>();\n\t\tUtils.AssertTrue(compare(graph.BreadthFirstSearch(inputArray), expected));\n\t}\n\n\tpublic static bool compare(List<string> arr1, string[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (!arr1[i].Equals(arr2[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\n// Do not edit the class below except\n// for the breadthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\nfunc (n *Node) BreadthFirstSearch(array []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Node struct {\n\tName     string\n\tChildren []*Node\n}\n\n// O(v + e) time | O(v) space\nfunc (n *Node) BreadthFirstSearch(array []string) []string {\n\tqueue := []*Node{n}\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tarray = append(array, current.Name)\n\t\tfor _, child := range current.Children {\n\t\t\tqueue = append(queue, child)\n\t\t}\n\t}\n\treturn array\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode("A").AddChildren("B", "C", "D")\n\tgraph.Children[0].AddChildren("E").AddChildren("F")\n\tgraph.Children[2].AddChildren("G").AddChildren("H")\n\tgraph.Children[0].Children[1].AddChildren("I").AddChildren("J")\n\tgraph.Children[2].Children[0].AddChildren("K")\n\toutput := graph.BreadthFirstSearch([]string{})\n\texpected := []string{"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"}\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc NewNode(name string) *Node {\n\treturn &Node{\n\t\tName:     name,\n\t\tChildren: []*Node{},\n\t}\n}\n\nfunc (n *Node) AddChildren(names ...string) *Node {\n\tfor _, name := range names {\n\t\tchild := Node{Name: name}\n\t\tn.Children = append(n.Children, &child)\n\t}\n\treturn n\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar graph = NewNode("A").AddChildren("B", "C", "D")\n\tgraph.Children[0].AddChildren("E").AddChildren("F")\n\tgraph.Children[2].AddChildren("G").AddChildren("H")\n\tgraph.Children[0].Children[1].AddChildren("I").AddChildren("J")\n\tgraph.Children[2].Children[0].AddChildren("K")\n\toutput := graph.BreadthFirstSearch([]string{})\n\texpected := []string{"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"}\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  // Do not edit the class below except\n  // for the breadthFirstSearch method.\n  // Feel free to add new properties\n  // and methods to the class.\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    public List<String> breadthFirstSearch(List<String> array) {\n      // Write your code here.\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class Node {\n    String name;\n    List<Node> children = new ArrayList<Node>();\n\n    public Node(String name) {\n      this.name = name;\n    }\n\n    // O(v + e) time | O(v) space\n    public List<String> breadthFirstSearch(List<String> array) {\n      Queue<Node> queue = new LinkedList<Node>();\n      queue.add(this);\n      while (!queue.isEmpty()) {\n        Node current = queue.poll();\n        array.add(current.name);\n        queue.addAll(current.children);\n      }\n      return array;\n    }\n\n    public Node addChild(String name) {\n      Node child = new Node(name);\n      children.add(child);\n      return this;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node("A");\n    graph.addChild("B").addChild("C").addChild("D");\n    graph.children.get(0).addChild("E").addChild("F");\n    graph.children.get(2).addChild("G").addChild("H");\n    graph.children.get(0).children.get(1).addChild("I").addChild("J");\n    graph.children.get(2).children.get(0).addChild("K");\n    String[] expected = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.breadthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Program.Node graph = new Program.Node("A");\n    graph.addChild("B").addChild("C").addChild("D");\n    graph.children.get(0).addChild("E").addChild("F");\n    graph.children.get(2).addChild("G").addChild("H");\n    graph.children.get(0).children.get(1).addChild("I").addChild("J");\n    graph.children.get(2).children.get(0).addChild("K");\n    String[] expected = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"};\n    List<String> inputArray = new ArrayList<String>();\n    Utils.assertTrue(compare(graph.breadthFirstSearch(inputArray), expected));\n  }\n\n  public static boolean compare(List<String> arr1, String[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (!arr1.get(i).equals(arr2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// Do not edit the class below except\n// for the breadthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  breadthFirstSearch(array) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  breadthFirstSearch(array) {\n    const queue = [this];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      array.push(current.name);\n      for (const child of current.children) {\n        queue.push(child);\n      }\n    }\n    return array;\n  }\n}\n\nexports.Node = Node;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.breadthFirstSearch([])).to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.breadthFirstSearch([])).to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    fun breadthFirstSearch(): List<String> {\n        // Write your code here.\n        return listOf()\n    }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport java.util.LinkedList\nimport java.util.Queue\n\nclass Node(name: String) {\n    val name: String = name\n    val children = mutableListOf<Node>()\n\n    // O(v + e) time | O(v) space\n    fun breadthFirstSearch(): List<String> {\n        val array = mutableListOf<String>()\n        val queue: Queue<Node> = LinkedList<Node>()\n        queue.add(this)\n        while (queue.size != 0) {\n            val current = queue.poll()\n            array.add(current.name)\n            queue.addAll(current.children)\n        }\n        return array\n    }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node("I")\n        val j = Node("J")\n        val k = Node("K")\n\n        val e = Node("E")\n        val f = Node("F")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node("G")\n        g.children.add(k)\n\n        val h = Node("H")\n\n        val b = Node("B")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node("C")\n\n        val d = Node("D")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node("A")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")\n        val output = graph.breadthFirstSearch()\n        assert(expected == output)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.Node\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val i = Node("I")\n        val j = Node("J")\n        val k = Node("K")\n\n        val e = Node("E")\n        val f = Node("F")\n        f.children.addAll(listOf(i, j))\n\n        val g = Node("G")\n        g.children.add(k)\n\n        val h = Node("H")\n\n        val b = Node("B")\n        b.children.add(e)\n        b.children.add(f)\n\n        val c = Node("C")\n\n        val d = Node("D")\n        d.children.add(g)\n        d.children.add(h)\n\n        val graph = Node("A")\n        graph.children.add(b)\n        graph.children.add(c)\n        graph.children.add(d)\n\n        val expected = listOf("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K")\n        val output = graph.breadthFirstSearch()\n        assert(expected == output)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "# Do not edit the class below except\n# for the breadthFirstSearch method.\n# Feel free to add new properties\n# and methods to the class.\nclass Node:\n    def __init__(self, name):\n        self.children = []\n        self.name = name\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    def breadthFirstSearch(self, array):\n        # Write your code here.\n        pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.children = []\n\n    def addChild(self, name):\n        self.children.append(Node(name))\n        return self\n\n    # O(v + e) time | O(v) space\n    def breadthFirstSearch(self, array):\n        queue = [self]\n        while len(queue) > 0:\n            current = queue.pop(0)\n            array.append(current.name)\n            for child in current.children:\n                queue.append(child)\n        return array\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node("A")\n        graph.addChild("B").addChild("C").addChild("D")\n        graph.children[0].addChild("E").addChild("F")\n        graph.children[2].addChild("G").addChild("H")\n        graph.children[0].children[1].addChild("I").addChild("J")\n        graph.children[2].children[0].addChild("K")\n        self.assertEqual(graph.breadthFirstSearch([]), ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"])\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        graph = program.Node("A")\n        graph.addChild("B").addChild("C").addChild("D")\n        graph.children[0].addChild("E").addChild("F")\n        graph.children[2].addChild("G").addChild("H")\n        graph.children[0].children[1].addChild("I").addChild("J")\n        graph.children[2].children[0].addChild("K")\n        self.assertEqual(graph.breadthFirstSearch([]), ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"])\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  class Node {\n    var name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    func breadthFirstSearch(array: inout [String]) -> [String] {\n      // Write your code here.\n      return []\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Node {\n    var name: String\n    var children: [Node]\n\n    init(name: String) {\n      self.name = name\n      children = []\n    }\n\n    func addChild(name: String) -> Node {\n      let childNode = Node(name: name)\n      children.append(childNode)\n\n      return self\n    }\n\n    // O(v + e) time | O(v) space\n    func breadthFirstSearch(array: inout [String]) -> [String] {\n      var queue = [self]\n\n      while queue.count > 0 {\n        let currentNode = queue.removeFirst()\n        array.append(currentNode.name)\n\n        for child in currentNode.children {\n          queue.append(child)\n        }\n      }\n\n      return array\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let graph = Program.Node(name: "A")\n      graph.addChild(name: "B").addChild(name: "C").addChild(name: "D")\n      graph.children[0].addChild(name: "E").addChild(name: "F")\n      graph.children[2].addChild(name: "G").addChild(name: "H")\n      graph.children[0].children[1].addChild(name: "I").addChild(name: "J")\n      graph.children[2].children[0].addChild(name: "K")\n\n      var arrayToReturn = [String]()\n      try assertEqual(["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"], graph.breadthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let graph = Program.Node(name: "A")\n      graph.addChild(name: "B").addChild(name: "C").addChild(name: "D")\n      graph.children[0].addChild(name: "E").addChild(name: "F")\n      graph.children[2].addChild(name: "G").addChild(name: "H")\n      graph.children[0].children[1].addChild(name: "I").addChild(name: "J")\n      graph.children[2].children[0].addChild(name: "K")\n\n      var arrayToReturn = [String]()\n      try assertEqual(["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"], graph.breadthFirstSearch(array: &arrayToReturn))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "// Do not edit the class below except\n// for the breadthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string): Node {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  breadthFirstSearch(array: string[]) {\n    // Write your code here.\n    return array;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nexport class Node {\n  name: string;\n  children: Node[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name: string): Node {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  breadthFirstSearch(array: string[]) {\n    const queue: Node[] = [this];\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      array.push(current.name);\n      for (const child of current.children) {\n        queue.push(child);\n      }\n    }\n    return array;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.breadthFirstSearch([])).to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai.expect(graph.breadthFirstSearch([])).to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "graph",
          example: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
          schema: {
            description:
              "For the purpose of this question, a <span>graph</span> is represented by a list of <span>nodes</span> and a <span>startNode</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes' lists of <span>children</span> and by the <span>startNode</span>.\nThe searching function will be called on the <span>startNode</span>.<br />\nRemember that your graph shouldn't have cycles!\n",
            properties: {
              nodes: {
                items: {
                  properties: {
                    children: {
                      items: {
                        type: "string",
                      },
                      type: "array",
                      uniqueItems: true,
                    },
                    id: {
                      type: "string",
                    },
                    value: {
                      type: "string",
                    },
                  },
                  required: ["id", "value", "children"],
                  type: "object",
                },
                type: "array",
              },
              startNode: {
                type: "string",
              },
            },
            required: ["startNode", "nodes"],
            type: "object",
          },
        },
      ],
      tests: [
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C"],
                id: "A",
                value: "A",
              },
              {
                children: ["D"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E"],
                id: "A",
                value: "A",
              },
              {
                children: [],
                id: "B",
                value: "B",
              },
              {
                children: ["F"],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B"],
                id: "A",
                value: "A",
              },
              {
                children: ["C"],
                id: "B",
                value: "B",
              },
              {
                children: ["D", "E"],
                id: "C",
                value: "C",
              },
              {
                children: ["F"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E", "F"],
                id: "A",
                value: "A",
              },
              {
                children: ["G", "H", "I"],
                id: "B",
                value: "B",
              },
              {
                children: ["J"],
                id: "C",
                value: "C",
              },
              {
                children: ["K", "L"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["M", "N"],
                id: "F",
                value: "F",
              },
              {
                children: [],
                id: "G",
                value: "G",
              },
              {
                children: ["O", "P", "Q", "R"],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: ["S"],
                id: "K",
                value: "K",
              },
              {
                children: [],
                id: "L",
                value: "L",
              },
              {
                children: [],
                id: "M",
                value: "M",
              },
              {
                children: [],
                id: "N",
                value: "N",
              },
              {
                children: [],
                id: "O",
                value: "O",
              },
              {
                children: ["T", "U"],
                id: "P",
                value: "P",
              },
              {
                children: [],
                id: "Q",
                value: "Q",
              },
              {
                children: ["V"],
                id: "R",
                value: "R",
              },
              {
                children: [],
                id: "S",
                value: "S",
              },
              {
                children: [],
                id: "T",
                value: "T",
              },
              {
                children: [],
                id: "U",
                value: "U",
              },
              {
                children: ["W", "X", "Y"],
                id: "V",
                value: "V",
              },
              {
                children: [],
                id: "W",
                value: "W",
              },
              {
                children: ["Z"],
                id: "X",
                value: "X",
              },
              {
                children: [],
                id: "Y",
                value: "Y",
              },
              {
                children: [],
                id: "Z",
                value: "Z",
              },
            ],
            startNode: "A",
          },
        },
      ],
      jsonTests: [
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D"],
                id: "A",
                value: "A",
              },
              {
                children: ["E", "F"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: ["G", "H"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["I", "J"],
                id: "F",
                value: "F",
              },
              {
                children: ["K"],
                id: "G",
                value: "G",
              },
              {
                children: [],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: [],
                id: "K",
                value: "K",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C"],
                id: "A",
                value: "A",
              },
              {
                children: ["D"],
                id: "B",
                value: "B",
              },
              {
                children: [],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E"],
                id: "A",
                value: "A",
              },
              {
                children: [],
                id: "B",
                value: "B",
              },
              {
                children: ["F"],
                id: "C",
                value: "C",
              },
              {
                children: [],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B"],
                id: "A",
                value: "A",
              },
              {
                children: ["C"],
                id: "B",
                value: "B",
              },
              {
                children: ["D", "E"],
                id: "C",
                value: "C",
              },
              {
                children: ["F"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: [],
                id: "F",
                value: "F",
              },
            ],
            startNode: "A",
          },
        },
        {
          graph: {
            nodes: [
              {
                children: ["B", "C", "D", "E", "F"],
                id: "A",
                value: "A",
              },
              {
                children: ["G", "H", "I"],
                id: "B",
                value: "B",
              },
              {
                children: ["J"],
                id: "C",
                value: "C",
              },
              {
                children: ["K", "L"],
                id: "D",
                value: "D",
              },
              {
                children: [],
                id: "E",
                value: "E",
              },
              {
                children: ["M", "N"],
                id: "F",
                value: "F",
              },
              {
                children: [],
                id: "G",
                value: "G",
              },
              {
                children: ["O", "P", "Q", "R"],
                id: "H",
                value: "H",
              },
              {
                children: [],
                id: "I",
                value: "I",
              },
              {
                children: [],
                id: "J",
                value: "J",
              },
              {
                children: ["S"],
                id: "K",
                value: "K",
              },
              {
                children: [],
                id: "L",
                value: "L",
              },
              {
                children: [],
                id: "M",
                value: "M",
              },
              {
                children: [],
                id: "N",
                value: "N",
              },
              {
                children: [],
                id: "O",
                value: "O",
              },
              {
                children: ["T", "U"],
                id: "P",
                value: "P",
              },
              {
                children: [],
                id: "Q",
                value: "Q",
              },
              {
                children: ["V"],
                id: "R",
                value: "R",
              },
              {
                children: [],
                id: "S",
                value: "S",
              },
              {
                children: [],
                id: "T",
                value: "T",
              },
              {
                children: [],
                id: "U",
                value: "U",
              },
              {
                children: ["W", "X", "Y"],
                id: "V",
                value: "V",
              },
              {
                children: [],
                id: "W",
                value: "W",
              },
              {
                children: ["Z"],
                id: "X",
                value: "X",
              },
              {
                children: [],
                id: "Y",
                value: "Y",
              },
              {
                children: [],
                id: "Z",
                value: "Z",
              },
            ],
            startNode: "A",
          },
        },
      ],
      changelog: [],
      id: 12,
    },
    {
      uid: "sort-stack",
      testStrategy: "JSON",
      name: "Sort Stack",
      version: 0,
      releaseDate: "2021-04-14T00:00:00Z",
      category: "Stacks",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 6603,
        failureCount: 1753,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "533446167",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1514,
      },
      prompt:
        "<div class=\"html\">\n<p>\n  Write a function that takes in an array of integers representing a stack,\n  recursively sorts the stack in place (i.e., doesn't create a brand new array),\n  and returns it.\n</p>\n<p>\n  The array must be treated as a stack, with the end of the array as the top of\n  the stack. Therefore, you're only allowed to\n</p>\n<ul>\n  <li>\n    Pop elements from the top of the stack by removing elements from the end of\n    the array using the built-in <span>.pop()</span> method in your programming\n    language of choice.\n  </li>\n  <li>\n    Push elements to the top of the stack by appending elements to the end of\n    the array using the built-in <span>.append()</span> method in your\n    programming language of choice.\n  </li>\n  <li>\n    Peek at the element on top of the stack by accessing the last element in the\n    array.\n  </li>\n</ul>\n<p>\n  You're not allowed to perform any other operations on the input array,\n  including accessing elements (except for the last element), moving elements,\n  etc.. You're also not allowed to use any other data structures, and your\n  solution must be recursive.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">stack</span> = [-5, 2, -2, 4, 3, 1]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-5, -2, 1, 2, 3, 4]\n</pre>\n</div>",
      hints: [
        "<p>\n  If you had to insert a single item into an already sorted stack, all the while\n  abiding by the constraints of this problem, how would you do that?\n</p>\n",
        "\n<p>\n  Inserting a single item in an already sorted stack is fairly simple: you can\n  pop elements off of the stack until you find an element that's smaller than or\n  equal to the value that you want to add. Then, you can push that value on top\n  of the stack and reinsert all the previously popped items back on top of the\n  stack in the reverse order in which you popped them off. The resulting stack\n  will still be sorted.\n</p>\n",
        "\n<p>\n  You can easily insert multiple items in an already sorted stack by just\n  repeatedly performing what's described in Hint #2. However, you'll need to\n  have an already sorted stack. To get an already sorted stack, you'll need to\n  pop all of the elements off the <i>unsorted</i> stack until it's eventually\n  empty, and then you'll need to push all of the items back on the stack,\n  inserting them in their sorted order one at a time.\n</p>\n",
        "\n<p>\n  If you're thinking about Hint #3 recursively, the steps are the following:\n</p>\n<ol>\n  <li>Pop an item from the top of the stack, and hold onto it in memory.</li>\n  <li>\n    Sort the rest of the stack. To do so, repeat step #1 until the stack is\n    empty, at which point you've reached the base case since an empty stack is\n    always sorted.\n  </li>\n  <li>\n    Insert the most recently popped off item from step #1 back into the now\n    sorted stack but in its proper sorted position. The first time that you\n    reinsert an item, it'll be inserted in an empty stack.\n  </li>\n</ol>",
      ],
      spaceTime:
        "O(n^2) time | O(n) space - where n is the length of the stack",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> sortStack(vector<int> &stack) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvoid insertInSortedStackOrder(vector<int> &stack, int value);\n\n// O(n^2) time | O(n) space - where n is the length of the stack\nvector<int> sortStack(vector<int> &stack) {\n  if (stack.size() == 0) {\n    return stack;\n  }\n\n  int top = stack.back();\n  stack.pop_back();\n\n  sortStack(stack);\n\n  insertInSortedStackOrder(stack, top);\n\n  return stack;\n}\n\nvoid insertInSortedStackOrder(vector<int> &stack, int value) {\n  if (stack.size() == 0 || stack.back() <= value) {\n    stack.push_back(value);\n    return;\n  }\n\n  int top = stack.back();\n  stack.pop_back();\n\n  insertInSortedStackOrder(stack, value);\n\n  stack.push_back(top);\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {-5, 2, -2, 4, 3, 1};\n      vector<int> expected = {-5, -2, 1, 2, 3, 4};\n      auto actual = sortStack(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {-5, 2, -2, 4, 3, 1};\n      vector<int> expected = {-5, -2, 1, 2, 3, 4};\n      auto actual = sortStack(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\tpublic List<int> SortStack(List<int> stack) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(n^2) time | O(n) space - where n is the length of the stack\n\tpublic List<int> SortStack(List<int> stack) {\n\t\tif (stack.Count == 0) {\n\t\t\treturn stack;\n\t\t}\n\n\t\tint top = stack[stack.Count - 1];\n\t\tstack.RemoveAt(stack.Count - 1);\n\n\t\tSortStack(stack);\n\n\t\tinsertInSortedOrder(stack, top);\n\n\t\treturn stack;\n\t}\n\n\tpublic void insertInSortedOrder(List<int> stack, int value) {\n\t\tif (stack.Count == 0 || (stack[stack.Count - 1] <= value)) {\n\t\t\tstack.Add(value);\n\t\t\treturn;\n\t\t}\n\n\t\tint top = stack[stack.Count - 1];\n\t\tstack.RemoveAt(stack.Count - 1);\n\n\t\tinsertInSortedOrder(stack, value);\n\n\t\tstack.Add(top);\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<int> stack = new List<int> {\n\t\t\t-5, 2, -2, 4, 3, 1\n\t\t};\n\t\tList<int> expected = new List<int> {\n\t\t\t-5, -2, 1, 2, 3, 4\n\t\t};\n\t\tvar actual = new Program().SortStack(stack);\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n\t}\n}\n",
          unitTests:
            "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<int> stack = new List<int> {\n\t\t\t-5, 2, -2, 4, 3, 1\n\t\t};\n\t\tList<int> expected = new List<int> {\n\t\t\t-5, -2, 1, 2, 3, 4\n\t\t};\n\t\tvar actual = new Program().SortStack(stack);\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc SortStack(stack []int) []int {\n\t// Write your code here.\n\treturn []int{}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space - where n is the length of the stack\nfunc SortStack(stack []int) []int {\n\tif len(stack) == 0 {\n\t\treturn stack\n\t}\n\n\ttop := stack[len(stack)-1]\n\tstack = stack[:len(stack)-1]\n\tSortStack(stack)\n\n\tinsertInSortedOrder(&stack, top)\n\treturn stack\n}\n\nfunc insertInSortedOrder(stack *[]int, value int) {\n\tif len(*stack) == 0 || (*stack)[len(*stack)-1] <= value {\n\t\t*stack = append(*stack, value)\n\t\treturn\n\t}\n\n\ttop := (*stack)[len(*stack)-1]\n\t*stack = (*stack)[:len(*stack)-1]\n\tinsertInSortedOrder(stack, value)\n\t*stack = append(*stack, top)\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{-5, 2, -2, 4, 3, 1}\n\texpected := []int{-5, -2, 1, 2, 3, 4}\n\tactual := SortStack(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{-5, 2, -2, 4, 3, 1}\n\texpected := []int{-5, -2, 1, 2, 3, 4}\n\tactual := SortStack(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public ArrayList<Integer> sortStack(ArrayList<Integer> stack) {\n    // Write your code here.\n    return null;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n^2) time | O(n) space - where n is the length of the stack\n  public ArrayList<Integer> sortStack(ArrayList<Integer> stack) {\n    if (stack.size() == 0) {\n      return stack;\n    }\n\n    int top = stack.remove(stack.size() - 1);\n\n    sortStack(stack);\n\n    insertInSortedOrder(stack, top);\n\n    return stack;\n  }\n\n  public void insertInSortedOrder(ArrayList<Integer> stack, int value) {\n    if (stack.size() == 0 || (stack.get(stack.size() - 1) <= value)) {\n      stack.add(value);\n      return;\n    }\n\n    int top = stack.remove(stack.size() - 1);\n\n    insertInSortedOrder(stack, value);\n\n    stack.add(top);\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    ArrayList<Integer> stack = new ArrayList<Integer>(Arrays.asList(-5, 2, -2, 4, 3, 1));\n    ArrayList<Integer> expected = new ArrayList<Integer>(Arrays.asList(-5, -2, 1, 2, 3, 4));\n    var actual = new Program().sortStack(stack);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    ArrayList<Integer> stack = new ArrayList<Integer>(Arrays.asList(-5, 2, -2, 4, 3, 1));\n    ArrayList<Integer> expected = new ArrayList<Integer>(Arrays.asList(-5, -2, 1, 2, 3, 4));\n    var actual = new Program().sortStack(stack);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function sortStack(stack) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sortStack = sortStack;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the stack\nfunction sortStack(stack) {\n  if (stack.length === 0) return stack;\n\n  const top = stack.pop();\n\n  sortStack(stack);\n\n  insertInSortedOrder(stack, top);\n\n  return stack;\n}\n\nfunction insertInSortedOrder(stack, value) {\n  if (stack.length === 0 || stack[stack.length - 1] <= value) {\n    stack.push(value);\n    return;\n  }\n\n  const top = stack.pop();\n\n  insertInSortedOrder(stack, value);\n\n  stack.push(top);\n}\n\n// Do not edit the line below.\nexports.sortStack = sortStack;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun sortStack(stack: MutableList<Int>): MutableList<Int> {\n    // Write your code here.\n    return mutableListOf()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space - where n is the length of the stack\nfun sortStack(stack: MutableList<Int>): MutableList<Int> {\n    if (stack.size == 0) return stack\n\n    val top = stack.removeAt(stack.size - 1)\n\n    sortStack(stack)\n\n    insertInSortedOrder(stack, top)\n\n    return stack\n}\n\nfun insertInSortedOrder(stack: MutableList<Int>, value: Int) {\n    if (stack.size == 0 || stack[stack.size - 1] <= value) {\n        stack.add(value)\n        return\n    }\n\n    val top = stack.removeAt(stack.size - 1)\n\n    insertInSortedOrder(stack, value)\n\n    stack.add(top)\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.sortStack\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(-5, 2, -2, 4, 3, 1)\n        val expected = mutableListOf(-5, -2, 1, 2, 3, 4)\n        val output = sortStack(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.sortStack\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(-5, 2, -2, 4, 3, 1)\n        val expected = mutableListOf(-5, -2, 1, 2, 3, 4)\n        val output = sortStack(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def sortStack(stack):\n    # Write your code here.\n    return []\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the length of the stack\ndef sortStack(stack):\n    if len(stack) == 0:\n        return stack\n\n    top = stack.pop()\n\n    sortStack(stack)\n\n    insertInSortedOrder(stack, top)\n\n    return stack\n\n\ndef insertInSortedOrder(stack, value):\n    if len(stack) == 0 or stack[len(stack) - 1] <= value:\n        stack.append(value)\n        return\n\n    top = stack.pop()\n\n    insertInSortedOrder(stack, value)\n\n    stack.append(top)\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [-5, 2, -2, 4, 3, 1]\n        expected = [-5, -2, 1, 2, 3, 4]\n        actual = program.sortStack(input)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [-5, 2, -2, 4, 3, 1]\n        expected = [-5, -2, 1, 2, 3, 4]\n        actual = program.sortStack(input)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: false,
          startingCode:
            "class Program\n  def sortStack(stack)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def sortStack(stack)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.sortStack\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.sortStack\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func sortStack(_ stack: inout [Int]) -> [Int] {\n    // Write your code here.\n    return [Int]()\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the length of the stack\n  func sortStack(_ stack: inout [Int]) -> [Int] {\n    if stack.count == 0 {\n      return stack\n    }\n\n    let top = stack.removeLast()\n    sortStack(&stack)\n\n    insertInSortedOrder(&stack, top)\n    return stack\n  }\n\n  func insertInSortedOrder(_ stack: inout [Int], _ value: Int) {\n    if stack.count == 0 || stack[stack.count - 1] <= value {\n      stack.append(value)\n      return\n    }\n\n    let top = stack.removeLast()\n    insertInSortedOrder(&stack, value)\n    stack.append(top)\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [-5, 2, -2, 4, 3, 1]\n      var expected = [-5, -2, 1, 2, 3, 4]\n      var actual = Program().sortStack(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [-5, 2, -2, 4, 3, 1]\n      var expected = [-5, -2, 1, 2, 3, 4]\n      var actual = Program().sortStack(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function sortStack(stack: number[]) {\n  // Write your code here.\n  return [];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the stack\nexport function sortStack(stack: number[]) {\n  if (stack.length === 0) return stack;\n\n  const top = stack.pop()!;\n\n  sortStack(stack);\n\n  insertInSortedOrder(stack, top);\n\n  return stack;\n}\n\nfunction insertInSortedOrder(stack: number[], value: number) {\n  if (stack.length === 0 || stack[stack.length - 1] <= value) {\n    stack.push(value);\n    return;\n  }\n\n  const top = stack.pop()!;\n\n  insertInSortedOrder(stack, value);\n\n  stack.push(top);\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "stack",
          example: [-5, 2, -2, 4, 3, 1],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          stack: [-5, 2, -2, 4, 3, 1],
        },
        {
          stack: [3, 4, 5, 1, 2],
        },
        {
          stack: [0, -2, 3, 4, 1, -9, 8],
        },
        {
          stack: [2, 4, 22, 1, -9, 0, 6, 23, -2, 1],
        },
        {
          stack: [3, 4, 5, 1, 2],
        },
        {
          stack: [-1, 0, 2, 3, 4, 1, 1, 1],
        },
        {
          stack: [],
        },
        {
          stack: [1],
        },
        {
          stack: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
        },
        {
          stack: [9, 2, 8, 1],
        },
        {
          stack: [2, 33, 44, 2, -9, -7, -5, -2, -2, -2, 0],
        },
        {
          stack: [3, 3, 3, 3, 3, 3],
        },
        {
          stack: [0, 0],
        },
        {
          stack: [2, 22, 222, 3, 33, 33, 9, 2, 3, 312, -9, -2, 3],
        },
        {
          stack: [3, 4, 5, 1, 2, 2, 2, 1, 3, 4, 5, 3, 1, 3, -1, 2, 3],
        },
      ],
      jsonTests: [
        {
          stack: [-5, 2, -2, 4, 3, 1],
        },
        {
          stack: [3, 4, 5, 1, 2],
        },
        {
          stack: [0, -2, 3, 4, 1, -9, 8],
        },
        {
          stack: [2, 4, 22, 1, -9, 0, 6, 23, -2, 1],
        },
        {
          stack: [3, 4, 5, 1, 2],
        },
        {
          stack: [-1, 0, 2, 3, 4, 1, 1, 1],
        },
        {
          stack: [],
        },
        {
          stack: [1],
        },
        {
          stack: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
        },
        {
          stack: [9, 2, 8, 1],
        },
        {
          stack: [2, 33, 44, 2, -9, -7, -5, -2, -2, -2, 0],
        },
        {
          stack: [3, 3, 3, 3, 3, 3],
        },
        {
          stack: [0, 0],
        },
        {
          stack: [2, 22, 222, 3, 33, 33, 9, 2, 3, 312, -9, -2, 3],
        },
        {
          stack: [3, 4, 5, 1, 2, 2, 2, 1, 3, 4, 5, 3, 1, 3, -1, 2, 3],
        },
      ],
      changelog: [],
      id: 13,
    },
    {
      uid: "suffix-trie-construction",
      testStrategy: "JSON",
      name: "Suffix Trie Construction",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Tries",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 11074,
        failureCount: 3938,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "243526904",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1426,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a <span>SuffixTrie</span> class for a Suffix-Trie-like data structure.\n  The class should have a <span>root</span> property set to be the root node of\n  the trie and should support:\n</p>\n<ul>\n  <li>\n    Creating the trie from a string; this will be done by calling the\n    <span>populateSuffixTrieFrom</span> method upon class instantiation, which\n    should populate the <span>root</span> of the class.\n  </li>\n  <li>Searching for strings in the trie.</li>\n</ul>\n<p>\n  Note that every string added to the trie should end with the special\n  <span>endSymbol</span> character: <span>"*"</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Suffix Tries, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input (for creation)</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "babc"\n</pre>\n<h3>Sample Output (for creation)</h3>\n<pre>\n<span class="CodeEditor-promptComment">The structure below is the root of the trie.</span>\n{\n  "c": {"*": true},\n  "b": {\n    "c": {"*": true},\n    "a": {"b": {"c": {"*": true}}},\n  },\n  "a": {"b": {"c": {"*": true}}},\n}\n</pre>\n<h3>\n  Sample Input (for searching in the suffix trie above)\n</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abc"\n</pre>\n<h3>\n  Sample Output (for searching in the suffix trie above)\n</h3>\n<pre>\ntrue\n</pre>\n</div>',
      hints: [
        "<p>\nBuilding a suffix-trie-like data structure consists of essentially storing every suffix of a given string in a trie. To do so, iterate through the input string one character at a time and insert every substring starting at each character and ending at the end of the string into the trie.\n</p>\n",
        "\n<p>\nTo insert a string into the trie, start by adding the first character of the string into the root node of the trie and mapping it to an empty hash table if it isn't already there. Then, iterate through the rest of the string inserting each of the remaining characters into the previous character's corresponding node (or hash table) in the trie, making sure to add an endSymbol \"*\" at the end.\n</p>\n",
        "\n<p>\nSearching the trie for a specific string should follow a nearly identical logic to the one used to add a string in the trie.\n</p>",
      ],
      spaceTime:
        "Creation: O(n^2) time | O(n^2) space - where n is the length of the input string\nSearching: O(m) time | O(1) space - where m is the length of the input string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <unordered_map>\nusing namespace std;\n\n// Do not edit the class below except for the\n// populateSuffixTrieFrom and contains methods.\n// Feel free to add new properties and methods\n// to the class.\nclass TrieNode {\npublic:\n  unordered_map<char, TrieNode *> children;\n};\n\nclass SuffixTrie {\npublic:\n  TrieNode *root;\n  char endSymbol;\n\n  SuffixTrie(string str) {\n    this->root = new TrieNode();\n    this->endSymbol = '*';\n    this->populateSuffixTrieFrom(str);\n  }\n\n  void populateSuffixTrieFrom(string str) {\n    // Write your code here.\n  }\n\n  bool contains(string str) {\n    // Write your code here.\n    return false;\n  }\n};\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\nusing namespace std;\n\nclass TrieNode {\npublic:\n  unordered_map<char, TrieNode *> children;\n};\n\nclass SuffixTrie {\npublic:\n  TrieNode *root;\n  char endSymbol;\n\n  SuffixTrie(string str) {\n    this->root = new TrieNode();\n    this->endSymbol = '*';\n    this->populateSuffixTrieFrom(str);\n  }\n\n  // O(n^2) time | O(n^2) space\n  void populateSuffixTrieFrom(string str) {\n    for (int i = 0; i < str.length(); i++) {\n      this->insertSubstringStartingAt(i, str);\n    }\n  }\n\n  void insertSubstringStartingAt(int i, string str) {\n    TrieNode *node = this->root;\n    for (int j = i; j < str.length(); j++) {\n      char letter = str[j];\n      if (node->children.find(letter) == node->children.end()) {\n        TrieNode *newNode = new TrieNode();\n        node->children.insert({letter, newNode});\n      }\n      node = node->children[letter];\n    }\n    node->children.insert({this->endSymbol, nullptr});\n  }\n\n  // O(m) time | O(1) space\n  bool contains(string str) {\n    TrieNode *node = this->root;\n    for (char letter : str) {\n      if (node->children.find(letter) == node->children.end()) {\n        return false;\n      }\n      node = node->children[letter];\n    }\n    return node->children.find(this->endSymbol) != node->children.end();\n  }\n};\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string word1 = "babc";\n      SuffixTrie actual(word1);\n      assert(actual.contains("abc") == true);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string word1 = "babc";\n      SuffixTrie actual(word1);\n      assert(actual.contains("abc") == true);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// Do not edit the class below except for the\n\t// PopulateSuffixTrieFrom and Contains methods.\n\t// Feel free to add new properties and methods\n\t// to the class.\n\tpublic class TrieNode {\n\t\tpublic Dictionary<char, TrieNode> Children = new Dictionary<char, TrieNode>();\n\t}\n\n\tpublic class SuffixTrie {\n\t\tpublic TrieNode root = new TrieNode();\n\t\tpublic char endSymbol = '*';\n\n\t\tpublic SuffixTrie(string str) {\n\t\t\tPopulateSuffixTrieFrom(str);\n\t\t}\n\n\t\tpublic void PopulateSuffixTrieFrom(string str) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic bool Contains(string str) {\n\t\t\t// Write your code here.\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic class TrieNode {\n\t\tpublic Dictionary<char, TrieNode> Children = new Dictionary<char, TrieNode>();\n\t}\n\n\tpublic class SuffixTrie {\n\t\tpublic TrieNode root = new TrieNode();\n\t\tpublic char endSymbol = '*';\n\n\t\tpublic SuffixTrie(string str) {\n\t\t\tPopulateSuffixTrieFrom(str);\n\t\t}\n\n\t\t// O(n^2) time | O(n^2) space\n\t\tpublic void PopulateSuffixTrieFrom(string str) {\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tinsertSubstringStartingAt(i, str);\n\t\t\t}\n\t\t}\n\n\t\tpublic void insertSubstringStartingAt(int i, string str) {\n\t\t\tTrieNode node = root;\n\t\t\tfor (int j = i; j < str.Length; j++) {\n\t\t\t\tchar letter = str[j];\n\t\t\t\tif (!node.Children.ContainsKey(letter)) {\n\t\t\t\t\tTrieNode newNode = new TrieNode();\n\t\t\t\t\tnode.Children.Add(letter, newNode);\n\t\t\t\t}\n\t\t\t\tnode = node.Children[letter];\n\t\t\t}\n\t\t\tnode.Children[endSymbol] = null;\n\t\t}\n\n\t\t// O(m) time | O(1) space\n\t\tpublic bool Contains(string str) {\n\t\t\tTrieNode node  = root;\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tchar letter = str[i];\n\t\t\t\tif (!node.Children.ContainsKey(letter)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tnode = node.Children[letter];\n\t\t\t}\n\t\t\treturn node.Children.ContainsKey(endSymbol);\n\t\t}\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.SuffixTrie trie = new Program.SuffixTrie("babc");\n\t\tUtils.AssertTrue(trie.Contains("abc"));\n\t}\n}\n',
          unitTests:
            'using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.SuffixTrie trie = new Program.SuffixTrie("babc");\n\t\tUtils.AssertTrue(trie.Contains("abc"));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\n// Do not edit the class below except for the\n// PopulateSuffixTrieFrom and Contains methods.\n// Feel free to add new properties and methods\n// to the class.\ntype SuffixTrie map[byte]SuffixTrie\n\n// Feel free to add to this function.\nfunc NewSuffixTrie() SuffixTrie {\n\ttrie := SuffixTrie{}\n\treturn trie\n}\n\nfunc (trie SuffixTrie) PopulateSuffixTrieFrom(str string) {\n\t// Write your code here.\n}\n\nfunc (trie SuffixTrie) Contains(str string) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype SuffixTrie map[byte]SuffixTrie\n\nfunc NewSuffixTrie() SuffixTrie {\n\ttrie := SuffixTrie{}\n\treturn trie\n}\n\n// O(n^2) time | O(n^2) space\nfunc (trie SuffixTrie) PopulateSuffixTrieFrom(str string) {\n\tfor i := range str {\n\t\tnode := trie\n\t\tfor j := i; j < len(str); j++ {\n\t\t\tletter := str[j]\n\t\t\tif _, found := node[letter]; !found {\n\t\t\t\tnode[letter] = NewSuffixTrie()\n\t\t\t}\n\t\t\tnode = node[letter]\n\t\t}\n\t\tnode['*'] = nil\n\t}\n}\n\n// O(m) time | O(1) space\nfunc (trie SuffixTrie) Contains(str string) bool {\n\tnode := trie\n\tfor i := 0; i < len(str); i++ {\n\t\tletter := str[i]\n\t\tif _, found := node[letter]; !found {\n\t\t\treturn false\n\t\t}\n\t\tnode = node[letter]\n\t}\n\t_, found := node['*']\n\treturn found\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport \"github.com/stretchr/testify/require\"\n\nfunc (trie SuffixTrie) Equals(other SuffixTrie) bool {\n\tif len(trie) != len(other) {\n\t\treturn false\n\t}\n\tfor key, child := range trie {\n\t\totherchild, found := other[key]\n\t\tif !found {\n\t\t\treturn false\n\t\t} else if child != nil && !child.Equals(otherchild) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TrieFromString(str string) SuffixTrie {\n\ttrie := SuffixTrie{}\n\ttrie.PopulateSuffixTrieFrom(str)\n\treturn trie\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttrie := TrieFromString(\"babc\")\n\texpected := SuffixTrie{\n\t\t'c': {'*': nil},\n\t\t'b': {\n\t\t\t'c': {'*': nil},\n\t\t\t'a': {'b': {'c': {'*': nil}}},\n\t\t},\n\t\t'a': {'b': {'c': {'*': nil}}},\n\t}\n\trequire.True(t, trie.Equals(expected))\n\trequire.True(t, trie.Contains(\"abc\"))\n}\n",
          unitTests:
            "package main\n\nimport \"github.com/stretchr/testify/require\"\n\nfunc (trie SuffixTrie) Equals(other SuffixTrie) bool {\n\tif len(trie) != len(other) {\n\t\treturn false\n\t}\n\tfor key, child := range trie {\n\t\totherchild, found := other[key]\n\t\tif !found {\n\t\t\treturn false\n\t\t} else if child != nil && !child.Equals(otherchild) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TrieFromString(str string) SuffixTrie {\n\ttrie := SuffixTrie{}\n\ttrie.PopulateSuffixTrieFrom(str)\n\treturn trie\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\ttrie := TrieFromString(\"babc\")\n\texpected := SuffixTrie{\n\t\t'c': {'*': nil},\n\t\t'b': {\n\t\t\t'c': {'*': nil},\n\t\t\t'a': {'b': {'c': {'*': nil}}},\n\t\t},\n\t\t'a': {'b': {'c': {'*': nil}}},\n\t}\n\trequire.True(t, trie.Equals(expected))\n\trequire.True(t, trie.Contains(\"abc\"))\n}\n",
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  // Do not edit the class below except for the\n  // populateSuffixTrieFrom and contains methods.\n  // Feel free to add new properties and methods\n  // to the class.\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  }\n\n  static class SuffixTrie {\n    TrieNode root = new TrieNode();\n    char endSymbol = '*';\n\n    public SuffixTrie(String str) {\n      populateSuffixTrieFrom(str);\n    }\n\n    public void populateSuffixTrieFrom(String str) {\n      // Write your code here.\n    }\n\n    public boolean contains(String str) {\n      // Write your code here.\n      return false;\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  }\n\n  static class SuffixTrie {\n    TrieNode root = new TrieNode();\n    char endSymbol = '*';\n\n    public SuffixTrie(String str) {\n      populateSuffixTrieFrom(str);\n    }\n\n    // O(n^2) time | O(n^2) space\n    public void populateSuffixTrieFrom(String str) {\n      for (int i = 0; i < str.length(); i++) {\n        insertSubstringStartingAt(i, str);\n      }\n    }\n\n    public void insertSubstringStartingAt(int i, String str) {\n      TrieNode node = root;\n      for (int j = i; j < str.length(); j++) {\n        char letter = str.charAt(j);\n        if (!node.children.containsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n        }\n        node = node.children.get(letter);\n      }\n      node.children.put(endSymbol, null);\n    }\n\n    // O(m) time | O(1) space\n    public boolean contains(String str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.length(); i++) {\n        char letter = str.charAt(i);\n        if (!node.children.containsKey(letter)) {\n          return false;\n        }\n        node = node.children.get(letter);\n      }\n      return node.children.containsKey(endSymbol);\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n\n  @Test\n  public void TestCase1() {\n    var trie = new Program.SuffixTrie("babc");\n    Utils.assertTrue(trie.contains("abc"));\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n\n  @Test\n  public void TestCase1() {\n    var trie = new Program.SuffixTrie("babc");\n    Utils.assertTrue(trie.contains("abc"));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// Do not edit the class below except for the\n// populateSuffixTrieFrom and contains methods.\n// Feel free to add new properties and methods\n// to the class.\nclass SuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  populateSuffixTrieFrom(string) {\n    // Write your code here.\n  }\n\n  contains(string) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.SuffixTrie = SuffixTrie;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass SuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  // O(n^2) time | O(n^2) space\n  populateSuffixTrieFrom(string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i, string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n    node[this.endSymbol] = true;\n  }\n\n  // O(m) time | O(1) space\n  contains(string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return this.endSymbol in node;\n  }\n}\n\nexports.SuffixTrie = SuffixTrie;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\ndata class TrieNode(\n    val children: MutableMap<Char, TrieNode> = mutableMapOf<Char, TrieNode>()\n)\n\nclass SuffixTrie(str: String) {\n    val endSymbol = '*'\n    var root = TrieNode()\n\n    init { populate(str) }\n\n    fun populate(str: String) {\n        // Write your code here.\n    }\n\n    fun contains(str: String): Boolean {\n        // Write your code here.\n        return false\n    }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\ndata class TrieNode(\n    val children: MutableMap<Char, TrieNode> = mutableMapOf<Char, TrieNode>()\n)\n\nclass SuffixTrie(str: String) {\n    val endSymbol = '*'\n    var root = TrieNode()\n\n    init { populate(str) }\n\n    // O(n^2) time | O(n^2) space\n    fun populate(str: String) {\n        for (i in 0 until str.length) {\n            insertSubstringStartingAt(i, str)\n        }\n    }\n\n    // O(m) time | O(1) space\n    fun contains(str: String): Boolean {\n        var node = this.root\n        for (letter in str) {\n            val child = node.children[letter]\n            if (child == null) return false\n            node = child\n        }\n        return node.children.containsKey(endSymbol)\n    }\n\n    fun insertSubstringStartingAt(i: Int, str: String) {\n        var node = root\n        for (j in i until str.length) {\n            val letter = str[j]\n            val child = node.children[letter]\n            if (child == null) {\n                val newNode = TrieNode()\n                node.children[letter] = newNode\n            }\n            node = node.children[letter]!!\n        }\n        node.children[endSymbol] = TrieNode()\n    }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.SuffixTrie\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val trie = SuffixTrie("babc")\n        assert(trie.contains("abc"))\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.SuffixTrie\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val trie = SuffixTrie("babc")\n        assert(trie.contains("abc"))\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            '# Do not edit the class below except for the\n# populateSuffixTrieFrom and contains methods.\n# Feel free to add new properties and methods\n# to the class.\nclass SuffixTrie:\n    def __init__(self, string):\n        self.root = {}\n        self.endSymbol = "*"\n        self.populateSuffixTrieFrom(string)\n\n    def populateSuffixTrieFrom(self, string):\n        # Write your code here.\n        pass\n\n    def contains(self, string):\n        # Write your code here.\n        pass\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass SuffixTrie:\n    def __init__(self, string):\n        self.root = {}\n        self.endSymbol = "*"\n        self.populateSuffixTrieFrom(string)\n\n    # O(n^2) time | O(n^2) space\n    def populateSuffixTrieFrom(self, string):\n        for i in range(len(string)):\n            self.insertSubstringStartingAt(i, string)\n\n    def insertSubstringStartingAt(self, i, string):\n        node = self.root\n        for j in range(i, len(string)):\n            letter = string[j]\n            if letter not in node:\n                node[letter] = {}\n            node = node[letter]\n        node[self.endSymbol] = True\n\n    # O(m) time | O(1) space\n    def contains(self, string):\n        node = self.root\n        for letter in string:\n            if letter not in node:\n                return False\n            node = node[letter]\n        return self.endSymbol in node\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        trie = program.SuffixTrie("babc")\n        expected = {\n            "c": {"*": True},\n            "b": {"c": {"*": True}, "a": {"b": {"c": {"*": True}}}},\n            "a": {"b": {"c": {"*": True}}},\n        }\n        self.assertEqual(trie.root, expected)\n        self.assertTrue(trie.contains("abc"))\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        trie = program.SuffixTrie("babc")\n        expected = {\n            "c": {"*": True},\n            "b": {"c": {"*": True}, "a": {"b": {"c": {"*": True}}}},\n            "a": {"b": {"c": {"*": True}}},\n        }\n        self.assertEqual(trie.root, expected)\n        self.assertTrue(trie.contains("abc"))\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def suffixTrie(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def suffixTrie(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.suffixTrie\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.suffixTrie\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            'class Program {\n  // Do not edit the class below except for the\n  // populateSuffixTrieFrom and contains methods.\n  // Feel free to add new properties and methods\n  // to the class.\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class SuffixTrie {\n    var root = TrieNode()\n    let endSymbol = "*"\n\n    init(string: String) {\n      populateSuffixTrieFrom(string: string)\n    }\n\n    func populateSuffixTrieFrom(string: String) {\n      // Write your code here.\n    }\n\n    func contains(string: String) -> Bool {\n      // Write your code here.\n      return false\n    }\n  }\n}\n',
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class SuffixTrie {\n    var root = TrieNode()\n    let endSymbol = "*"\n\n    init(string: String) {\n      populateSuffixTrieFrom(string: string)\n    }\n\n    // O(n^2) time | O(n^2) space\n    func populateSuffixTrieFrom(string: String) {\n      for i in 0 ..< string.count {\n        insertSubstringStartingAt(index: i, string: string, root: root)\n      }\n    }\n\n    func insertSubstringStartingAt(index: Int, string: String, root: TrieNode) {\n      var node = root\n\n      for j in index ..< string.count {\n        let jStringIndex = string.index(string.startIndex, offsetBy: j)\n        let jthCharacter = String(string[jStringIndex])\n\n        if !node.children.keys.contains(jthCharacter) {\n          node.children[jthCharacter] = TrieNode()\n        }\n\n        let nextNode = node.children[jthCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      node.children[endSymbol] = true\n    }\n\n    // O(m) time | O(1) space\n    func contains(string: String) -> Bool {\n      var node = root\n\n      for character in string {\n        let stringifiedCharacter = String(character)\n\n        if !node.children.keys.contains(stringifiedCharacter) {\n          return false\n        }\n\n        let nextNode = node.children[stringifiedCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      let reachedTheEnd = node.children[endSymbol] != nil\n      return reachedTheEnd\n    }\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let trie = Program.SuffixTrie(string: "babc")\n      try assert(trie.contains(string: "abc"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let trie = Program.SuffixTrie(string: "babc")\n      try assert(trie.contains(string: "abc"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "interface TrieNode {\n  [key: string]: TrieNode | boolean;\n}\n\n// Do not edit the class below except for the\n// populateSuffixTrieFrom and contains methods.\n// Feel free to add new properties and methods\n// to the class.\nexport class SuffixTrie {\n  root: TrieNode;\n  endSymbol: string;\n\n  constructor(string: string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  populateSuffixTrieFrom(string: string) {\n    // Write your code here.\n  }\n\n  contains(string: string) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface TrieNode {\n  [key: string]: TrieNode | boolean;\n}\n\nexport class SuffixTrie {\n  root: TrieNode;\n  endSymbol: string;\n\n  constructor(string: string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  // O(n^2) time | O(n^2) space\n  populateSuffixTrieFrom(string: string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i: number, string: string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter] as TrieNode;\n    }\n    node[this.endSymbol] = true;\n  }\n\n  // O(m) time | O(1) space\n  contains(string: string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter] as TrieNode;\n    }\n    return this.endSymbol in node;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "babc",
          schema: {
            type: "string",
          },
        },
        {
          name: "classMethodsToCall",
          example: [
            {
              arguments: ["abc"],
              method: "contains",
            },
          ],
          schema: {
            description:
              "These methods will be called in the order that they appear in below\non a <span>SuffixTrie</span> built from the <span>string</span> and with their respective arguments.\n",
            items: {
              properties: {
                arguments: {
                  items: {
                    type: "string",
                  },
                  maxItems: 1,
                  minItems: 1,
                  type: "array",
                },
                method: {
                  enum: ["contains"],
                  type: "string",
                },
              },
              required: ["method", "arguments"],
              type: "object",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          classMethodsToCall: [
            {
              arguments: ["abc"],
              method: "contains",
            },
          ],
          string: "babc",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["st"],
              method: "contains",
            },
            {
              arguments: ["est"],
              method: "contains",
            },
            {
              arguments: ["test"],
              method: "contains",
            },
            {
              arguments: ["tes"],
              method: "contains",
            },
          ],
          string: "test",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["e"],
              method: "contains",
            },
            {
              arguments: ["le"],
              method: "contains",
            },
            {
              arguments: ["ble"],
              method: "contains",
            },
            {
              arguments: ["ible"],
              method: "contains",
            },
            {
              arguments: ["sible"],
              method: "contains",
            },
            {
              arguments: ["isible"],
              method: "contains",
            },
            {
              arguments: ["visible"],
              method: "contains",
            },
            {
              arguments: ["nvisible"],
              method: "contains",
            },
            {
              arguments: ["invisible"],
              method: "contains",
            },
            {
              arguments: ["nvisibl"],
              method: "contains",
            },
          ],
          string: "invisible",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["9"],
              method: "contains",
            },
            {
              arguments: ["89"],
              method: "contains",
            },
            {
              arguments: ["789"],
              method: "contains",
            },
            {
              arguments: ["6789"],
              method: "contains",
            },
            {
              arguments: ["56789"],
              method: "contains",
            },
            {
              arguments: ["456789"],
              method: "contains",
            },
            {
              arguments: ["3456789"],
              method: "contains",
            },
            {
              arguments: ["23456789"],
              method: "contains",
            },
            {
              arguments: ["123456789"],
              method: "contains",
            },
            {
              arguments: ["45567"],
              method: "contains",
            },
          ],
          string: "1234556789",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["st"],
              method: "contains",
            },
            {
              arguments: ["est"],
              method: "contains",
            },
            {
              arguments: ["test"],
              method: "contains",
            },
            {
              arguments: ["ttest"],
              method: "contains",
            },
            {
              arguments: ["sttest"],
              method: "contains",
            },
            {
              arguments: ["esttest"],
              method: "contains",
            },
            {
              arguments: ["testtest"],
              method: "contains",
            },
            {
              arguments: ["tt"],
              method: "contains",
            },
          ],
          string: "testtest",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["tt"],
              method: "contains",
            },
            {
              arguments: ["ttt"],
              method: "contains",
            },
            {
              arguments: ["tttt"],
              method: "contains",
            },
            {
              arguments: ["ttttt"],
              method: "contains",
            },
            {
              arguments: ["tttttt"],
              method: "contains",
            },
            {
              arguments: ["ttttttt"],
              method: "contains",
            },
            {
              arguments: ["tttttttt"],
              method: "contains",
            },
            {
              arguments: ["ttttttttt"],
              method: "contains",
            },
            {
              arguments: ["vvv"],
              method: "contains",
            },
          ],
          string: "ttttttttt",
        },
      ],
      jsonTests: [
        {
          classMethodsToCall: [
            {
              arguments: ["abc"],
              method: "contains",
            },
          ],
          string: "babc",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["st"],
              method: "contains",
            },
            {
              arguments: ["est"],
              method: "contains",
            },
            {
              arguments: ["test"],
              method: "contains",
            },
            {
              arguments: ["tes"],
              method: "contains",
            },
          ],
          string: "test",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["e"],
              method: "contains",
            },
            {
              arguments: ["le"],
              method: "contains",
            },
            {
              arguments: ["ble"],
              method: "contains",
            },
            {
              arguments: ["ible"],
              method: "contains",
            },
            {
              arguments: ["sible"],
              method: "contains",
            },
            {
              arguments: ["isible"],
              method: "contains",
            },
            {
              arguments: ["visible"],
              method: "contains",
            },
            {
              arguments: ["nvisible"],
              method: "contains",
            },
            {
              arguments: ["invisible"],
              method: "contains",
            },
            {
              arguments: ["nvisibl"],
              method: "contains",
            },
          ],
          string: "invisible",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["9"],
              method: "contains",
            },
            {
              arguments: ["89"],
              method: "contains",
            },
            {
              arguments: ["789"],
              method: "contains",
            },
            {
              arguments: ["6789"],
              method: "contains",
            },
            {
              arguments: ["56789"],
              method: "contains",
            },
            {
              arguments: ["456789"],
              method: "contains",
            },
            {
              arguments: ["3456789"],
              method: "contains",
            },
            {
              arguments: ["23456789"],
              method: "contains",
            },
            {
              arguments: ["123456789"],
              method: "contains",
            },
            {
              arguments: ["45567"],
              method: "contains",
            },
          ],
          string: "1234556789",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["st"],
              method: "contains",
            },
            {
              arguments: ["est"],
              method: "contains",
            },
            {
              arguments: ["test"],
              method: "contains",
            },
            {
              arguments: ["ttest"],
              method: "contains",
            },
            {
              arguments: ["sttest"],
              method: "contains",
            },
            {
              arguments: ["esttest"],
              method: "contains",
            },
            {
              arguments: ["testtest"],
              method: "contains",
            },
            {
              arguments: ["tt"],
              method: "contains",
            },
          ],
          string: "testtest",
        },
        {
          classMethodsToCall: [
            {
              arguments: ["t"],
              method: "contains",
            },
            {
              arguments: ["tt"],
              method: "contains",
            },
            {
              arguments: ["ttt"],
              method: "contains",
            },
            {
              arguments: ["tttt"],
              method: "contains",
            },
            {
              arguments: ["ttttt"],
              method: "contains",
            },
            {
              arguments: ["tttttt"],
              method: "contains",
            },
            {
              arguments: ["ttttttt"],
              method: "contains",
            },
            {
              arguments: ["tttttttt"],
              method: "contains",
            },
            {
              arguments: ["ttttttttt"],
              method: "contains",
            },
            {
              arguments: ["vvv"],
              method: "contains",
            },
          ],
          string: "ttttttttt",
        },
      ],
      changelog: [],
      id: 14,
    },
    {
      uid: "two-edge-connected-graph",
      testStrategy: "JSON",
      name: "Two-Edge-Connected Graph",
      version: 0,
      releaseDate: "2021-05-17T00:00:00Z",
      category: "Graphs",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 893,
        failureCount: 273,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "540930009",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 2133,
      },
      prompt:
        "<div class=\"html\">\n<p>\n  You're given a list of <span>edges</span> representing an unweighted and\n  undirected graph. Write a function that returns a boolean representing whether\n  the given graph is two-edge-connected.\n</p>\n<p>\n  A graph is connected if, for every pair of vertices in the graph, there's a\n  path of one or more edges connecting the given vertices. A graph that isn't\n  connected is said to be disconnected.\n</p>\n<p>\n  A graph is two-edge-connected if, for every one of its edges, the edge's\n  removal from the graph doesn't cause the graph to become disconnected. If the\n  removal of any single edge disconnects the graph, then it isn't\n  two-edge-connected. If the given graph is already disconnected, then it also\n  isn't two-edge-connected. An empty graph is considered two-edge-connected.\n</p>\n<p>\n  The input list is what's called an adjacency list, and it represents a graph.\n  The number of vertices in the graph is equal to the length of\n  <span>edges</span>, where each index <span>i</span> in\n  <span>edges</span> contains vertex <span>i</span>'s outbound edges, in no\n  particular order. Each outbound edge is represented by a positive integer that\n  denotes an index (a destination vertex) in the list that this vertex is\n  connected to. Note that these edges are undirected, meaning that you can\n  travel from a particular vertex to its destination and from the destination\n  back to that vertex. Since these edges are undirected, if vertex\n  <span>i</span> has an outbound edge to vertex <span>j</span>, then vertex\n  <span>j</span> is guaranteed to have an outbound edge to vertex\n  <span>i</span>. For example, an undirected graph with two vertices and one\n  edge would be represented by the following adjacency list\n  <span>edges = [[1], [0]]</span>.\n</p>\n<p>\n  Note that the input graph will never contain parallel edges (edges that share\n  the same source and destination vertices). In other words, there will never be\n  more than one edge that connects the same two vertices to each other.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [1, 2, 5],\n  [0, 2],\n  [0, 1, 3],\n  [2, 4, 5],\n  [3, 5],\n  [0, 3, 4],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue \n</pre>\n</div>",
      hints: [
        "<p>\n  The brute-force approach to solving this problem is to simply remove one edge\n  from the graph at a time and to then check if the resulting graph is\n  disconnected. This approach works, but is isn't optimal. Can you think of a\n  better approach?\n</p>\n",
        "\n<p>\n  It's easy to see that, if there's only one edge that connects a vertex or a\n  group of vertices to the rest of the graph, then this graph isn't\n  two-edge-connected. This is because, after the removal of that particular\n  edge, the graph would become disconnected. This type of edge is what's known\n  as a bridge; if you discover a bridge in the graph, the graph isn't\n  two-edge-connected.\n</p>\n",
        "\n<p>\n  In order for a graph to be two-edge-connected, it must be connected before the\n  removal of any edges, and it must not contain any bridges. To determine if a\n  graph is connected, you can simply run a depth-first search from any vertex\n  and see if you're able to visit every other vertex. To determine if a graph\n  contains any bridges is a little bit more difficult, but it can be done with a\n  modified depth-first search that considers the different types of edges in the\n  graph.\n</p>\n",
        "\n<p>\n  To confirm that no bridges exist in the graph, you need to see if there's an\n  edge from every vertex in the graph to a vertex that is visited before it in a\n  depth-first search (this is known as a back edge). A back edge indicates that\n  there's a way to reach a vertex other than from the original edge that reached\n  it. This means that if you remove the original edge that reached a vertex, it\n  can still be visited, and the original edge you've just removed isn't a\n  bridge. If every vertex in the graph (with the exception of the starting\n  vertex in a given depth-first search) has a back edge, then the graph is\n  two-edge-connected. See the Conceptual Overview section of this question's\n  video explanation for a more in-depth explanation.\n</p>",
      ],
      spaceTime:
        "O(v + e) time | O(v) space - where v is the number of vertices and e is the number of edges in the graph",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nbool twoEdgeConnectedGraph(vector<vector<int>> edges) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool areAllVerticesVisited(const vector<int> &arrivalTimes);\nint getMinimumArrivalTimeOfAncestors(int currentVertex, int parent,\n                                     int currentTime, vector<int> &arrivalTimes,\n                                     const vector<vector<int>> &edges);\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nbool twoEdgeConnectedGraph(vector<vector<int>> edges) {\n  if (edges.size() == 0)\n    return true;\n\n  vector<int> arrivalTimes(edges.size(), -1);\n  int startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes,\n                                       edges) == -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nbool areAllVerticesVisited(const vector<int> &arrivalTimes) {\n  for (const auto &time : arrivalTimes) {\n    if (time == -1)\n      return false;\n  }\n\n  return true;\n}\n\nint getMinimumArrivalTimeOfAncestors(int currentVertex, int parent,\n                                     int currentTime, vector<int> &arrivalTimes,\n                                     const vector<vector<int>> &edges) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  int minimumArrivalTime = currentTime;\n\n  for (const auto &destination : edges[currentVertex]) {\n    if (arrivalTimes[destination] == -1) {\n      minimumArrivalTime =\n          min(minimumArrivalTime, getMinimumArrivalTimeOfAncestors(\n                                      destination, currentVertex,\n                                      currentTime + 1, arrivalTimes, edges));\n    } else if (destination != parent) {\n      minimumArrivalTime = min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime == currentTime && parent != -1)\n    return -1;\n\n  return minimumArrivalTime;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> input = {{1, 2, 5}, {0, 2}, {0, 1, 3},\n                                   {2, 4, 5}, {3, 5}, {0, 3, 5}};\n      auto expected = true;\n      auto actual = twoEdgeConnectedGraph(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> input = {{1, 2, 5}, {0, 2}, {0, 1, 3},\n                                   {2, 4, 5}, {3, 5}, {0, 3, 5}};\n      auto expected = true;\n      auto actual = twoEdgeConnectedGraph(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic bool TwoEdgeConnectedGraph(int[][] edges) {\n\t\t// Write your code here.\n\t\treturn false;\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(v + e) time | O(v) space - where v is the number of\n\t// vertices and e is the number of edges in the graph\n\tpublic bool TwoEdgeConnectedGraph(int[][] edges) {\n\t\tif (edges.Length == 0) return true;\n\n\t\tint[] arrivalTimes = new int[edges.Length];\n\t\tArray.Fill(arrivalTimes, -1);\n\t\tint startVertex = 0;\n\n\t\tif (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes,\n\t\t  edges) == -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn areAllVerticesVisited(arrivalTimes);\n\t}\n\n\tpublic bool areAllVerticesVisited(int[] arrivalTimes) {\n\t\tforeach (var time in arrivalTimes) {\n\t\t\tif (time == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int getMinimumArrivalTimeOfAncestors(int currentVertex, int parent, int currentTime,\n\t  int[] arrivalTimes, int[][] edges) {\n\t\tarrivalTimes[currentVertex] = currentTime;\n\n\t\tint minimumArrivalTime = currentTime;\n\n\t\tforeach (var destination in edges[currentVertex]) {\n\t\t\tif (arrivalTimes[destination] == -1) {\n\t\t\t\tminimumArrivalTime = Math.Min(minimumArrivalTime, getMinimumArrivalTimeOfAncestors(\n\t\t\t\t\t    destination, currentVertex, currentTime + 1,\n\t\t\t\t\t    arrivalTimes,\n\t\t\t\t\t    edges));\n\t\t\t} else if (destination != parent) {\n\t\t\t\tminimumArrivalTime =\n\t\t\t\t  Math.Min(minimumArrivalTime, arrivalTimes[destination]);\n\t\t\t}\n\t\t}\n\n\t\t// A bridge was detected, which means the graph isn't two-edge-connected.\n\t\tif (minimumArrivalTime == currentTime && parent != -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn minimumArrivalTime;\n\t}\n\n}",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] input = new int[][] {\n\t\t\tnew int[] { 1, 2, 5 },\n\t\t\tnew int[] { 0, 2 },\n\t\t\tnew int[] { 0, 1, 3 },\n\t\t\tnew int[] { 2, 4, 5 },\n\t\t\tnew int[] { 3, 5 },\n\t\t\tnew int[] { 0, 3, 4 },\n\t\t};\n\t\tbool expected = true;\n\t\tvar actual = new Program().TwoEdgeConnectedGraph(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] input = new int[][] {\n\t\t\tnew int[] { 1, 2, 5 },\n\t\t\tnew int[] { 0, 2 },\n\t\t\tnew int[] { 0, 1, 3 },\n\t\t\tnew int[] { 2, 4, 5 },\n\t\t\tnew int[] { 3, 5 },\n\t\t\tnew int[] { 0, 3, 4 },\n\t\t};\n\t\tbool expected = true;\n\t\tvar actual = new Program().TwoEdgeConnectedGraph(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc TwoEdgeConnectedGraph(edges [][]int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunc TwoEdgeConnectedGraph(edges [][]int) bool {\n\tif len(edges) == 0 {\n\t\treturn true\n\t}\n\n\tarrivalTimes := make([]int, len(edges))\n\tfor i := range edges {\n\t\tarrivalTimes[i] = -1\n\t}\n\tstartVertex := 0\n\n\tif getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, &arrivalTimes, edges) == -1 {\n\t\treturn false\n\t}\n\n\treturn areAllVerticesVisited(arrivalTimes)\n}\n\nfunc areAllVerticesVisited(arrivalTimes []int) bool {\n\tfor _, time := range arrivalTimes {\n\t\tif time == -1 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime int, arrivalTimes *[]int, edges [][]int) int {\n\t(*arrivalTimes)[currentVertex] = currentTime\n\n\tvar minimumArrivalTime = currentTime\n\n\tfor _, destination := range edges[currentVertex] {\n\t\tif (*arrivalTimes)[destination] == -1 {\n\t\t\tminimumArrivalTime = min(\n\t\t\t\tminimumArrivalTime,\n\t\t\t\tgetMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime+1, arrivalTimes, edges),\n\t\t\t)\n\t\t} else if destination != parent {\n\t\t\tminimumArrivalTime = min(\n\t\t\t\tminimumArrivalTime,\n\t\t\t\t(*arrivalTimes)[destination],\n\t\t\t)\n\t\t}\n\t}\n\n\t// A bridge was detected, which means the graph isn't two-edge-connected.\n\tif minimumArrivalTime == currentTime && parent != -1 {\n\t\treturn -1\n\t}\n\n\treturn minimumArrivalTime\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2, 5},\n\t\t{0, 2},\n\t\t{0, 1, 3},\n\t\t{2, 4, 5},\n\t\t{3, 5},\n\t\t{0, 3, 4},\n\t}\n\texpected := true\n\tactual := TwoEdgeConnectedGraph(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2, 5},\n\t\t{0, 2},\n\t\t{0, 1, 3},\n\t\t{2, 4, 5},\n\t\t{3, 5},\n\t\t{0, 3, 4},\n\t}\n\texpected := true\n\tactual := TwoEdgeConnectedGraph(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public boolean twoEdgeConnectedGraph(int[][] edges) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(v + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the graph\n  public boolean twoEdgeConnectedGraph(int[][] edges) {\n    if (edges.length == 0) return true;\n\n    int[] arrivalTimes = new int[edges.length];\n    Arrays.fill(arrivalTimes, -1);\n    int startVertex = 0;\n\n    if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1) {\n      return false;\n    }\n\n    return areAllVerticesVisited(arrivalTimes);\n  }\n\n  public boolean areAllVerticesVisited(int[] arrivalTimes) {\n    for (int time : arrivalTimes) {\n      if (time == -1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public int getMinimumArrivalTimeOfAncestors(\n      int currentVertex, int parent, int currentTime, int[] arrivalTimes, int[][] edges) {\n    arrivalTimes[currentVertex] = currentTime;\n\n    int minimumArrivalTime = currentTime;\n\n    for (int destination : edges[currentVertex]) {\n      if (arrivalTimes[destination] == -1) {\n        minimumArrivalTime =\n            Math.min(\n                minimumArrivalTime,\n                getMinimumArrivalTimeOfAncestors(\n                    destination, currentVertex, currentTime + 1, arrivalTimes, edges));\n      } else if (destination != parent) {\n        minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n      }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if (minimumArrivalTime == currentTime && parent != -1) {\n      return -1;\n    }\n\n    return minimumArrivalTime;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = new int[][] {{1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 4}};\n    boolean expected = true;\n    var actual = new Program().twoEdgeConnectedGraph(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] input = new int[][] {{1, 2, 5}, {0, 2}, {0, 1, 3}, {2, 4, 5}, {3, 5}, {0, 3, 4}};\n    boolean expected = true;\n    var actual = new Program().twoEdgeConnectedGraph(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function twoEdgeConnectedGraph(edges) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction twoEdgeConnectedGraph(edges) {\n  if (edges.length === 0) return true;\n\n  const arrivalTimes = new Array(edges.length).fill(-1);\n  const startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) === -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nfunction areAllVerticesVisited(arrivalTimes) {\n  for (const time of arrivalTimes) {\n    if (time === -1) return false;\n  }\n\n  return true;\n}\n\nfunction getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime, arrivalTimes, edges) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  let minimumArrivalTime = currentTime;\n\n  for (const destination of edges[currentVertex]) {\n    if (arrivalTimes[destination] === -1) {\n      minimumArrivalTime = Math.min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime + 1, arrivalTimes, edges),\n      );\n    } else if (destination !== parent) {\n      minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime === currentTime && parent !== -1) return -1;\n\n  return minimumArrivalTime;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun twoEdgeConnectedGraph(edges: List<List<Int>>): Boolean {\n    // Write your code here.\n    return false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.min\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfun twoEdgeConnectedGraph(edges: List<List<Int>>): Boolean {\n    if (edges.size == 0) return true\n\n    val arrivalTimes = MutableList(edges.size) { -1 }\n    val startVertex = 0\n\n    if (\n        getMinimumArrivalTimeOfAncestors(\n                startVertex,\n                -1,\n                0,\n                arrivalTimes,\n                edges\n            ) == -1\n    ) {\n        return false\n    }\n\n    return areAllVerticesVisited(arrivalTimes)\n}\n\nfun areAllVerticesVisited(arrivalTimes: List<Int>): Boolean {\n    for (time in arrivalTimes) {\n        if (time == -1) return false\n    }\n\n    return true\n}\n\nfun getMinimumArrivalTimeOfAncestors(\n    currentVertex: Int,\n    parent: Int,\n    currentTime: Int,\n    arrivalTimes: MutableList<Int>,\n    edges: List<List<Int>>\n): Int {\n    arrivalTimes[currentVertex] = currentTime\n\n    var minimumArrivalTime = currentTime\n\n    for (destination in edges[currentVertex]) {\n        if (arrivalTimes[destination] == -1) {\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                getMinimumArrivalTimeOfAncestors(\n                    destination,\n                    currentVertex,\n                    currentTime + 1,\n                    arrivalTimes,\n                    edges\n                )\n            )\n        } else if (destination != parent) {\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                arrivalTimes[destination]\n            )\n        }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if (minimumArrivalTime == currentTime && parent != -1) return -1\n\n    return minimumArrivalTime\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.twoEdgeConnectedGraph\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 2, 5),\n            listOf(0, 2),\n            listOf(0, 1, 3),\n            listOf(2, 4, 5),\n            listOf(3, 5),\n            listOf(0, 3, 4)\n        )\n        val expected = true\n        val output = twoEdgeConnectedGraph(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.twoEdgeConnectedGraph\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\n            listOf(1, 2, 5),\n            listOf(0, 2),\n            listOf(0, 1, 3),\n            listOf(2, 4, 5),\n            listOf(3, 5),\n            listOf(0, 3, 4)\n        )\n        val expected = true\n        val output = twoEdgeConnectedGraph(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def twoEdgeConnectedGraph(edges):\n    # Write your code here.\n    return False\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(v + e) time | O(v) space - where v is the number of\n# vertices and e is the number of edges in the graph\ndef twoEdgeConnectedGraph(edges):\n    if len(edges) == 0:\n        return True\n\n    arrivalTimes = [-1] * len(edges)\n    startVertex = 0\n\n    if getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) == -1:\n        return False\n\n    return areAllVerticesVisited(arrivalTimes)\n\n\ndef areAllVerticesVisited(arrivalTimes):\n    for time in arrivalTimes:\n        if time == -1:\n            return False\n\n    return True\n\n\ndef getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime, arrivalTimes, edges):\n    arrivalTimes[currentVertex] = currentTime\n\n    minimumArrivalTime = currentTime\n\n    for destination in edges[currentVertex]:\n        if arrivalTimes[destination] == -1:\n            minimumArrivalTime = min(\n                minimumArrivalTime,\n                getMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime + 1, arrivalTimes, edges),\n            )\n        elif destination != parent:\n            minimumArrivalTime = min(minimumArrivalTime, arrivalTimes[destination])\n\n    # A bridge was detected, which means the graph isn't two-edge-connected.\n    if minimumArrivalTime == currentTime and parent != -1:\n        return -1\n\n    return minimumArrivalTime\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 2, 5], [0, 2], [0, 1, 3], [2, 4, 5], [3, 5], [0, 3, 4]]\n        expected = True\n        actual = program.twoEdgeConnectedGraph(input)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [[1, 2, 5], [0, 2], [0, 1, 3], [2, 4, 5], [3, 5], [0, 3, 4]]\n        expected = True\n        actual = program.twoEdgeConnectedGraph(input)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: false,
          startingCode:
            "class Program\n  def twoEdgeConnectedGraph(edges)\n    # Write your code here.\n    return false\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def twoEdgeConnectedGraph(edges)\n    # Write your code here.\n    return false\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.twoEdgeConnectedGraph\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.twoEdgeConnectedGraph\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func twoEdgeConnectedGraph(_ edges: inout [[Int]]) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(v + e) time | O(v) space - where v is the number of\n  // vertices and e is the number of edges in the graph\n  func twoEdgeConnectedGraph(_ edges: inout [[Int]]) -> Bool {\n    if edges.count == 0 {\n      return true\n    }\n\n    var arrivalTimes = Array(repeating: -1, count: edges.count)\n    let startVertex = 0\n\n    if getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, &arrivalTimes, &edges) == -1 {\n      return false\n    }\n\n    return areAllVerticesVisited(arrivalTimes)\n  }\n\n  func areAllVerticesVisited(_ arrivalTimes: [Int]) -> Bool {\n    for time in arrivalTimes {\n      if time == -1 {\n        return false\n      }\n    }\n    return true\n  }\n\n  func getMinimumArrivalTimeOfAncestors(_ currentVertex: Int, _ parent: Int, _ currentTime: Int,\n                                        _ arrivalTimes: inout [Int], _ edges: inout [[Int]]) -> Int\n  {\n    arrivalTimes[currentVertex] = currentTime\n\n    var minimumArrivalTime = currentTime\n\n    for destination in edges[currentVertex] {\n      if arrivalTimes[destination] == -1 {\n        minimumArrivalTime = min(\n          minimumArrivalTime,\n          getMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime + 1, &arrivalTimes, &edges)\n        )\n      } else if destination != parent {\n        minimumArrivalTime = min(\n          minimumArrivalTime,\n          arrivalTimes[destination]\n        )\n      }\n    }\n\n    // A bridge was detected, which means the graph isn't two-edge-connected.\n    if minimumArrivalTime == currentTime, parent != -1 {\n      return -1\n    }\n\n    return minimumArrivalTime\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [\n        [1, 2, 5],\n        [0, 2],\n        [0, 1, 3],\n        [2, 4, 5],\n        [3, 5],\n        [0, 3, 4],\n      ]\n      var expected = true\n      var actual = Program().twoEdgeConnectedGraph(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [\n        [1, 2, 5],\n        [0, 2],\n        [0, 1, 3],\n        [2, 4, 5],\n        [3, 5],\n        [0, 3, 4],\n      ]\n      var expected = true\n      var actual = Program().twoEdgeConnectedGraph(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function twoEdgeConnectedGraph(edges: number[][]) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nexport function twoEdgeConnectedGraph(edges: number[][]) {\n  if (edges.length === 0) return true;\n\n  const arrivalTimes = new Array(edges.length).fill(-1);\n  const startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) === -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nfunction areAllVerticesVisited(arrivalTimes: number[]) {\n  for (const time of arrivalTimes) {\n    if (time === -1) return false;\n  }\n\n  return true;\n}\n\nfunction getMinimumArrivalTimeOfAncestors(\n  currentVertex: number,\n  parent: number,\n  currentTime: number,\n  arrivalTimes: number[],\n  edges: number[][],\n) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  let minimumArrivalTime = currentTime;\n\n  for (const destination of edges[currentVertex]) {\n    if (arrivalTimes[destination] === -1) {\n      minimumArrivalTime = Math.min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(destination, currentVertex, currentTime + 1, arrivalTimes, edges),\n      );\n    } else if (destination !== parent) {\n      minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime === currentTime && parent !== -1) return -1;\n\n  return minimumArrivalTime;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "edges",
          example: [
            [1, 2, 5],
            [0, 2],
            [0, 1, 3],
            [2, 4, 5],
            [3, 5],
            [0, 3, 4],
          ],
          schema: {
            items: {
              items: {
                type: "integer",
              },
              type: "array",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          edges: [
            [1, 2, 5],
            [0, 2],
            [0, 1, 3],
            [2, 4, 5],
            [3, 5],
            [0, 3, 4],
          ],
        },
        {
          edges: [[1], [0, 2, 3], [1, 3], [1, 2]],
        },
        {
          edges: [
            [1, 2],
            [0, 2, 3],
            [1, 3, 0],
            [1, 2],
          ],
        },
        {
          edges: [[1], [0]],
        },
        {
          edges: [[], []],
        },
        {
          edges: [
            [1, 2, 3],
            [0, 2],
            [0, 1],
            [0, 4, 5],
            [3, 5],
            [3, 4],
          ],
        },
        {
          edges: [
            [1, 2, 3, 5],
            [0, 2],
            [0, 1],
            [0, 4, 5],
            [3, 5],
            [3, 4, 0],
          ],
        },
        {
          edges: [[]],
        },
        {
          edges: [
            [1, 5, 6],
            [0, 2, 6],
            [1, 6, 3],
            [6, 2, 4],
            [5, 6, 3],
            [4, 6, 0],
            [0, 1, 2, 3, 4, 5],
          ],
        },
        {
          edges: [
            [1, 5, 6],
            [0, 2, 6],
            [1, 6, 3],
            [6, 2, 4],
            [6, 3],
            [0],
            [0, 1, 2, 3, 4],
          ],
        },
        {
          edges: [
            [1, 2],
            [0, 2, 3],
            [1, 0, 4],
            [1, 4],
            [3, 2],
          ],
        },
        {
          edges: [[1, 2], [0, 2, 3], [1, 0, 4], [1, 4], [3, 2], []],
        },
        {
          edges: [
            [1, 7, 4],
            [0, 2, 7],
            [1, 6],
            [7, 5],
            [0, 7, 5],
            [4, 7, 6, 3],
            [5, 2, 7],
            [6, 0, 1, 3, 4, 5],
          ],
        },
        {
          edges: [],
        },
      ],
      jsonTests: [
        {
          edges: [
            [1, 2, 5],
            [0, 2],
            [0, 1, 3],
            [2, 4, 5],
            [3, 5],
            [0, 3, 4],
          ],
        },
        {
          edges: [[1], [0, 2, 3], [1, 3], [1, 2]],
        },
        {
          edges: [
            [1, 2],
            [0, 2, 3],
            [1, 3, 0],
            [1, 2],
          ],
        },
        {
          edges: [[1], [0]],
        },
        {
          edges: [[], []],
        },
        {
          edges: [
            [1, 2, 3],
            [0, 2],
            [0, 1],
            [0, 4, 5],
            [3, 5],
            [3, 4],
          ],
        },
        {
          edges: [
            [1, 2, 3, 5],
            [0, 2],
            [0, 1],
            [0, 4, 5],
            [3, 5],
            [3, 4, 0],
          ],
        },
        {
          edges: [[]],
        },
        {
          edges: [
            [1, 5, 6],
            [0, 2, 6],
            [1, 6, 3],
            [6, 2, 4],
            [5, 6, 3],
            [4, 6, 0],
            [0, 1, 2, 3, 4, 5],
          ],
        },
        {
          edges: [
            [1, 5, 6],
            [0, 2, 6],
            [1, 6, 3],
            [6, 2, 4],
            [6, 3],
            [0],
            [0, 1, 2, 3, 4],
          ],
        },
        {
          edges: [
            [1, 2],
            [0, 2, 3],
            [1, 0, 4],
            [1, 4],
            [3, 2],
          ],
        },
        {
          edges: [[1, 2], [0, 2, 3], [1, 0, 4], [1, 4], [3, 2], []],
        },
        {
          edges: [
            [1, 7, 4],
            [0, 2, 7],
            [1, 6],
            [7, 5],
            [0, 7, 5],
            [4, 7, 6, 3],
            [5, 2, 7],
            [6, 0, 1, 3, 4, 5],
          ],
        },
        {
          edges: [],
        },
      ],
      changelog: [],
      id: 15,
    },
    {
      uid: "palindrome-check",
      testStrategy: "JSON",
      name: "Palindrome Check",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Strings",
      difficulty: 1,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 56747,
        failureCount: 18802,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "225764612",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1130,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a non-empty string and that returns a boolean\n  representing whether the string is a palindrome.\n</p>\n<p>\n  A palindrome is defined as a string that\'s written the same forward and\n  backward. Note that single-character strings are palindromes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abcdcba"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// it\'s written the same forward and backward</span>\n</pre>\n</div>',
      hints: [
        "<p>\nStart by building the input string in reverse order and comparing this newly built string to the input string. Can you do this without using string concatenations?\n</p>\n",
        "\n<p>\nCan you optimize your algorithm by using recursion? What are the implications of recursion on an algorithm's space-time complexity analysis?\n</p>\n",
        "\n<p>\nGo back to an iterative solution and try using pointers to solve this problem: start with a pointer at the first index of the string and a pointer at the final index of the string. What can you do from there?\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input string",
      notes:
        '<div class="html">\n<p class="CodeEditor-notesQuestion">\n  Why does the first solution run in <i>O(n^2)</i> time when it only uses a\n  single <i>for</i> loop?\n</p>\n<p>\n  At each iteration in the <i>for</i> loop, the first solution adds a character\n  to the <span>reversedString</span>. In most languages where strings are\n  immutable, adding a character to a string involves re-creating the entire\n  string, which in turn involves iterating through every character in the string\n  (an <i>O(n)</i>-time operation).\n</p>\n<p>\n  This, the first solution has us perform an <i>O(n)</i>-time operation at each\n  iteration in the <i>for</i> loop, leading to an <i>O(n^2)</i>-time algorithm\n  overall.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nbool isPalindrome(string str) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n^2) time | O(n) space\nbool isPalindrome(string str) {\n  string reversedString = "";\n  for (int i = str.length() - 1; i >= 0; i--) {\n    reversedString += str[i];\n  }\n  return str == reversedString;\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <numeric>\nusing namespace std;\n\n// O(n) time | O(n) space\nbool isPalindrome(string str) {\n  vector<char> reversedChars;\n  for (int i = str.length() - 1; i >= 0; i--) {\n    reversedChars.push_back(str[i]);\n  }\n  return str == string(reversedChars.begin(), reversedChars.end());\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nbool helper(string str, int i);\n\n// O(n) time | O(n) space\nbool isPalindrome(string str) { return helper(str, 0); }\n\nbool helper(string str, int i) {\n  int j = str.length() - 1 - i;\n  return i >= j ? true : str[i] == str[j] && helper(str, i + 1);\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n) time | O(1) space\nbool isPalindrome(string str) {\n  int leftIdx = 0;\n  int rightIdx = str.length() - 1;\n  while (leftIdx < rightIdx) {\n    if (str[leftIdx] != str[rightIdx]) {\n      return false;\n    }\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() { assert(isPalindrome("abcdcba")); });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() { assert(isPalindrome("abcdcba")); });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static bool IsPalindrome(string str) {\n\t\t// Write your code here.\n\t\treturn false;\n\t}\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n^2) time | O(n) space\n\tpublic static bool IsPalindrome(string str) {\n\t\tstring reversedstring = "";\n\t\tfor (int i = str.Length - 1; i >= 0; i--) {\n\t\t\treversedstring += str[i];\n\t\t}\n\t\treturn str.Equals(reversedstring);\n\t}\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Text;\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static bool IsPalindrome(string str) {\n\t\tStringBuilder reversedstring = new StringBuilder();\n\t\tfor (int i = str.Length - 1; i >= 0; i--) {\n\t\t\treversedstring.Append(str[i]);\n\t\t}\n\t\treturn str.Equals(reversedstring.ToString());\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static bool IsPalindrome(string str) {\n\t\treturn IsPalindrome(str, 0);\n\t}\n\n\tpublic static bool IsPalindrome(string str, int i) {\n\t\tint j = str.Length - 1 - i;\n\t\treturn i >= j ? true : str[i] == str[j] && IsPalindrome(str, i + 1);\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n) time | O(1) space\n\tpublic static bool IsPalindrome(string str) {\n\t\tint leftIdx = 0;\n\t\tint rightIdx = str.Length - 1;\n\t\twhile (leftIdx < rightIdx) {\n\t\t\tif (str[leftIdx] != str[rightIdx]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tleftIdx++;\n\t\t\trightIdx--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.IsPalindrome("abcdcba"));\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.IsPalindrome("abcdcba"));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc IsPalindrome(str string) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space\nfunc IsPalindrome(str string) bool {\n\treversed := ""\n\tfor i := len(str) - 1; i >= 0; i-- {\n\t\treversed += string(str[i])\n\t}\n\tfor i := range str {\n\t\tif reversed[i] != str[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space\nfunc IsPalindrome(str string) bool {\n\tresult := []byte{}\n\tfor i := len(str) - 1; i >= 0; i-- {\n\t\tresult = append(result, str[i])\n\t}\n\treturn str == string(result)\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space\nfunc IsPalindrome(str string) bool {\n\treturn helper(str, 0)\n}\n\nfunc helper(str string, i int) bool {\n\tj := len(str) - 1 - i\n\tif i >= j {\n\t\treturn true\n\t}\n\tif str[i] != str[j] {\n\t\treturn false\n\t}\n\treturn helper(str, i+1)\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space\nfunc IsPalindrome(str string) bool {\n\tfor i := 0; i < len(str); i++ {\n\t\tj := len(str) - i - 1\n\t\tif str[i] != str[j] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := true\n\toutput := IsPalindrome("abcdcba")\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := true\n\toutput := IsPalindrome("abcdcba")\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static boolean isPalindrome(String str) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space\n  public static boolean isPalindrome(String str) {\n    String reversedString = "";\n    for (int i = str.length() - 1; i >= 0; i--) {\n      reversedString += str.charAt(i);\n    }\n    return str.equals(reversedString);\n  }\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  public static boolean isPalindrome(String str) {\n    StringBuilder reversedString = new StringBuilder();\n    for (int i = str.length() - 1; i >= 0; i--) {\n      reversedString.append(str.charAt(i));\n    }\n    return str.equals(reversedString.toString());\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  public static boolean isPalindrome(String str) {\n    return isPalindrome(str, 0);\n  }\n\n  public static boolean isPalindrome(String str, int i) {\n    int j = str.length() - 1 - i;\n    return i >= j ? true : str.charAt(i) == str.charAt(j) && isPalindrome(str, i + 1);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  public static boolean isPalindrome(String str) {\n    int leftIdx = 0;\n    int rightIdx = str.length() - 1;\n    while (leftIdx < rightIdx) {\n      if (str.charAt(leftIdx) != str.charAt(rightIdx)) {\n        return false;\n      }\n      leftIdx++;\n      rightIdx--;\n    }\n    return true;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.isPalindrome("abcdcba"));\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.isPalindrome("abcdcba"));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function isPalindrome(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.isPalindrome = isPalindrome;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nfunction isPalindrome(string) {\n  let reversedString = '';\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedString += string[i];\n  }\n  return string === reversedString;\n}\n\nexports.isPalindrome = isPalindrome;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction isPalindrome(string) {\n  const reversedChars = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedChars.push(string[i]);\n  }\n  return string === reversedChars.join('');\n}\n\nexports.isPalindrome = isPalindrome;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction isPalindrome(string, i = 0) {\n  const j = string.length - 1 - i;\n  return i >= j ? true : string[i] === string[j] && isPalindrome(string, i + 1);\n}\n\nexports.isPalindrome = isPalindrome;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nfunction isPalindrome(string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n\nexports.isPalindrome = isPalindrome;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun isPalindrome(string: String): Boolean {\n    // Write your code here.\n    return false\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space\nfun isPalindrome(string: String): Boolean {\n    var reversedString = ""\n    for (i in string.length - 1 downTo 0) {\n        reversedString += string[i]\n    }\n    return string == reversedString\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space\nfun isPalindrome(string: String): Boolean {\n    val reversedChars = mutableListOf<Char>()\n    for (i in string.length - 1 downTo 0) {\n        reversedChars.add(string[i])\n    }\n    return string == reversedChars.joinToString("")\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space\nfun isPalindrome(string: String = "", i: Int = 0): Boolean {\n    val j = string.length - 1 - i\n    return if (i >= j) true else string[i] == string[j] && isPalindrome(string, i + 1)\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(1) space\nfun isPalindrome(string: String): Boolean {\n    var leftIdx = 0\n    var rightIdx = string.length - 1\n    while (leftIdx < rightIdx) {\n        if (string[leftIdx] != string[rightIdx]) return false\n        leftIdx++\n        rightIdx--\n    }\n    return true\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.isPalindrome as isPalindrome\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(isPalindrome("abcdcba"))\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.isPalindrome as isPalindrome\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(isPalindrome("abcdcba"))\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def isPalindrome(string):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space\ndef isPalindrome(string):\n    reversedString = ""\n    for i in reversed(range(len(string))):\n        reversedString += string[i]\n    return string == reversedString\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef isPalindrome(string):\n    reversedChars = []\n    for i in reversed(range(len(string))):\n        reversedChars.append(string[i])\n    return string == "".join(reversedChars)\n',
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef isPalindrome(string, i=0):\n    j = len(string) - 1 - i\n    return True if i >= j else string[i] == string[j] and isPalindrome(string, i + 1)\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space\ndef isPalindrome(string):\n    leftIdx = 0\n    rightIdx = len(string) - 1\n    while leftIdx < rightIdx:\n        if string[leftIdx] != string[rightIdx]:\n            return False\n        leftIdx += 1\n        rightIdx -= 1\n    return True\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.isPalindrome("abcdcba"), True)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.isPalindrome("abcdcba"), True)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def isPalindrome(string)\n    # Write your code here.\n    return false\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def isPalindrome(string)\n    # Write your code here.\n    return false\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def isPalindrome(string)\n    # Write your code here.\n    return false\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def isPalindrome(string)\n    # Write your code here.\n    return false\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def isPalindrome(string)\n    # Write your code here.\n    return false\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.isPalindrome\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.isPalindrome\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func isPalindrome(string: String) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space\n  func isPalindrome(string: String) -> Bool {\n    var reversedString = ""\n\n    for i in (0 ..< string.count).reversed() {\n      let startIndex = string.index(string.startIndex, offsetBy: i)\n\n      let currentChar = string[startIndex]\n      reversedString.append(currentChar)\n    }\n\n    return string == reversedString\n  }\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func isPalindrome(string: String) -> Bool {\n    var reversedChars = [Character]()\n\n    for i in (0 ..< string.count).reversed() {\n      let startIndex = string.index(string.startIndex, offsetBy: i)\n\n      let currentChar = string[startIndex]\n      reversedChars.append(currentChar)\n    }\n\n    let reversedString = String(reversedChars)\n\n    return string == reversedString\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func isPalindrome(string: String, firstIndex: Int = 0) -> Bool {\n    let lastIndex = string.count - 1 - firstIndex\n\n    if firstIndex >= lastIndex {\n      return true\n    }\n\n    let startIndex = string.index(string.startIndex, offsetBy: firstIndex)\n    let endIndex = string.index(string.startIndex, offsetBy: lastIndex)\n\n    let firstAndLastAreEqual = string[startIndex] == string[endIndex]\n    let palindromeCheck = isPalindrome(string: string, firstIndex: firstIndex + 1)\n\n    return firstAndLastAreEqual && palindromeCheck\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  func isPalindrome(string: String) -> Bool {\n    var leftPointer = 0\n    var rightPointer = string.count - 1\n    var leftIndex = string.index(string.startIndex, offsetBy: leftPointer)\n    var rightIndex = string.index(string.startIndex, offsetBy: rightPointer)\n\n    while leftIndex < rightIndex {\n      if string[leftIndex] != string[rightIndex] {\n        return false\n      }\n\n      leftPointer = leftPointer + 1\n      rightPointer = rightPointer - 1\n      leftIndex = string.index(string.startIndex, offsetBy: leftPointer)\n      rightIndex = string.index(string.startIndex, offsetBy: rightPointer)\n    }\n\n    return true\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.isPalindrome(string: "abcdcba"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(true, program.isPalindrome(string: "abcdcba"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function isPalindrome(string: string) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nexport function isPalindrome(string: string) {\n  let reversedString = '';\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedString += string[i];\n  }\n  return string === reversedString;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function isPalindrome(string: string) {\n  const reversedChars: string[] = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedChars.push(string[i]);\n  }\n  return string === reversedChars.join('');\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function isPalindrome(string: string, i = 0): boolean {\n  const j = string.length - 1 - i;\n  return i >= j ? true : string[i] === string[j] && isPalindrome(string, i + 1);\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nexport function isPalindrome(string: string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "abcdcba",
          schema: {
            minLength: 1,
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "abcdcba",
        },
        {
          string: "a",
        },
        {
          string: "ab",
        },
        {
          string: "aba",
        },
        {
          string: "abb",
        },
        {
          string: "abba",
        },
        {
          string: "abcdefghhgfedcba",
        },
        {
          string: "abcdefghihgfedcba",
        },
        {
          string: "abcdefghihgfeddcba",
        },
      ],
      jsonTests: [
        {
          string: "abcdcba",
        },
        {
          string: "a",
        },
        {
          string: "ab",
        },
        {
          string: "aba",
        },
        {
          string: "abb",
        },
        {
          string: "abba",
        },
        {
          string: "abcdefghhgfedcba",
        },
        {
          string: "abcdefghihgfedcba",
        },
        {
          string: "abcdefghihgfeddcba",
        },
      ],
      changelog: [],
      id: 16,
    },
    {
      uid: "smallest-difference",
      testStrategy: "JSON",
      name: "Smallest Difference",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Arrays",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 50368,
        failureCount: 20192,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226846336",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 943,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in two non-empty arrays of integers, finds the\n  pair of numbers (one from each array) whose absolute difference is closest to\n  zero, and returns an array containing these two numbers, with the number from\n  the first array in the first position.\n</p>\n<p>\n  Note that the absolute difference of two integers is the distance between\n  them on the real number line. For example, the absolute difference of -5 and 5\n  is 10, and the absolute difference of -5 and -4 is 1.\n</p>\n<p>\n  You can assume that there will only be one pair of numbers with the smallest\n  difference.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">arrayOne</span> = [-1, 5, 10, 20, 28, 3]\n<span class="CodeEditor-promptParameter">arrayTwo</span> = [26, 134, 135, 15, 17]\n</pre>\n<h3>Sample Output</h3>\n<pre>[28, 26]</pre>\n</div>',
      hints: [
        "<p>\nInstead of generating all possible pairs of numbers, try somehow only looking at pairs that you know could actually have the smallest difference. How can you accomplish this?\n</p>\n",
        "\n<p>\nWould it help if the two arrays were sorted? If the arrays were sorted and you were looking at a given pair of numbers, could you efficiently find the next pair of numbers to look at? What are the runtime implications of sorting the arrays?\n</p>\n",
        "\n<p>\nStart by sorting both arrays, as per Hint #2. Put a pointer at the beginning of both arrays and evaluate the absolute difference of the pointer-numbers. If the difference is equal to zero, then you've found the closest pair; otherwise, increment the pointer of the smaller of the two numbers to find a potentially better pair. Continue until you get a pair with a difference of zero or until one of the pointers gets out of range of its array.\n</p>",
      ],
      spaceTime:
        "O(nlog(n) + mlog(m)) time | O(1) space - where n is the length of the first input array and m is the length of the second input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> smallestDifference(vector<int> arrayOne, vector<int> arrayTwo) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n// O(nlog(n) + mlog(m)) time | O(1) space\nvector<int> smallestDifference(vector<int> arrayOne, vector<int> arrayTwo) {\n  sort(arrayOne.begin(), arrayOne.end());\n  sort(arrayTwo.begin(), arrayTwo.end());\n  int idxOne = 0;\n  int idxTwo = 0;\n  int smallest = INT_MAX;\n  int current = INT_MAX;\n  vector<int> smallestPair;\n  while (idxOne < arrayOne.size() && idxTwo < arrayTwo.size()) {\n    int firstNum = arrayOne[idxOne];\n    int secondNum = arrayTwo[idxTwo];\n    if (firstNum < secondNum) {\n      current = secondNum - firstNum;\n      idxOne++;\n    } else if (secondNum < firstNum) {\n      current = firstNum - secondNum;\n      idxTwo++;\n    } else {\n      return vector<int>{firstNum, secondNum};\n    }\n    if (smallest > current) {\n      smallest = current;\n      smallestPair = {firstNum, secondNum};\n    }\n  }\n  return smallestPair;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{28, 26};\n      assert(smallestDifference({-1, 5, 10, 20, 28, 3},\n                                {26, 134, 135, 15, 17}) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{28, 26};\n      assert(smallestDifference({-1, 5, 10, 20, 28, 3},\n                                {26, 134, 135, 15, 17}) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] SmallestDifference(int[] arrayOne, int[] arrayTwo) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(nlog(n) + mlog(m)) time | O(1) space\n\tpublic static int[] SmallestDifference(int[] arrayOne, int[] arrayTwo) {\n\t\tArray.Sort(arrayOne);\n\t\tArray.Sort(arrayTwo);\n\t\tint idxOne = 0;\n\t\tint idxTwo = 0;\n\t\tint smallest = Int32.MaxValue;\n\t\tint current = Int32.MaxValue;\n\t\tint[] smallestPair = new int[2];\n\t\twhile (idxOne < arrayOne.Length && idxTwo < arrayTwo.Length) {\n\t\t\tint firstNum = arrayOne[idxOne];\n\t\t\tint secondNum = arrayTwo[idxTwo];\n\t\t\tif (firstNum < secondNum) {\n\t\t\t\tcurrent = secondNum - firstNum;\n\t\t\t\tidxOne++;\n\t\t\t} else if (secondNum < firstNum) {\n\t\t\t\tcurrent = firstNum - secondNum;\n\t\t\t\tidxTwo++;\n\t\t\t} else {\n\t\t\t\treturn new int[] {firstNum, secondNum};\n\t\t\t}\n\t\t\tif (smallest > current) {\n\t\t\t\tsmallest = current;\n\t\t\t\tsmallestPair = new int[] {firstNum, secondNum};\n\t\t\t}\n\t\t}\n\t\treturn smallestPair;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {28, 26};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.SmallestDifference(new int[] {-1,\n\t\t                                                                                5,\n\t\t                                                                                10,\n\t\t                                                                                20,\n\t\t                                                                                28,\n\t\t                                                                                3},\n\t\t  new int[] {26,\n\t\t             134,\n\t\t             135,\n\t\t             15,\n\t\t             17}),\n\t\t  expected));\n\t}\n}\n",
          unitTests:
            "using System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {28, 26};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.SmallestDifference(new int[] {-1,\n\t\t                                                                                5,\n\t\t                                                                                10,\n\t\t                                                                                20,\n\t\t                                                                                28,\n\t\t                                                                                3},\n\t\t  new int[] {26,\n\t\t             134,\n\t\t             135,\n\t\t             15,\n\t\t             17}),\n\t\t  expected));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc SmallestDifference(array1, array2 []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"math"\n\t"sort"\n)\n\n// O(nlog(n) + mlog(m)) time | O(1) space\nfunc SmallestDifference(array1, array2 []int) []int {\n\tsort.Ints(array1)\n\tsort.Ints(array2)\n\tidxOne, idxTwo := 0, 0\n\tsmallest, current := math.MaxInt32, math.MaxInt32\n\tsmallestPair := []int{}\n\tfor idxOne < len(array1) && idxTwo < len(array2) {\n\t\tfirst, second := array1[idxOne], array2[idxTwo]\n\t\tif first < second {\n\t\t\tcurrent = second - first\n\t\t\tidxOne += 1\n\t\t} else if second < first {\n\t\t\tcurrent = first - second\n\t\t\tidxTwo += 1\n\t\t} else {\n\t\t\treturn []int{first, second}\n\t\t}\n\t\tif smallest > current {\n\t\t\tsmallest = current\n\t\t\tsmallestPair = []int{first, second}\n\t\t}\n\t}\n\treturn smallestPair\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{28, 26}\n\toutput := SmallestDifference([]int{-1, 5, 10, 20, 28, 3}, []int{26, 134, 135, 15, 17})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{28, 26}\n\toutput := SmallestDifference([]int{-1, 5, 10, 20, 28, 3}, []int{26, 134, 135, 15, 17})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] smallestDifference(int[] arrayOne, int[] arrayTwo) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.Arrays;\n\nclass Program {\n  // O(nlog(n) + mlog(m)) time | O(1) space\n  public static int[] smallestDifference(int[] arrayOne, int[] arrayTwo) {\n    Arrays.sort(arrayOne);\n    Arrays.sort(arrayTwo);\n    int idxOne = 0;\n    int idxTwo = 0;\n    int smallest = Integer.MAX_VALUE;\n    int current = Integer.MAX_VALUE;\n    int[] smallestPair = new int[2];\n    while (idxOne < arrayOne.length && idxTwo < arrayTwo.length) {\n      int firstNum = arrayOne[idxOne];\n      int secondNum = arrayTwo[idxTwo];\n      if (firstNum < secondNum) {\n        current = secondNum - firstNum;\n        idxOne++;\n      } else if (secondNum < firstNum) {\n        current = firstNum - secondNum;\n        idxTwo++;\n      } else {\n        return new int[] {firstNum, secondNum};\n      }\n      if (smallest > current) {\n        smallest = current;\n        smallestPair = new int[] {firstNum, secondNum};\n      }\n    }\n    return smallestPair;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {28, 26};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.smallestDifference(\n                new int[] {-1, 5, 10, 20, 28, 3}, new int[] {26, 134, 135, 15, 17}),\n            expected));\n  }\n}\n",
          unitTests:
            "import java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {28, 26};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.smallestDifference(\n                new int[] {-1, 5, 10, 20, 28, 3}, new int[] {26, 134, 135, 15, 17}),\n            expected));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function smallestDifference(arrayOne, arrayTwo) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.smallestDifference = smallestDifference;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n) + mlog(m)) time | O(1) space\nfunction smallestDifference(arrayOne, arrayTwo) {\n  arrayOne.sort((a, b) => a - b);\n  arrayTwo.sort((a, b) => a - b);\n  let idxOne = 0;\n  let idxTwo = 0;\n  let smallest = Infinity;\n  let current = Infinity;\n  let smallestPair = [];\n  while (idxOne < arrayOne.length && idxTwo < arrayTwo.length) {\n    let firstNum = arrayOne[idxOne];\n    let secondNum = arrayTwo[idxTwo];\n    if (firstNum < secondNum) {\n      current = secondNum - firstNum;\n      idxOne++;\n    } else if (secondNum < firstNum) {\n      current = firstNum - secondNum;\n      idxTwo++;\n    } else {\n      return [firstNum, secondNum];\n    }\n    if (smallest > current) {\n      smallest = current;\n      smallestPair = [firstNum, secondNum];\n    }\n  }\n  return smallestPair;\n}\n\nexports.smallestDifference = smallestDifference;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17])).to.deep.equal([28, 26]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17])).to.deep.equal([28, 26]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun smallestDifference(arrayOne: MutableList<Int>, arrayTwo: MutableList<Int>): List<Int> {\n    // Write your code here.\n    return listOf<Int>()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nlog(n) + mlog(m)) time | O(1) space\nfun smallestDifference(arrayOne: MutableList<Int>, arrayTwo: MutableList<Int>): List<Int> {\n    arrayOne.sort()\n    arrayTwo.sort()\n    var idxOne = 0\n    var idxTwo = 0\n    var smallest = Int.MAX_VALUE\n    var current: Int\n    var smallestPair = listOf<Int>()\n    while (idxOne < arrayOne.size && idxTwo < arrayTwo.size) {\n        var firstNum = arrayOne[idxOne]\n        var secondNum = arrayTwo[idxTwo]\n        if (firstNum < secondNum) {\n            current = secondNum - firstNum\n            idxOne++\n        } else if (secondNum < firstNum) {\n            current = firstNum - secondNum\n            idxTwo++\n        } else {\n            return listOf<Int>(firstNum, secondNum)\n        }\n        if (smallest > current) {\n            smallest = current\n            smallestPair = listOf<Int>(firstNum, secondNum)\n        }\n    }\n    return smallestPair\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.smallestDifference as smallestDifference\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val arrayOne = mutableListOf<Int>(-1, 5, 10, 20, 28, 3)\n        val arrayTwo = mutableListOf<Int>(26, 134, 135, 15, 17)\n        val output = smallestDifference(arrayOne, arrayTwo)\n        val expected = listOf<Int>(28, 26)\n        assert(output.equals(expected))\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.smallestDifference as smallestDifference\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val arrayOne = mutableListOf<Int>(-1, 5, 10, 20, 28, 3)\n        val arrayTwo = mutableListOf<Int>(26, 134, 135, 15, 17)\n        val output = smallestDifference(arrayOne, arrayTwo)\n        val expected = listOf<Int>(28, 26)\n        assert(output.equals(expected))\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def smallestDifference(arrayOne, arrayTwo):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nlog(n) + mlog(m)) time | O(1) space\ndef smallestDifference(arrayOne, arrayTwo):\n    arrayOne.sort()\n    arrayTwo.sort()\n    idxOne = 0\n    idxTwo = 0\n    smallest = float("inf")\n    current = float("inf")\n    smallestPair = []\n    while idxOne < len(arrayOne) and idxTwo < len(arrayTwo):\n        firstNum = arrayOne[idxOne]\n        secondNum = arrayTwo[idxTwo]\n        if firstNum < secondNum:\n            current = secondNum - firstNum\n            idxOne += 1\n        elif secondNum < firstNum:\n            current = firstNum - secondNum\n            idxTwo += 1\n        else:\n            return [firstNum, secondNum]\n        if smallest > current:\n            smallest = current\n            smallestPair = [firstNum, secondNum]\n    return smallestPair\n',
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17]), [28, 26])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17]), [28, 26])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def smallestDifference(arrayOne, arrayTwo)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def smallestDifference(arrayOne, arrayTwo)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.smallestDifference\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.smallestDifference\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func smallestDifference(arrayOne: inout [Int], arrayTwo: inout [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  func smallestDifference(arrayOne: inout [Int], arrayTwo: inout [Int]) -> [Int] {\n    arrayOne.sort()\n    arrayTwo.sort()\n\n    var idxOne = 0\n    var idxTwo = 0\n\n    var current = Int.max\n    var smallest = Int.max\n\n    var smallestPair: [Int] = []\n\n    while idxOne < arrayOne.count, idxTwo < arrayTwo.count {\n      let firstNum = arrayOne[idxOne]\n      let secondNum = arrayTwo[idxTwo]\n\n      if firstNum < secondNum {\n        current = secondNum - firstNum\n        idxOne = idxOne + 1\n      } else if firstNum > secondNum {\n        current = firstNum - secondNum\n        idxTwo = idxTwo + 1\n      } else {\n        return [firstNum, secondNum]\n      }\n\n      if smallest > current {\n        smallest = current\n        smallestPair = [firstNum, secondNum]\n      }\n    }\n\n    return smallestPair\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var firstArray = [-1, 5, 10, 20, 28, 3]\n      var secondArray = [26, 134, 135, 15, 17]\n      let difference = program.smallestDifference(arrayOne: &firstArray, arrayTwo: &secondArray)\n      try assertEqual([28, 26], difference)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var firstArray = [-1, 5, 10, 20, 28, 3]\n      var secondArray = [26, 134, 135, 15, 17]\n      let difference = program.smallestDifference(arrayOne: &firstArray, arrayTwo: &secondArray)\n      try assertEqual([28, 26], difference)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function smallestDifference(arrayOne: number[], arrayTwo: number[]) {\n  // Write your code here.\n  return [-1, -1];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n) + mlog(m)) time | O(1) space\nexport function smallestDifference(arrayOne: number[], arrayTwo: number[]) {\n  arrayOne.sort((a, b) => a - b);\n  arrayTwo.sort((a, b) => a - b);\n  let idxOne = 0;\n  let idxTwo = 0;\n  let smallest = Infinity;\n  let current = Infinity;\n  let smallestPair: number[] = [];\n  while (idxOne < arrayOne.length && idxTwo < arrayTwo.length) {\n    let firstNum = arrayOne[idxOne];\n    let secondNum = arrayTwo[idxTwo];\n    if (firstNum < secondNum) {\n      current = secondNum - firstNum;\n      idxOne++;\n    } else if (secondNum < firstNum) {\n      current = firstNum - secondNum;\n      idxTwo++;\n    } else {\n      return [firstNum, secondNum];\n    }\n    if (smallest > current) {\n      smallest = current;\n      smallestPair = [firstNum, secondNum];\n    }\n  }\n  return smallestPair;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17])).to.deep.equal([28, 26]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17])).to.deep.equal([28, 26]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "arrayOne",
          example: [-1, 5, 10, 20, 28, 3],
          schema: {
            items: {
              type: "integer",
            },
            minItems: 1,
            type: "array",
          },
        },
        {
          name: "arrayTwo",
          example: [26, 134, 135, 15, 17],
          schema: {
            items: {
              type: "integer",
            },
            minItems: 1,
            type: "array",
          },
        },
      ],
      tests: [
        {
          arrayOne: [-1, 5, 10, 20, 28, 3],
          arrayTwo: [26, 134, 135, 15, 17],
        },
        {
          arrayOne: [-1, 5, 10, 20, 3],
          arrayTwo: [26, 134, 135, 15, 17],
        },
        {
          arrayOne: [10, 0, 20, 25],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [10, 0, 20, 25, 2200],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [10, 0, 20, 25, 2000],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [240, 124, 86, 111, 2, 84, 954, 27, 89],
          arrayTwo: [1, 3, 954, 19, 8],
        },
        {
          arrayOne: [0, 20],
          arrayTwo: [21, -2],
        },
        {
          arrayOne: [10, 1000],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
        {
          arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
        {
          arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123, 530],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
      ],
      jsonTests: [
        {
          arrayOne: [-1, 5, 10, 20, 28, 3],
          arrayTwo: [26, 134, 135, 15, 17],
        },
        {
          arrayOne: [-1, 5, 10, 20, 3],
          arrayTwo: [26, 134, 135, 15, 17],
        },
        {
          arrayOne: [10, 0, 20, 25],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [10, 0, 20, 25, 2200],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [10, 0, 20, 25, 2000],
          arrayTwo: [1005, 1006, 1014, 1032, 1031],
        },
        {
          arrayOne: [240, 124, 86, 111, 2, 84, 954, 27, 89],
          arrayTwo: [1, 3, 954, 19, 8],
        },
        {
          arrayOne: [0, 20],
          arrayTwo: [21, -2],
        },
        {
          arrayOne: [10, 1000],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
        {
          arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
        {
          arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123, 530],
          arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
        },
      ],
      changelog: [],
      id: 17,
    },
    {
      uid: "merge-overlapping-intervals",
      testStrategy: "JSON",
      name: "Merge Overlapping Intervals",
      version: 0,
      releaseDate: "2021-04-01T00:00:00Z",
      category: "Arrays",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 16323,
        failureCount: 5793,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "557896069",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1082,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of arbitrary intervals,\n  merges any overlapping intervals, and returns the new intervals in no\n  particular order.\n</p>\n<p>\n  Each interval <span>interval</span> is an array of two integers, with\n  <span>interval[0]</span> as the start of the interval and\n  <span>interval[1]</span> as the end of the interval.\n</p>\n<p>\n  Note that back-to-back intervals aren\'t considered to be overlapping. For\n  example, <span>[1, 5]</span> and <span>[6, 7]</span> aren\'t overlapping;\n  however, <span>[1, 6]</span> and <span>[6, 7]</span> <i>are</i> indeed\n  overlapping.\n</p>\n<p>\n  Also note that the start of any particular interval will always be less than\n  or equal to the end of that interval.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">intervals</span> = [[1, 2], [3, 5], [4, 7], [6, 8], [9, 10]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[1, 2], [3, 8], [9, 10]]\n<span class="CodeEditor-promptComment">// Merge the intervals [3, 5], [4, 7], and [6, 8].</span>\n<span class="CodeEditor-promptComment">// The intervals could be ordered differently.</span>\n</pre>\n</div>',
      hints: [
        "<p>\n  The problem asks you to merge overlapping intervals. How can you determine if\n  two intervals are overlapping?\n</p>\n",
        "\n<p>\n  Sort the intervals with respect to their starting values. This will allow you\n  to merge all overlapping intervals in a single traversal through the sorted\n  intervals.\n</p>\n",
        "\n<p>\n  After sorting the intervals with respect to their starting values, traverse\n  them, and at each iteration, compare the start of the next interval to the end\n  of the current interval to look for an overlap. If you find an overlap, mutate\n  the current interval so as to merge the next interval into it.\n</p>",
      ],
      spaceTime:
        "O(nlog(n)) time | O(n) space - where n is the length of the input array",
      notes:
        "<div class=\"html\">\n<p>\n  Important note: while this problem's prompt specifies that the input array of\n  intervals is non-empty, in a real coding interview, it would be important to\n  double-check this with your interviewer and to ask them if they'd like you to\n  handle that edge case in your function.\n</p>\n<p>\n  As they currently stand, our sample solutions would have a run-time error if\n  the input array were empty.\n</p>\n</div>",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<vector<int>> mergeOverlappingIntervals(vector<vector<int>> intervals) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// O(nlog(n)) time | O(n) space - where n is the length of the input array\nvector<vector<int>> mergeOverlappingIntervals(vector<vector<int>> intervals) {\n  vector<vector<int>> sortedIntervals = intervals;\n  sort(sortedIntervals.begin(), sortedIntervals.end(),\n       [](vector<int> a, vector<int> b) { return a[0] < b[0]; });\n\n  vector<vector<int> *> mergedIntervals;\n  vector<int> *currentInterval = &sortedIntervals[0];\n  mergedIntervals.push_back(currentInterval);\n\n  for (auto &nextInterval : sortedIntervals) {\n    int currentIntervalEnd = currentInterval->at(1);\n    int nextIntervalStart = nextInterval[0];\n    int nextIntervalEnd = nextInterval[1];\n\n    if (currentIntervalEnd >= nextIntervalStart) {\n      currentInterval->at(1) = max(currentIntervalEnd, nextIntervalEnd);\n    } else {\n      currentInterval = &nextInterval;\n      mergedIntervals.push_back(currentInterval);\n    }\n  }\n\n  vector<vector<int>> mergedIntervalsCopy;\n  for (auto interval : mergedIntervals) {\n    mergedIntervalsCopy.push_back(*interval);\n  }\n  return mergedIntervalsCopy;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> intervals = {{1, 2}, {3, 5}, {4, 7}, {6, 8}, {9, 10}};\n      vector<vector<int>> expected = {{1, 2}, {3, 8}, {9, 10}};\n      auto actual = mergeOverlappingIntervals(intervals);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> intervals = {{1, 2}, {3, 5}, {4, 7}, {6, 8}, {9, 10}};\n      vector<vector<int>> expected = {{1, 2}, {3, 8}, {9, 10}};\n      auto actual = mergeOverlappingIntervals(intervals);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic int[][] MergeOverlappingIntervals(int[][] intervals) {\n\t\t// Write your code here.\n\t\treturn new int[][] {};\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(nlog(n)) time | O(n) space - where n is the length of the input array\n\tpublic int[][] MergeOverlappingIntervals(int[][] intervals) {\n\t\t// Sort the intervals by starting value.\n\t\tint[][] sortedIntervals = intervals.Clone() as int[][];\n\t\tArray.Sort(sortedIntervals, (a, b) => a[0].CompareTo(b[0]));\n\n\t\tList<int[]> mergedIntervals = new List<int[]>();\n\t\tint[] currentInterval = sortedIntervals[0];\n\t\tmergedIntervals.Add(currentInterval);\n\n\t\tforeach (var nextInterval in sortedIntervals) {\n\t\t\tint currentIntervalEnd = currentInterval[1];\n\t\t\tint nextIntervalStart = nextInterval[0];\n\t\t\tint nextIntervalEnd = nextInterval[1];\n\n\t\t\tif (currentIntervalEnd >= nextIntervalStart) {\n\t\t\t\tcurrentInterval[1] = Math.Max(currentIntervalEnd, nextIntervalEnd);\n\t\t\t} else {\n\t\t\t\tcurrentInterval = nextInterval;\n\t\t\t\tmergedIntervals.Add(currentInterval);\n\t\t\t}\n\t\t}\n\n\t\treturn mergedIntervals.ToArray();\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] intervals = new int[][] {\n\t\t\tnew int[] {1,2},\n\t\t\tnew int[] {3,5},\n\t\t\tnew int[] {4,7},\n\t\t\tnew int[] {6,8},\n\t\t\tnew int[] {9,10},\n\t\t};\n\t\tint[][] expected = new int[][] {\n\t\t\tnew int[] {1,2},\n\t\t\tnew int[] {3,8},\n\t\t\tnew int[] {9,10},\n\t\t};\n\t\tint[][] actual = new Program().MergeOverlappingIntervals(intervals);\n\t\tfor (int i=0; i<actual.Length; i++) {\n\t\t\tfor (int j=0; j<actual[i].Length; j++) {\n\t\t\t\tUtils.AssertTrue(expected[i][j] == actual[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] intervals = new int[][] {\n\t\t\tnew int[] {1,2},\n\t\t\tnew int[] {3,5},\n\t\t\tnew int[] {4,7},\n\t\t\tnew int[] {6,8},\n\t\t\tnew int[] {9,10},\n\t\t};\n\t\tint[][] expected = new int[][] {\n\t\t\tnew int[] {1,2},\n\t\t\tnew int[] {3,8},\n\t\t\tnew int[] {9,10},\n\t\t};\n\t\tint[][] actual = new Program().MergeOverlappingIntervals(intervals);\n\t\tfor (int i=0; i<actual.Length; i++) {\n\t\t\tfor (int j=0; j<actual[i].Length; j++) {\n\t\t\t\tUtils.AssertTrue(expected[i][j] == actual[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc MergeOverlappingIntervals(intervals [][]int) [][]int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"sort"\n)\n\n// O(nlog(n)) time | O(n) space - where n is the length of the input array\nfunc MergeOverlappingIntervals(intervals [][]int) [][]int {\n\tsortedIntervals := make([][]int, len(intervals))\n\tcopy(sortedIntervals, intervals)\n\tsort.Slice(sortedIntervals, func(i, j int) bool {\n\t\treturn sortedIntervals[i][0] < sortedIntervals[j][0]\n\t})\n\n\tmergedIntervals := make([][]int, 0)\n\tcurrentInterval := sortedIntervals[0]\n\tmergedIntervals = append(mergedIntervals, currentInterval)\n\n\tfor _, nextInterval := range sortedIntervals {\n\t\tcurrentIntervalEnd := currentInterval[1]\n\t\tnextIntervalStart, nextIntervalEnd := nextInterval[0], nextInterval[1]\n\n\t\tif currentIntervalEnd >= nextIntervalStart {\n\t\t\tcurrentInterval[1] = max(currentIntervalEnd, nextIntervalEnd)\n\t\t} else {\n\t\t\tcurrentInterval = nextInterval\n\t\t\tmergedIntervals = append(mergedIntervals, currentInterval)\n\t\t}\n\t}\n\n\treturn mergedIntervals\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2},\n\t\t{3, 5},\n\t\t{4, 7},\n\t\t{6, 8},\n\t\t{9, 10},\n\t}\n\texpected := [][]int{\n\t\t{1, 2},\n\t\t{3, 8},\n\t\t{9, 10},\n\t}\n\tactual := MergeOverlappingIntervals(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := [][]int{\n\t\t{1, 2},\n\t\t{3, 5},\n\t\t{4, 7},\n\t\t{6, 8},\n\t\t{9, 10},\n\t}\n\texpected := [][]int{\n\t\t{1, 2},\n\t\t{3, 8},\n\t\t{9, 10},\n\t}\n\tactual := MergeOverlappingIntervals(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public int[][] mergeOverlappingIntervals(int[][] intervals) {\n    // Write your code here.\n    return new int[][] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(nlog(n)) time | O(n) space - where n is the length of the input array\n  public int[][] mergeOverlappingIntervals(int[][] intervals) {\n    // Sort the intervals by starting value.\n    int[][] sortedIntervals = intervals.clone();\n    Arrays.sort(sortedIntervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n    List<int[]> mergedIntervals = new ArrayList<int[]>();\n    int[] currentInterval = sortedIntervals[0];\n    mergedIntervals.add(currentInterval);\n\n    for (int[] nextInterval : sortedIntervals) {\n      int currentIntervalEnd = currentInterval[1];\n      int nextIntervalStart = nextInterval[0];\n      int nextIntervalEnd = nextInterval[1];\n\n      if (currentIntervalEnd >= nextIntervalStart) {\n        currentInterval[1] = Math.max(currentIntervalEnd, nextIntervalEnd);\n      } else {\n        currentInterval = nextInterval;\n        mergedIntervals.add(currentInterval);\n      }\n    }\n\n    return mergedIntervals.toArray(new int[mergedIntervals.size()][]);\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] intervals =\n        new int[][] {\n          {1, 2},\n          {3, 5},\n          {4, 7},\n          {6, 8},\n          {9, 10}\n        };\n    int[][] expected =\n        new int[][] {\n          {1, 2},\n          {3, 8},\n          {9, 10}\n        };\n    int[][] actual = new Program().mergeOverlappingIntervals(intervals);\n    for (int i = 0; i < actual.length; i++) {\n      for (int j = 0; j < actual[i].length; j++) {\n        Utils.assertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] intervals =\n        new int[][] {\n          {1, 2},\n          {3, 5},\n          {4, 7},\n          {6, 8},\n          {9, 10}\n        };\n    int[][] expected =\n        new int[][] {\n          {1, 2},\n          {3, 8},\n          {9, 10}\n        };\n    int[][] actual = new Program().mergeOverlappingIntervals(intervals);\n    for (int i = 0; i < actual.length; i++) {\n      for (int j = 0; j < actual[i].length; j++) {\n        Utils.assertTrue(expected[i][j] == actual[i][j]);\n      }\n    }\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function mergeOverlappingIntervals(array) {\n  // Write your code here.\n  return [[]];\n}\n\n// Do not edit the line below.\nexports.mergeOverlappingIntervals = mergeOverlappingIntervals;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the length of the input array\nfunction mergeOverlappingIntervals(intervals) {\n  const sortedIntervals = intervals.sort((a, b) => a[0] - b[0]);\n\n  const mergedIntervals = [];\n  let currentInterval = sortedIntervals[0];\n  mergedIntervals.push(currentInterval);\n\n  for (const nextInterval of sortedIntervals) {\n    const [_, currentIntervalEnd] = currentInterval;\n    const [nextIntervalStart, nextIntervalEnd] = nextInterval;\n\n    if (currentIntervalEnd >= nextIntervalStart) currentInterval[1] = Math.max(currentIntervalEnd, nextIntervalEnd);\n    else {\n      currentInterval = nextInterval;\n      mergedIntervals.push(currentInterval);\n    }\n  }\n\n  return mergedIntervals;\n}\n\n// Do not edit the line below.\nexports.mergeOverlappingIntervals = mergeOverlappingIntervals;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun mergeOverlappingIntervals(intervals: List<List<Int>>): List<List<Int>> {\n    // Write your code here.\n    return listOf()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(nlog(n)) time | O(n) space - where n is the length of the input array\nfun mergeOverlappingIntervals(intervals: List<List<Int>>): List<List<Int>> {\n    // Sort the intervals by starting value.\n    var sortedIntervals = intervals.toMutableList().sortedWith(Comparator<List<Int>> { a, b -> a[0].compareTo(b[0]) })\n    sortedIntervals = sortedIntervals.map() { it -> it.toMutableList() }\n\n    val mergedIntervals = mutableListOf<MutableList<Int>>()\n    var currentInterval = sortedIntervals[0]\n    mergedIntervals.add(currentInterval)\n\n    for (nextInterval in sortedIntervals) {\n        val (currentIntervalStart, currentIntervalEnd) = currentInterval\n        val (nextIntervalStart, nextIntervalEnd) = nextInterval\n\n        if (currentIntervalEnd >= nextIntervalStart) {\n            currentInterval[1] = max(currentIntervalEnd, nextIntervalEnd)\n        } else {\n            currentInterval = nextInterval\n            mergedIntervals.add(currentInterval)\n        }\n    }\n\n    return mergedIntervals\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.mergeOverlappingIntervals\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val intervals = listOf(listOf(1, 2), listOf(3, 5), listOf(4, 7), listOf(6, 8), listOf(9, 10))\n        val expected = listOf(listOf(1, 2), listOf(3, 8), listOf(9, 10))\n        val output = mergeOverlappingIntervals(intervals)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.mergeOverlappingIntervals\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val intervals = listOf(listOf(1, 2), listOf(3, 5), listOf(4, 7), listOf(6, 8), listOf(9, 10))\n        val expected = listOf(listOf(1, 2), listOf(3, 8), listOf(9, 10))\n        val output = mergeOverlappingIntervals(intervals)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def mergeOverlappingIntervals(intervals):\n    # Write your code here.\n    return [[]]\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nlog(n)) time | O(n) space - where n is the length of the input array\ndef mergeOverlappingIntervals(intervals):\n    # Sort the intervals by starting value.\n    sortedIntervals = sorted(intervals, key=lambda x: x[0])\n\n    mergedIntervals = []\n    currentInterval = sortedIntervals[0]\n    mergedIntervals.append(currentInterval)\n\n    for nextInterval in sortedIntervals:\n        _, currentIntervalEnd = currentInterval\n        nextIntervalStart, nextIntervalEnd = nextInterval\n\n        if currentIntervalEnd >= nextIntervalStart:\n            currentInterval[1] = max(currentIntervalEnd, nextIntervalEnd)\n        else:\n            currentInterval = nextInterval\n            mergedIntervals.append(currentInterval)\n\n    return mergedIntervals\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        intervals = [[1, 2], [3, 5], [4, 7], [6, 8], [9, 10]]\n        expected = [[1, 2], [3, 8], [9, 10]]\n        actual = program.mergeOverlappingIntervals(intervals)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        intervals = [[1, 2], [3, 5], [4, 7], [6, 8], [9, 10]]\n        expected = [[1, 2], [3, 8], [9, 10]]\n        actual = program.mergeOverlappingIntervals(intervals)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def mergeOverlappingIntervals(intervals)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def mergeOverlappingIntervals(intervals)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeOverlappingIntervals\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.mergeOverlappingIntervals\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func mergeOverlappingIntervals(_ intervals: [[Int]]) -> [[Int]] {\n    // Write your code here.\n    return [[Int]]()\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlog(n)) time | O(n) space - where n is the length of the input array\n  func mergeOverlappingIntervals(_ intervals: [[Int]]) -> [[Int]] {\n    let sortedIntervals = intervals.sorted(by: { $0[0] < $1[0] })\n\n    var mergedIntervals = [[Int]]()\n    var currentInterval = sortedIntervals[0]\n    mergedIntervals.append(currentInterval)\n\n    for nextInterval in sortedIntervals {\n      let currentIntervalEnd = currentInterval[1]\n      let (nextIntervalStart, nextIntervalEnd) = (nextInterval[0], nextInterval[1])\n\n      if currentIntervalEnd >= nextIntervalStart {\n        currentInterval[1] = max(currentIntervalEnd, nextIntervalEnd)\n        mergedIntervals[mergedIntervals.count - 1][1] = currentInterval[1]\n      } else {\n        currentInterval = nextInterval\n        mergedIntervals.append(currentInterval)\n      }\n    }\n\n    return mergedIntervals\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [\n        [1, 2],\n        [3, 5],\n        [4, 7],\n        [6, 8],\n        [9, 10],\n      ]\n      var expected = [\n        [1, 2],\n        [3, 8],\n        [9, 10],\n      ]\n      var actual = Program().mergeOverlappingIntervals(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [\n        [1, 2],\n        [3, 5],\n        [4, 7],\n        [6, 8],\n        [9, 10],\n      ]\n      var expected = [\n        [1, 2],\n        [3, 8],\n        [9, 10],\n      ]\n      var actual = Program().mergeOverlappingIntervals(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function mergeOverlappingIntervals(array: number[][]) {\n  // Write your code here.\n  return array;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlog(n)) time | O(n) space - where n is the length of the input array\nexport function mergeOverlappingIntervals(intervals: number[][]) {\n  const sortedIntervals = intervals.sort((a, b) => a[0] - b[0]);\n\n  const mergedIntervals: number[][] = [];\n  let currentInterval = sortedIntervals[0];\n  mergedIntervals.push(currentInterval);\n\n  for (const nextInterval of sortedIntervals) {\n    const [_, currentIntervalEnd] = currentInterval;\n    const [nextIntervalStart, nextIntervalEnd] = nextInterval;\n\n    if (currentIntervalEnd >= nextIntervalStart) currentInterval[1] = Math.max(currentIntervalEnd, nextIntervalEnd);\n    else {\n      currentInterval = nextInterval;\n      mergedIntervals.push(currentInterval);\n    }\n  }\n\n  return mergedIntervals;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "intervals",
          example: [
            [1, 2],
            [3, 5],
            [4, 7],
            [6, 8],
            [9, 10],
          ],
          schema: {
            items: {
              items: {
                type: "integer",
              },
              maxItems: 2,
              minItems: 2,
              type: "array",
            },
            minItems: 1,
            type: "array",
          },
        },
      ],
      tests: [
        {
          intervals: [
            [1, 2],
            [3, 5],
            [4, 7],
            [6, 8],
            [9, 10],
          ],
        },
        {
          intervals: [
            [1, 3],
            [2, 8],
            [9, 10],
          ],
        },
        {
          intervals: [
            [1, 10],
            [10, 20],
            [20, 30],
            [30, 40],
            [40, 50],
            [50, 60],
            [60, 70],
            [70, 80],
            [80, 90],
            [90, 100],
          ],
        },
        {
          intervals: [
            [1, 10],
            [11, 20],
            [21, 30],
            [31, 40],
            [41, 50],
            [51, 60],
            [61, 70],
            [71, 80],
            [81, 90],
            [91, 100],
          ],
        },
        {
          intervals: [
            [100, 105],
            [1, 104],
          ],
        },
        {
          intervals: [
            [89, 90],
            [-10, 20],
            [-50, 0],
            [70, 90],
            [90, 91],
            [90, 95],
          ],
        },
        {
          intervals: [
            [-5, -4],
            [-4, -3],
            [-3, -2],
            [-2, -1],
            [-1, 0],
          ],
        },
        {
          intervals: [
            [43, 49],
            [9, 12],
            [12, 54],
            [45, 90],
            [91, 93],
          ],
        },
        {
          intervals: [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
          ],
        },
        {
          intervals: [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 1],
          ],
        },
        {
          intervals: [
            [1, 22],
            [-20, 30],
          ],
        },
        {
          intervals: [
            [20, 21],
            [22, 23],
            [0, 1],
            [3, 4],
            [23, 24],
            [25, 27],
            [5, 6],
            [7, 19],
          ],
        },
        {
          intervals: [
            [2, 3],
            [4, 5],
            [6, 7],
            [8, 9],
            [1, 10],
          ],
        },
      ],
      jsonTests: [
        {
          intervals: [
            [1, 2],
            [3, 5],
            [4, 7],
            [6, 8],
            [9, 10],
          ],
        },
        {
          intervals: [
            [1, 3],
            [2, 8],
            [9, 10],
          ],
        },
        {
          intervals: [
            [1, 10],
            [10, 20],
            [20, 30],
            [30, 40],
            [40, 50],
            [50, 60],
            [60, 70],
            [70, 80],
            [80, 90],
            [90, 100],
          ],
        },
        {
          intervals: [
            [1, 10],
            [11, 20],
            [21, 30],
            [31, 40],
            [41, 50],
            [51, 60],
            [61, 70],
            [71, 80],
            [81, 90],
            [91, 100],
          ],
        },
        {
          intervals: [
            [100, 105],
            [1, 104],
          ],
        },
        {
          intervals: [
            [89, 90],
            [-10, 20],
            [-50, 0],
            [70, 90],
            [90, 91],
            [90, 95],
          ],
        },
        {
          intervals: [
            [-5, -4],
            [-4, -3],
            [-3, -2],
            [-2, -1],
            [-1, 0],
          ],
        },
        {
          intervals: [
            [43, 49],
            [9, 12],
            [12, 54],
            [45, 90],
            [91, 93],
          ],
        },
        {
          intervals: [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
          ],
        },
        {
          intervals: [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 1],
          ],
        },
        {
          intervals: [
            [1, 22],
            [-20, 30],
          ],
        },
        {
          intervals: [
            [20, 21],
            [22, 23],
            [0, 1],
            [3, 4],
            [23, 24],
            [25, 27],
            [5, 6],
            [7, 19],
          ],
        },
        {
          intervals: [
            [2, 3],
            [4, 5],
            [6, 7],
            [8, 9],
            [1, 10],
          ],
        },
      ],
      changelog: [],
      id: 18,
    },
    {
      uid: "search-in-sorted-matrix",
      testStrategy: "JSON",
      name: "Search In Sorted Matrix",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Searching",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 18081,
        failureCount: 5940,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "241818616",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 942,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of distinct integers and a\n  target integer. Each row in the matrix is sorted, and each column is also sorted; the\n  matrix doesn\'t necessarily have the same height and width.\n</p>\n<p>\n  Write a function that returns an array of the row and column indices of the\n  target integer if it\'s contained in the matrix, otherwise\n  <span>[-1, -1]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 4, 7, 12, 15, 1000],\n  [2, 5, 19, 31, 32, 1001],\n  [3, 8, 24, 33, 35, 1002],\n  [40, 41, 42, 44, 45, 1003],\n  [99, 100, 103, 106, 128, 1004],\n]\n<span class="CodeEditor-promptParameter">target</span> = 44\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[3, 3]\n</pre>\n</div>',
      hints: [
        "<p>\nPick any number in the matrix and compare it to the target number. If this number is bigger than the target number, what does that tell you about all of the other numbers in this number's row and this number's column? What about if this number is smaller than the target number?\n</p>\n",
        "\n<p>\nTry starting at the top right corner of the matrix, comparing the number there to the target number, and using whatever you gathered from Hint #1 to figure out what number to compare next if the top right number isn't equal to the target number. Continue until you find the target number or until you get past the extremities of the matrix.\n</p>",
      ],
      spaceTime:
        "O(n + m) time | O(1) space - where n is the length of the matrix's rows and m is the length of the matrix's columns",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> searchInSortedMatrix(vector<vector<int>> matrix, int target) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(n + m) time | O(1) space\nvector<int> searchInSortedMatrix(vector<vector<int>> matrix, int target) {\n  int row = 0;\n  int col = matrix[0].size() - 1;\n  while (row < matrix.size() && col >= 0) {\n    if (matrix[row][col] > target) {\n      col--;\n    } else if (matrix[row][col] < target) {\n      row++;\n    } else {\n      return {row, col};\n    }\n  }\n  return {-1, -1};\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> matrix{\n          {1, 4, 7, 12, 15, 1000},        {2, 5, 19, 31, 32, 1001},\n          {3, 8, 24, 33, 35, 1002},       {40, 41, 42, 44, 45, 1003},\n          {99, 100, 103, 106, 128, 1004},\n      };\n      vector<int> expected{3, 3};\n      assert(searchInSortedMatrix(matrix, 44) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> matrix{\n          {1, 4, 7, 12, 15, 1000},        {2, 5, 19, 31, 32, 1001},\n          {3, 8, 24, 33, 35, 1002},       {40, 41, 42, 44, 45, 1003},\n          {99, 100, 103, 106, 128, 1004},\n      };\n      vector<int> expected{3, 3};\n      assert(searchInSortedMatrix(matrix, 44) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] SearchInSortedMatrix(int[,] matrix, int target) {\n\t\t// Write your code here.\n\t\treturn new int[] {-1, -1};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(n + m) time | O(1) space\n\tpublic static int[] SearchInSortedMatrix(int[,] matrix, int target) {\n\t\tint row = 0;\n\t\tint col = matrix.GetLength(1) - 1;\n\t\twhile (row < matrix.GetLength(0) && col >= 0) {\n\t\t\tif (matrix[row,col] > target) {\n\t\t\t\tcol--;\n\t\t\t} else if (matrix[row,col] < target) {\n\t\t\t\trow++;\n\t\t\t} else {\n\t\t\t\treturn new int[] {row, col};\n\t\t\t}\n\t\t}\n\t\treturn new int[] {-1, -1};\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[,] matrix = {\n\t\t\t{1, 4, 7, 12, 15, 1000},\n\t\t\t{2, 5, 19, 31, 32, 1001},\n\t\t\t{3, 8, 24, 33, 35, 1002},\n\t\t\t{40, 41, 42, 44, 45, 1003},\n\t\t\t{99, 100, 103, 106, 128, 1004},\n\t\t};\n\t\tint[] expected = {3, 3};\n\t\tint[] output = Program.SearchInSortedMatrix(matrix, 44);\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[,] matrix = {\n\t\t\t{1, 4, 7, 12, 15, 1000},\n\t\t\t{2, 5, 19, 31, 32, 1001},\n\t\t\t{3, 8, 24, 33, 35, 1002},\n\t\t\t{40, 41, 42, 44, 45, 1003},\n\t\t\t{99, 100, 103, 106, 128, 1004},\n\t\t};\n\t\tint[] expected = {3, 3};\n\t\tint[] output = Program.SearchInSortedMatrix(matrix, 44);\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\tpublic bool compare(int[] arr1, int[] arr2) {\n\t\tif (arr1.Length != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Length; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc SearchInSortedMatrix(matrix [][]int, target int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n + m) time | O(1) space\nfunc SearchInSortedMatrix(matrix [][]int, target int) []int {\n\trow, col := 0, len(matrix[0])-1\n\tfor row < len(matrix) && col >= 0 {\n\t\tif matrix[row][col] > target {\n\t\t\tcol -= 1\n\t\t} else if matrix[row][col] < target {\n\t\t\trow += 1\n\t\t} else {\n\t\t\treturn []int{row, col}\n\t\t}\n\t}\n\treturn []int{-1, -1}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar matrix = [][]int{\n\t\t{1, 4, 7, 12, 15, 1000},\n\t\t{2, 5, 19, 31, 32, 1001},\n\t\t{3, 8, 24, 33, 35, 1002},\n\t\t{40, 41, 42, 44, 45, 1003},\n\t\t{99, 100, 103, 106, 128, 1004},\n\t}\n\texpected := []int{3, 3}\n\toutput := SearchInSortedMatrix(matrix, 44)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tvar matrix = [][]int{\n\t\t{1, 4, 7, 12, 15, 1000},\n\t\t{2, 5, 19, 31, 32, 1001},\n\t\t{3, 8, 24, 33, 35, 1002},\n\t\t{40, 41, 42, 44, 45, 1003},\n\t\t{99, 100, 103, 106, 128, 1004},\n\t}\n\texpected := []int{3, 3}\n\toutput := SearchInSortedMatrix(matrix, 44)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] searchInSortedMatrix(int[][] matrix, int target) {\n    // Write your code here.\n    return new int[] {-1, -1};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n + m) time | O(1) space\n  public static int[] searchInSortedMatrix(int[][] matrix, int target) {\n    int row = 0;\n    int col = matrix[0].length - 1;\n    while (row < matrix.length && col >= 0) {\n      if (matrix[row][col] > target) {\n        col--;\n      } else if (matrix[row][col] < target) {\n        row++;\n      } else {\n        return new int[] {row, col};\n      }\n    }\n    return new int[] {-1, -1};\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] matrix = {\n      {1, 4, 7, 12, 15, 1000},\n      {2, 5, 19, 31, 32, 1001},\n      {3, 8, 24, 33, 35, 1002},\n      {40, 41, 42, 44, 45, 1003},\n      {99, 100, 103, 106, 128, 1004},\n    };\n    int[] expected = {3, 3};\n    int[] output = Program.searchInSortedMatrix(matrix, 44);\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] matrix = {\n      {1, 4, 7, 12, 15, 1000},\n      {2, 5, 19, 31, 32, 1001},\n      {3, 8, 24, 33, 35, 1002},\n      {40, 41, 42, 44, 45, 1003},\n      {99, 100, 103, 106, 128, 1004},\n    };\n    int[] expected = {3, 3};\n    int[] output = Program.searchInSortedMatrix(matrix, 44);\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(int[] arr1, int[] arr2) {\n    if (arr1.length != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.length; i++) {\n      if (arr1[i] != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function searchInSortedMatrix(matrix, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.searchInSortedMatrix = searchInSortedMatrix;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n + m) time | O(1) space\nfunction searchInSortedMatrix(matrix, target) {\n  let row = 0;\n  let col = matrix[0].length - 1;\n  while (row < matrix.length && col >= 0) {\n    if (matrix[row][col] > target) {\n      col--;\n    } else if (matrix[row][col] < target) {\n      row++;\n    } else {\n      return [row, col];\n    }\n  }\n  return [-1, -1];\n}\n\nexports.searchInSortedMatrix = searchInSortedMatrix;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun searchInSortedMatrix(matrix: List<List<Int>>, target: Int): Pair<Int, Int> {\n    // Write your code here.\n    return Pair(-1, -1)\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n + m) time | O(1) space\nfun searchInSortedMatrix(matrix: List<List<Int>>, target: Int): Pair<Int, Int> {\n    var row = 0\n    var col = matrix[0].size - 1\n    while (row < matrix.size && col >= 0) {\n        if (matrix[row][col] > target) {\n            col--\n        } else if (matrix[row][col] < target) {\n            row++\n        } else {\n            return Pair(row, col)\n        }\n    }\n    return Pair(-1, -1)\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.searchInSortedMatrix\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val matrix = listOf(\n            listOf(1, 4, 7, 12, 15, 1000),\n            listOf(2, 5, 19, 31, 32, 1001),\n            listOf(3, 8, 24, 33, 35, 1002),\n            listOf(40, 41, 42, 44, 45, 1003),\n            listOf(99, 100, 103, 106, 128, 1004)\n        )\n        val expected = Pair(3, 3)\n        val output = searchInSortedMatrix(matrix, 44)\n        assert(expected.equals(output))\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.searchInSortedMatrix\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val matrix = listOf(\n            listOf(1, 4, 7, 12, 15, 1000),\n            listOf(2, 5, 19, 31, 32, 1001),\n            listOf(3, 8, 24, 33, 35, 1002),\n            listOf(40, 41, 42, 44, 45, 1003),\n            listOf(99, 100, 103, 106, 128, 1004)\n        )\n        val expected = Pair(3, 3)\n        val output = searchInSortedMatrix(matrix, 44)\n        assert(expected.equals(output))\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def searchInSortedMatrix(matrix, target):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n + m) time | O(1) space\ndef searchInSortedMatrix(matrix, target):\n    row = 0\n    col = len(matrix[0]) - 1\n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] > target:\n            col -= 1\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            return [row, col]\n    return [-1, -1]\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        matrix = [\n            [1, 4, 7, 12, 15, 1000],\n            [2, 5, 19, 31, 32, 1001],\n            [3, 8, 24, 33, 35, 1002],\n            [40, 41, 42, 44, 45, 1003],\n            [99, 100, 103, 106, 128, 1004],\n        ]\n        actual = program.searchInSortedMatrix(matrix, 44)\n        self.assertEqual(actual, [3, 3])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        matrix = [\n            [1, 4, 7, 12, 15, 1000],\n            [2, 5, 19, 31, 32, 1001],\n            [3, 8, 24, 33, 35, 1002],\n            [40, 41, 42, 44, 45, 1003],\n            [99, 100, 103, 106, 128, 1004],\n        ]\n        actual = program.searchInSortedMatrix(matrix, 44)\n        self.assertEqual(actual, [3, 3])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def searchInSortedMatrix(matrix, target)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def searchInSortedMatrix(matrix, target)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.searchInSortedMatrix\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.searchInSortedMatrix\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func searchInSortedMatrix(matrix: [[Int]], target: Int) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n + m) time | O(1) space\n  func searchInSortedMatrix(matrix: [[Int]], target: Int) -> [Int] {\n    var row = 0\n    var column = matrix[0].count - 1\n\n    while row < matrix.count, column >= 0 {\n      if matrix[row][column] > target {\n        column = column - 1\n      } else if matrix[row][column] < target {\n        row = row + 1\n      } else {\n        return [row, column]\n      }\n    }\n\n    return [-1, -1]\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var matrix =\n        [\n          [1, 4, 7, 12, 15, 1000],\n          [2, 5, 19, 31, 32, 1001],\n          [3, 8, 24, 33, 35, 1002],\n          [40, 41, 42, 44, 45, 1003],\n          [99, 100, 103, 106, 128, 1004],\n        ]\n      try assertEqual([3, 3], program.searchInSortedMatrix(matrix: matrix, target: 44))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      var matrix =\n        [\n          [1, 4, 7, 12, 15, 1000],\n          [2, 5, 19, 31, 32, 1001],\n          [3, 8, 24, 33, 35, 1002],\n          [40, 41, 42, 44, 45, 1003],\n          [99, 100, 103, 106, 128, 1004],\n        ]\n      try assertEqual([3, 3], program.searchInSortedMatrix(matrix: matrix, target: 44))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "type Range = [number, number];\n\nexport function searchInSortedMatrix(matrix: number[][], target: number): Range {\n  // Write your code here.\n  return [-1, -1];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ntype Range = [number, number];\n\n// O(n + m) time | O(1) space\nexport function searchInSortedMatrix(matrix: number[][], target: number): Range {\n  let row = 0;\n  let col = matrix[0].length - 1;\n  while (row < matrix.length && col >= 0) {\n    if (matrix[row][col] > target) {\n      col--;\n    } else if (matrix[row][col] < target) {\n      row++;\n    } else {\n      return [row, col];\n    }\n  }\n  return [-1, -1];\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "matrix",
          example: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          schema: {
            items: {
              items: {
                type: "integer",
                uniqueItems: true,
              },
              type: "array",
            },
            type: "array",
          },
        },
        {
          name: "target",
          example: 44,
          schema: {
            type: "integer",
          },
        },
      ],
      tests: [
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 44,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 2,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 4,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 15,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 12,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 32,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 99,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 100,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 40,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 128,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 106,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 45,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 24,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 43,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: -1,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1000,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1004,
        },
      ],
      jsonTests: [
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 44,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 2,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 4,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 15,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 12,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 32,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 99,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 100,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 40,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 128,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 106,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 45,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 24,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 43,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: -1,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1000,
        },
        {
          matrix: [
            [1, 4, 7, 12, 15, 1000],
            [2, 5, 19, 31, 32, 1001],
            [3, 8, 24, 33, 35, 1002],
            [40, 41, 42, 44, 45, 1003],
            [99, 100, 103, 106, 128, 1004],
          ],
          target: 1004,
        },
      ],
      changelog: [],
      id: 19,
    },
    {
      uid: "min-number-of-jumps",
      testStrategy: "JSON",
      name: "Min Number Of Jumps",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Dynamic Programming",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 12872,
        failureCount: 4541,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "224221528",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1556,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re given a non-empty array of positive integers where each integer represents the\n  maximum number of steps you can take forward in the array. For example, if the\n  element at index <span>1</span> is <span>3</span>, you can go from index\n  <span>1</span> to index <span>2</span>, <span>3</span>, or <span>4</span>.\n</p>\n<p>\n  Write a function that returns the minimum number of jumps needed to reach the\n  final index.\n</p>\n<p>\n  Note that jumping from index <span>i</span> to index <span>i + x</span> always\n  constitutes one jump, no matter how large <span>x</span> is.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class="CodeEditor-promptComment">// 3 --> (4 or 2) --> (2 or 3) --> 7 --> 3</span>\n</pre>\n</div>',
      hints: [
        "<p>\nTry building an array of the minimum number of jumps needed to go from index 0 to all indices. Start at index 0 and progressively build up the array, using previously calculated values to find next ones.\n</p>\n",
        '\n<p>\nBuilding the array mentioned in Hint #1 should be feasible using two for loops. In an effort to optimize your algorithm, realize that at any point in the array you know the farthest index that you can reach as well as the number of steps that you have left until you must "consume" a jump.\n</p>\n',
        "\n<p>\nAfter initializing your maximum reach as well as your current number of steps to the value stored at index 0, you can easily update your maximum reach as you traverse the input array by simply comparing it to the value stored at each index. You can also remove one step from your current number of steps at each index, since moving from one index to the next uses up one step. When your steps reach zero, find a way to calculate how many steps you actually have left using the maximum reach and the index that you're at.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint minNumberOfJumps(vector<int> array) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// O(n^2) time | O(n) space\nint minNumberOfJumps(vector<int> array) {\n  vector<int> jumps(array.size(), INT_MAX);\n  jumps[0] = 0;\n  for (int i = 1; i < array.size(); i++) {\n    for (int j = 0; j < i; j++) {\n      if (array[j] >= i - j) {\n        jumps[i] = min(jumps[j] + 1, jumps[i]);\n      }\n    }\n  }\n  return jumps[jumps.size() - 1];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(n) time | O(1) space\nint minNumberOfJumps(vector<int> array) {\n  if (array.size() == 1) {\n    return 0;\n  }\n  int jumps = 0;\n  int maxReach = array[0];\n  int steps = array[0];\n  for (int i = 1; i < array.size() - 1; i++) {\n    maxReach = max(maxReach, i + array[i]);\n    steps--;\n    if (steps == 0) {\n      jumps++;\n      steps = maxReach - i;\n    }\n  }\n  return jumps + 1;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input{3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n      assert(minNumberOfJumps(input) == 4);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input{3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n      assert(minNumberOfJumps(input) == 4);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int MinNumberOfJumps(int[] array) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n^2) time | O(n) space\n\tpublic static int MinNumberOfJumps(int[] array) {\n\t\tint[] jumps = new int[array.Length];\n\t\tArray.Fill(jumps, Int32.MaxValue);\n\t\tjumps[0] = 0;\n\t\tfor (int i = 1; i < array.Length; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (array[j] >= i -j) {\n\t\t\t\t\tjumps[i] = Math.Min(jumps[j] + 1, jumps[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn jumps[jumps.Length - 1];\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n) time | O(1) space\n\tpublic static int MinNumberOfJumps(int[] array) {\n\t\tif (array.Length == 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tint jumps = 0;\n\t\tint maxReach = array[0];\n\t\tint steps = array[0];\n\t\tfor (int i = 1; i < array.Length - 1; i++) {\n\t\t\tmaxReach = Math.Max(maxReach, i + array[i]);\n\t\t\tsteps--;\n\t\t\tif (steps == 0) {\n\t\t\t\tjumps++;\n\t\t\t\tsteps = maxReach - i;\n\t\t\t}\n\t\t}\n\t\treturn jumps + 1;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = {3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n\t\tUtils.AssertTrue(Program.MinNumberOfJumps(input) == 4);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = {3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n\t\tUtils.AssertTrue(Program.MinNumberOfJumps(input) == 4);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc MinNumberOfJumps(array []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space\nfunc MinNumberOfJumps(array []int) int {\n\tjumps := make([]int, len(array))\n\tfor i := range jumps {\n\t\tjumps[i] = -1\n\t}\n\tjumps[0] = 0\n\tfor i := 1; i < len(array); i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif array[j] >= i-j && (jumps[i] == -1 || jumps[j]+1 < jumps[i]) {\n\t\t\t\tjumps[i] = jumps[j] + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn jumps[len(array)-1]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space\nfunc MinNumberOfJumps(array []int) int {\n\tif len(array) == 1 {\n\t\treturn 0\n\t}\n\tjumps := 0\n\tmaxReach := array[0]\n\tsteps := array[0]\n\tfor i := 1; i < len(array)-1; i++ {\n\t\tif i+array[i] > maxReach {\n\t\t\tmaxReach = i + array[i]\n\t\t}\n\t\tsteps -= 1\n\t\tif steps == 0 {\n\t\t\tjumps += 1\n\t\t\tsteps = maxReach - i\n\t\t}\n\t}\n\treturn jumps + 1\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 4\n\toutput := MinNumberOfJumps([]int{3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 4\n\toutput := MinNumberOfJumps([]int{3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int minNumberOfJumps(int[] array) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.Arrays;\n\nclass Program {\n  // O(n^2) time | O(n) space\n  public static int minNumberOfJumps(int[] array) {\n    int[] jumps = new int[array.length];\n    Arrays.fill(jumps, Integer.MAX_VALUE);\n    jumps[0] = 0;\n    for (int i = 1; i < array.length; i++) {\n      for (int j = 0; j < i; j++) {\n        if (array[j] >= i - j) {\n          jumps[i] = Math.min(jumps[j] + 1, jumps[i]);\n        }\n      }\n    }\n    return jumps[jumps.length - 1];\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  public static int minNumberOfJumps(int[] array) {\n    if (array.length == 1) {\n      return 0;\n    }\n    int jumps = 0;\n    int maxReach = array[0];\n    int steps = array[0];\n    for (int i = 1; i < array.length - 1; i++) {\n      maxReach = Math.max(maxReach, i + array[i]);\n      steps--;\n      if (steps == 0) {\n        jumps++;\n        steps = maxReach - i;\n      }\n    }\n    return jumps + 1;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = {3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n    Utils.assertTrue(Program.minNumberOfJumps(input) == 4);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = {3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3};\n    Utils.assertTrue(Program.minNumberOfJumps(input) == 4);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function minNumberOfJumps(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.minNumberOfJumps = minNumberOfJumps;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nfunction minNumberOfJumps(array) {\n  const jumps = new Array(array.length).fill(Infinity);\n  jumps[0] = 0;\n  for (let i = 1; i < array.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (array[j] >= i - j) {\n        jumps[i] = Math.min(jumps[j] + 1, jumps[i]);\n      }\n    }\n  }\n  return jumps[jumps.length - 1];\n}\n\nexports.minNumberOfJumps = minNumberOfJumps;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nfunction minNumberOfJumps(array) {\n  if (array.length === 1) return 0;\n  let jumps = 0;\n  let maxReach = array[0];\n  let steps = array[0];\n  for (let i = 1; i < array.length - 1; i++) {\n    maxReach = Math.max(maxReach, i + array[i]);\n    steps--;\n    if (steps === 0) {\n      jumps++;\n      steps = maxReach - i;\n    }\n  }\n  return jumps + 1;\n}\n\nexports.minNumberOfJumps = minNumberOfJumps;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun minNumberOfJumps(array: List<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.min\n\nfun minNumberOfJumps(array: List<Int>): Int {\n    val jumps = MutableList(array.size) { Int.MAX_VALUE }\n    jumps[0] = 0\n    for (i in 1 until array.size) {\n        for (j in 0 until i) {\n            if (array[j] >= i - j) {\n                jumps[i] = min(jumps[j] + 1, jumps[i])\n            }\n        }\n    }\n    return jumps[jumps.size - 1]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\nfun minNumberOfJumps(array: List<Int>): Int {\n    if (array.size == 1) {\n        return 0\n    }\n    var jumps = 0\n    var maxReach = array[0]\n    var steps = array[0]\n    for (i in 1 until array.size - 1) {\n        maxReach = max(maxReach, i + array[i])\n        steps--\n        if (steps == 0) {\n            jumps++\n            steps = maxReach - i\n        }\n    }\n    return jumps + 1\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.minNumberOfJumps\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3)\n        val output = minNumberOfJumps(input)\n        val expected = 4\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.minNumberOfJumps\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3)\n        val output = minNumberOfJumps(input)\n        val expected = 4\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def minNumberOfJumps(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space\ndef minNumberOfJumps(array):\n    jumps = [float("inf") for x in array]\n    jumps[0] = 0\n    for i in range(1, len(array)):\n        for j in range(0, i):\n            if array[j] >= i - j:\n                jumps[i] = min(jumps[j] + 1, jumps[i])\n    return jumps[-1]\n',
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space\ndef minNumberOfJumps(array):\n    if len(array) == 1:\n        return 0\n    jumps = 0\n    maxReach = array[0]\n    steps = array[0]\n    for i in range(1, len(array) - 1):\n        maxReach = max(maxReach, i + array[i])\n        steps -= 1\n        if steps == 0:\n            jumps += 1\n            steps = maxReach - i\n    return jumps + 1\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3]), 4)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3]), 4)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def minNumberOfJumps(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minNumberOfJumps(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minNumberOfJumps(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minNumberOfJumps\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minNumberOfJumps\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func minNumberOfJumps(array: [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space\n  func minNumberOfJumps(array: [Int]) -> Int {\n    var jumps = Array(repeating: Int.max, count: array.count)\n\n    jumps[0] = 0\n\n    for i in 0 ..< array.count {\n      for j in 0 ..< i {\n        if array[j] + j >= i {\n          jumps[i] = min(jumps[i], jumps[j] + 1)\n        }\n      }\n    }\n\n    return jumps[jumps.count - 1]\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  func minNumberOfJumps(array: [Int]) -> Int {\n    if array.count == 1 {\n      return 0\n    }\n\n    var jumps = 0\n    var steps = array[0]\n    var maximumReach = array[0]\n\n    for i in 1 ..< array.count - 1 {\n      maximumReach = max(maximumReach, array[i] + i)\n\n      steps -= 1\n\n      if steps == 0 {\n        jumps += 1\n\n        steps = maximumReach - i\n      }\n    }\n\n    return jumps + 1\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 9") { () throws -> Void in\n      let output = program.minNumberOfJumps(array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])\n      try assertEqual(4, output)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 9") { () throws -> Void in\n      let output = program.minNumberOfJumps(array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])\n      try assertEqual(4, output)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function minNumberOfJumps(array: number[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nexport function minNumberOfJumps(array: number[]) {\n  const jumps: number[] = new Array(array.length).fill(Infinity);\n  jumps[0] = 0;\n  for (let i = 1; i < array.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (array[j] >= i - j) {\n        jumps[i] = Math.min(jumps[j] + 1, jumps[i]);\n      }\n    }\n  }\n  return jumps[jumps.length - 1];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nexport function minNumberOfJumps(array: number[]) {\n  if (array.length === 1) return 0;\n  let jumps = 0;\n  let maxReach = array[0];\n  let steps = array[0];\n  for (let i = 1; i < array.length - 1; i++) {\n    maxReach = Math.max(maxReach, i + array[i]);\n    steps--;\n    if (steps === 0) {\n      jumps++;\n      steps = maxReach - i;\n    }\n  }\n  return jumps + 1;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3],
          schema: {
            items: {
              minimum: 1,
              type: "integer",
            },
            minItems: 1,
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 1],
        },
        {
          array: [3, 1],
        },
        {
          array: [1, 1, 1],
        },
        {
          array: [2, 1, 1],
        },
        {
          array: [2, 1, 2, 3, 1],
        },
        {
          array: [2, 1, 2, 3, 1, 1, 1],
        },
        {
          array: [2, 1, 2, 2, 1, 1, 1],
        },
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 6, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 10, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 12, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 12, 2, 1, 2, 3, 15, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
      ],
      jsonTests: [
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3],
        },
        {
          array: [1],
        },
        {
          array: [1, 1],
        },
        {
          array: [3, 1],
        },
        {
          array: [1, 1, 1],
        },
        {
          array: [2, 1, 1],
        },
        {
          array: [2, 1, 2, 3, 1],
        },
        {
          array: [2, 1, 2, 3, 1, 1, 1],
        },
        {
          array: [2, 1, 2, 2, 1, 1, 1],
        },
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 6, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 10, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 12, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
        {
          array: [3, 12, 2, 1, 2, 3, 15, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1],
        },
      ],
      changelog: [],
      id: 20,
    },
    {
      uid: "first-duplicate-value",
      testStrategy: "JSON",
      name: "First Duplicate Value",
      version: 0,
      releaseDate: "2020-12-23T00:00:00Z",
      category: "Arrays",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 30057,
        failureCount: 12380,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "561923850",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1427,
      },
      prompt:
        '<div class="html">\n<p>\n  Given an array of integers between <span>1</span> and <span>n</span>,\n  inclusive, where <span>n</span> is the length of the array, write a function\n  that returns the first integer that appears more than once (when the array is\n  read from left to right).\n</p>\n<p>\n  In other words, out of all the integers that might occur more than once in the\n  input array, your function should return the one whose first duplicate value\n  has the minimum index.\n</p>\n<p>\n  If no integer appears more than once, your function should return\n  <span>-1</span>.\n</p>\n<p>Note that you\'re allowed to mutate the input array.</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 1, 5, 2, 3, 3, 4]\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// 2 is the first integer that appears more than once.</span>\n<span class="CodeEditor-promptComment">// 3 also appears more than once, but the second 3 appears after the second 2.</span>\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 1, 5, 3, 3, 2, 4]\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// 3 is the first integer that appears more than once.</span>\n<span class="CodeEditor-promptComment">// 2 also appears more than once, but the second 2 appears after the second 3.</span>\n</pre>\n</div>',
      hints: [
        "<p>\nThe brute-force solution can be done in O(n^2) time. Think about how you can determine if a value appears twice in an array.\n</p>\n",
        "\n<p>\nYou can use a data structure that has constant-time lookups to keep track of integers that you've seen already. This leads the way to a linear-time solution.\n</p>\n",
        "\n<p>\nYou should always pay close attention to the details of a question's prompt. In this question, the integers in the array are between 1 and n, inclusive, where n is the length of the input array. The prompt also explicitly allows us to mutate the array. How can these details help us find a better solution, either time-complexity-wise or space-complexity-wise? \n</p>\n",
        "\n<p>\nSince the integers are between 1 and the length of the input array, you can map them to indices in the array itself by subtracting 1 from them. Once you've mapped an integer to an index in the array, you can mutate the value in the array at that index and make it negative (by multiplying it by -1). Since the integers normally aren't negative, the first time that you encounter a negative value at the index that an integer maps to, you'll know that you'll have already seen that integer.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input array",
      notes:
        '<div class="html">\n<p>\n  At 9:43 in the video, the math that describes the number of operations\n  performed in Solution #1 has a typo. It should <b>not</b> involve\n  multiplication; instead, the total number of operations is approximated by the\n  following sum:\n</p>\n<pre>\nn + (n - 1) + (n - 2) + ... + 1\n</pre>\n<p>\n  In the first iteration, we visit <span>n</span> elements; in the second\n  iteration, we visit <span>n - 1</span> elements; in the third iteration, we\n  visit <span>n - 2</span> elements; etc..\n</p>\n<p>\n  This sum is equal to <span>n(n + 1) / 2</span>, which leads to an algorithm\n  that runs in <span>O(n^2)</span> time.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint firstDuplicateValue(vector<int> array) { return -1; }\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// O(n^2) time | O(1) space - where n is the length of the input array\nint firstDuplicateValue(vector<int> array) {\n  int minimumSecondIndex = array.size();\n  for (int i = 0; i < array.size(); i++) {\n    int value = array[i];\n    for (int j = i + 1; j < array.size(); j++) {\n      int valueToCompare = array[j];\n      if (value == valueToCompare) {\n        minimumSecondIndex = min(minimumSecondIndex, j);\n      }\n    }\n  }\n  if (minimumSecondIndex == array.size()) {\n    return -1;\n  }\n\n  return array[minimumSecondIndex];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the length of the input array\nint firstDuplicateValue(vector<int> array) {\n  unordered_map<int, bool> seen;\n  for (int value : array) {\n    if (seen.find(value) != seen.end()) {\n      return value;\n    }\n    seen[value] = true;\n  }\n  return -1;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// O(n) time | O(1) space - where n is the length of the input array\nint firstDuplicateValue(vector<int> array) {\n  for (int value : array) {\n    int absValue = abs(value);\n    if (array[absValue - 1] < 0) {\n      return absValue;\n    }\n    array[absValue - 1] *= -1;\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {2, 1, 5, 2, 3, 3, 4};\n      int expected = 2;\n      int actual = firstDuplicateValue(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {2, 1, 5, 2, 3, 3, 4};\n      int expected = 2;\n      int actual = firstDuplicateValue(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\tpublic int FirstDuplicateValue(int[] array) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(n^2) time | O(1) space - where n is the length of the input array\n\tpublic int FirstDuplicateValue(int[] array) {\n\t\tint minimumSecondIndex = array.Length;\n\t\tfor (int i=0; i<array.Length; i++) {\n\t\t\tint value = array[i];\n\t\t\tfor (int j=i + 1; j<array.Length; j++) {\n\t\t\t\tint valueToCompare = array[j];\n\t\t\t\tif (value == valueToCompare) {\n\t\t\t\t\tminimumSecondIndex = Math.Min(minimumSecondIndex, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (minimumSecondIndex == array.Length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn array[minimumSecondIndex];\n\t}\n}\n\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(n) time | O(n) space - where n is the length of the input array\n\tpublic int FirstDuplicateValue(int[] array) {\n\t\tHashSet<int> seen = new HashSet<int>();\n\t\tforeach (var value in array) {\n\t\t\tif (seen.Contains(value)) return value;\n\t\t\tseen.Add(value);\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(n) time | O(1) space - where n is the length of the input array\n\tpublic int FirstDuplicateValue(int[] array) {\n\t\tforeach (var value in array) {\n\t\t\tint absValue = Math.Abs(value);\n\t\t\tif (array[absValue - 1] < 0) return absValue;\n\t\t\tarray[absValue - 1] *= -1;\n\t\t}\n\t\treturn -1;\n\t}\n}\n\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar input = new int[] {2, 1, 5, 2, 3, 3, 4};\n\t\tvar expected = 2;\n\t\tvar actual = new Program().FirstDuplicateValue(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar input = new int[] {2, 1, 5, 2, 3, 3, 4};\n\t\tvar expected = 2;\n\t\tvar actual = new Program().FirstDuplicateValue(input);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc FirstDuplicateValue(array []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(1) space - where n is the length of the input array\nfunc FirstDuplicateValue(array []int) int {\n\tminimumSecondIndex := len(array)\n\tfor i := 0; i < len(array); i++ {\n\t\tvalue := array[i]\n\t\tfor j := i + 1; j < len(array); j++ {\n\t\t\tvalueToCompare := array[j]\n\t\t\tif value == valueToCompare {\n\t\t\t\tminimumSecondIndex = min(minimumSecondIndex, j)\n\t\t\t}\n\t\t}\n\t}\n\tif minimumSecondIndex == len(array) {\n\t\treturn -1\n\t}\n\n\treturn array[minimumSecondIndex]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunc FirstDuplicateValue(array []int) int {\n\tseen := map[int]bool{}\n\tfor _, value := range array {\n\t\tif seen[value] {\n\t\t\treturn value\n\t\t}\n\t\tseen[value] = true\n\t}\n\treturn -1\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunc FirstDuplicateValue(array []int) int {\n\tfor _, value := range array {\n\t\tabsValue := abs(value)\n\t\tif array[absValue-1] < 0 {\n\t\t\treturn absValue\n\t\t}\n\t\tarray[absValue-1] *= -1\n\t}\n\treturn -1\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 1, 5, 2, 3, 3, 4}\n\texpected := 2\n\tactual := FirstDuplicateValue(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{2, 1, 5, 2, 3, 3, 4}\n\texpected := 2\n\tactual := FirstDuplicateValue(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public int firstDuplicateValue(int[] array) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n^2) time | O(1) space - where n is the length of the input array\n  public int firstDuplicateValue(int[] array) {\n    int minimumSecondIndex = array.length;\n    for (int i = 0; i < array.length; i++) {\n      int value = array[i];\n      for (int j = i + 1; j < array.length; j++) {\n        int valueToCompare = array[j];\n        if (value == valueToCompare) {\n          minimumSecondIndex = Math.min(minimumSecondIndex, j);\n        }\n      }\n    }\n\n    if (minimumSecondIndex == array.length) {\n      return -1;\n    }\n\n    return array[minimumSecondIndex];\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n) time | O(n) space - where n is the length of the input array\n  public int firstDuplicateValue(int[] array) {\n    HashSet<Integer> seen = new HashSet<Integer>();\n    for (int value : array) {\n      if (seen.contains(value)) return value;\n      seen.add(value);\n    }\n    return -1;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n) time | O(1) space - where n is the length of the input array\n  public int firstDuplicateValue(int[] array) {\n    for (int value : array) {\n      int absValue = Math.abs(value);\n      if (array[absValue - 1] < 0) return absValue;\n      array[absValue - 1] *= -1;\n    }\n    return -1;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[] {2, 1, 5, 2, 3, 3, 4};\n    var expected = 2;\n    var actual = new Program().firstDuplicateValue(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[] {2, 1, 5, 2, 3, 3, 4};\n    var expected = 2;\n    var actual = new Program().firstDuplicateValue(input);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function firstDuplicateValue(array) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(1) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  let minimumSecondIndex = array.length;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    for (let j = i + 1; j < array.length; j++) {\n      const valueToCompare = array[j];\n      if (value === valueToCompare) {\n        minimumSecondIndex = Math.min(minimumSecondIndex, j);\n      }\n    }\n  }\n\n  if (minimumSecondIndex === array.length) return -1;\n\n  return array[minimumSecondIndex];\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  const seen = new Set();\n  for (const value of array) {\n    if (seen.has(value)) return value;\n    seen.add(value);\n  }\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  for (const value of array) {\n    const absValue = Math.abs(value);\n    if (array[absValue - 1] < 0) return absValue;\n    array[absValue - 1] *= -1;\n  }\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun firstDuplicateValue(array: MutableList<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.min\n\n// O(n^2) time | O(1) space - where n is the length of the input array\nfun firstDuplicateValue(array: MutableList<Int>): Int {\n    var minimumSecondIndex = array.size\n    for (i in 0 until array.size) {\n        val value = array[i]\n        for (j in i + 1 until array.size) {\n            val valueToCompare = array[j]\n            if (value == valueToCompare) {\n                minimumSecondIndex = min(minimumSecondIndex, j)\n            }\n        }\n    }\n\n    if (minimumSecondIndex == array.size) return -1\n\n    return array[minimumSecondIndex]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the length of the input array\nfun firstDuplicateValue(array: MutableList<Int>): Int {\n    val seen = mutableSetOf<Int>()\n    for (value in array) {\n        if (value in seen) return value\n        seen.add(value)\n    }\n    return -1\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\n\n// O(n) time | O(1) space - where n is the length of the input array\nfun firstDuplicateValue(array: MutableList<Int>): Int {\n    for (value in array) {\n        val absValue = abs(value)\n        if (array[absValue - 1] < 0) return absValue\n        array[absValue - 1] *= -1\n    }\n    return -1\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.firstDuplicateValue\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(2, 1, 5, 2, 3, 3, 4)\n        val expected = 2\n        val output = firstDuplicateValue(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.firstDuplicateValue\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = mutableListOf(2, 1, 5, 2, 3, 3, 4)\n        val expected = 2\n        val output = firstDuplicateValue(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def firstDuplicateValue(array):\n    # Write your code here.\n    return []\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(1) space - where n is the length of the input array\ndef firstDuplicateValue(array):\n    minimumSecondIndex = len(array)\n    for i in range(len(array)):\n        value = array[i]\n        for j in range(i + 1, len(array)):\n            valueToCompare = array[j]\n            if value == valueToCompare:\n                minimumSecondIndex = min(minimumSecondIndex, j)\n\n    if minimumSecondIndex == len(array):\n        return -1\n\n    return array[minimumSecondIndex]\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the input array\ndef firstDuplicateValue(array):\n    seen = set()\n    for value in array:\n        if value in seen:\n            return value\n        seen.add(value)\n    return -1\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space - where n is the length of the input array\ndef firstDuplicateValue(array):\n    for value in array:\n        absValue = abs(value)\n        if array[absValue - 1] < 0:\n            return absValue\n        array[absValue - 1] *= -1\n    return -1\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [2, 1, 5, 2, 3, 3, 4]\n        expected = 2\n        actual = program.firstDuplicateValue(input)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = [2, 1, 5, 2, 3, 3, 4]\n        expected = 2\n        actual = program.firstDuplicateValue(input)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def firstDuplicateValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def firstDuplicateValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def firstDuplicateValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def firstDuplicateValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.firstDuplicateValue\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.firstDuplicateValue\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func firstDuplicateValue(_ array: inout [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(1) space - where n is the length of the input array\n  func firstDuplicateValue(_ array: inout [Int]) -> Int {\n    var minimumSecondIndex = array.count\n    for i in 0 ..< array.count {\n      let value = array[i]\n      for j in i + 1 ..< array.count {\n        let valueToCompare = array[j]\n        if value == valueToCompare {\n          minimumSecondIndex = min(minimumSecondIndex, j)\n        }\n      }\n    }\n    if minimumSecondIndex == array.count {\n      return -1\n    }\n    return array[minimumSecondIndex]\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input array\n  func firstDuplicateValue(_ array: inout [Int]) -> Int {\n    var seen = Set<Int>()\n    for value in array {\n      if seen.contains(value) {\n        return value\n      }\n      seen.insert(value)\n    }\n    return -1\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space - where n is the length of the input array\n  func firstDuplicateValue(_ array: inout [Int]) -> Int {\n    for value in array {\n      let absValue = abs(value)\n      if array[absValue - 1] < 0 {\n        return absValue\n      }\n      array[absValue - 1] = -array[absValue - 1]\n    }\n    return -1\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [2, 1, 5, 2, 3, 3, 4]\n      var expected = 2\n      var actual = Program().firstDuplicateValue(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [2, 1, 5, 2, 3, 3, 4]\n      var expected = 2\n      var actual = Program().firstDuplicateValue(&input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function firstDuplicateValue(array: number[]) {\n  // Write your code here.\n  return [];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(1) space - where n is the length of the input array\nexport function firstDuplicateValue(array: number[]) {\n  let minimumSecondIndex = array.length;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    for (let j = i + 1; j < array.length; j++) {\n      const valueToCompare = array[j];\n      if (value === valueToCompare) {\n        minimumSecondIndex = Math.min(minimumSecondIndex, j);\n      }\n    }\n  }\n\n  if (minimumSecondIndex === array.length) return -1;\n\n  return array[minimumSecondIndex];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nexport function firstDuplicateValue(array: number[]) {\n  const seen = new Set();\n  for (const value of array) {\n    if (seen.has(value)) return value;\n    seen.add(value);\n  }\n  return -1;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nexport function firstDuplicateValue(array: number[]) {\n  for (const value of array) {\n    const absValue = Math.abs(value);\n    if (array[absValue - 1] < 0) return absValue;\n    array[absValue - 1] *= -1;\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [2, 1, 5, 2, 3, 3, 4],
          schema: {
            items: {
              minimum: 1,
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [2, 1, 5, 2, 3, 3, 4],
        },
        {
          array: [2, 1, 5, 3, 3, 2, 4],
        },
        {
          array: [1, 1, 2, 3, 3, 2, 2],
        },
        {
          array: [3, 1, 3, 1, 1, 4, 4],
        },
        {
          array: [],
        },
        {
          array: [1],
        },
        {
          array: [1, 1],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10],
        },
        {
          array: [2, 1, 1],
        },
        {
          array: [2, 2, 2, 2, 2, 2, 2, 2, 2],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [7, 6, 5, 3, 6, 4, 3, 5, 2],
        },
        {
          array: [9, 13, 6, 2, 3, 5, 5, 5, 3, 2, 2, 2, 2, 4, 3],
        },
        {
          array: [
            23, 21, 22, 5, 3, 13, 11, 16, 5, 11, 9, 14, 23, 3, 2, 2, 5, 11, 6,
            11, 23, 8, 1,
          ],
        },
        {
          array: [
            8, 20, 4, 12, 14, 9, 19, 17, 14, 20, 22, 9, 6, 15, 1, 15, 10, 9, 17,
            7, 22, 17,
          ],
        },
        {
          array: [3, 3, 2],
        },
        {
          array: [6, 6, 5, 1, 3, 7, 7, 8],
        },
        {
          array: [
            23, 25, 9, 26, 2, 19, 24, 18, 25, 17, 13, 3, 14, 17, 9, 20, 26, 15,
            21, 2, 6, 11, 2, 12, 23, 5, 4, 20,
          ],
        },
        {
          array: [
            12, 22, 6, 18, 5, 17, 18, 22, 22, 4, 6, 14, 12, 8, 5, 6, 10, 7, 13,
            22, 17, 18,
          ],
        },
        {
          array: [
            16, 6, 6, 18, 6, 13, 28, 9, 3, 26, 10, 2, 23, 5, 20, 21, 11, 20, 6,
            11, 26, 20, 26, 25, 13, 3, 12, 4,
          ],
        },
        {
          array: [
            15, 2, 6, 3, 3, 22, 14, 16, 6, 21, 4, 16, 2, 17, 9, 13, 1, 3, 5, 6,
            1, 2, 23, 16, 16,
          ],
        },
        {
          array: [4, 7, 9, 7, 1, 3, 2, 3, 1, 12, 12, 5],
        },
        {
          array: [
            9, 21, 9, 22, 3, 23, 4, 26, 7, 11, 25, 25, 19, 13, 23, 28, 5, 23,
            19, 13, 10, 26, 28, 9, 28, 16, 7, 13, 22,
          ],
        },
        {
          array: [
            29, 3, 23, 16, 1, 22, 21, 14, 15, 21, 12, 27, 9, 12, 11, 3, 22, 5,
            21, 24, 14, 26, 11, 5, 21, 25, 15, 19, 13, 4,
          ],
        },
        {
          array: [13, 2, 8, 8, 10, 11, 13, 11, 9, 13, 4, 5, 7],
        },
        {
          array: [
            4, 7, 7, 14, 14, 10, 15, 14, 14, 16, 14, 11, 5, 12, 17, 7, 1, 6, 13,
          ],
        },
        {
          array: [2, 5, 1, 4, 1],
        },
        {
          array: [11, 10, 5, 3, 1, 7, 10, 6, 10, 11, 7],
        },
        {
          array: [2, 13, 3, 9, 1, 9, 1, 11, 11, 5, 3, 1, 9, 12],
        },
        {
          array: [3, 3, 1, 1],
        },
        {
          array: [
            26, 18, 21, 26, 26, 16, 16, 3, 19, 9, 10, 24, 21, 9, 8, 11, 17, 21,
            18, 22, 17, 27, 6, 7, 6, 10, 4,
          ],
        },
        {
          array: [
            27, 16, 15, 21, 10, 21, 3, 21, 5, 12, 27, 24, 20, 26, 5, 13, 26, 22,
            26, 8, 23, 10, 14, 17, 7, 5, 3,
          ],
        },
        {
          array: [
            11, 6, 1, 1, 4, 19, 10, 12, 19, 8, 12, 15, 26, 9, 6, 20, 17, 12, 26,
            15, 25, 18, 26, 5, 3, 5, 16, 5,
          ],
        },
        {
          array: [
            16, 22, 20, 22, 26, 19, 8, 17, 18, 24, 17, 19, 19, 11, 18, 13, 10,
            20, 6, 23, 20, 19, 21, 6, 17, 7,
          ],
        },
        {
          array: [11, 13, 6, 12, 4, 15, 4, 9, 3, 10, 5, 8, 15, 5, 8],
        },
        {
          array: [7, 9, 5, 6, 4, 11, 2, 8, 2, 5, 1],
        },
        {
          array: [8, 1, 5, 2, 9, 12, 9, 6, 9, 9, 5, 13, 5, 9],
        },
        {
          array: [11, 5, 2, 7, 11, 11, 3, 11, 4, 2, 9],
        },
        {
          array: [
            2, 22, 3, 20, 18, 8, 29, 25, 7, 12, 12, 17, 1, 28, 3, 6, 11, 2, 28,
            16, 23, 27, 8, 28, 4, 29, 24, 12, 29,
          ],
        },
        {
          array: [5, 1, 3, 5, 1],
        },
        {
          array: [
            20, 12, 3, 18, 9, 16, 4, 18, 6, 19, 14, 23, 10, 13, 6, 1, 22, 11,
            11, 16, 13, 15, 17, 19, 14, 12, 20,
          ],
        },
        {
          array: [
            23, 15, 11, 5, 13, 11, 9, 9, 13, 8, 22, 12, 2, 24, 6, 2, 15, 24, 12,
            9, 13, 13, 22, 18,
          ],
        },
        {
          array: [4, 1, 5, 1, 4],
        },
        {
          array: [
            7, 14, 4, 6, 17, 17, 3, 14, 1, 16, 18, 4, 12, 13, 8, 19, 1, 2, 4,
            14,
          ],
        },
        {
          array: [5, 6, 6, 4, 3, 5],
        },
        {
          array: [3, 2, 3, 1],
        },
        {
          array: [9, 12, 14, 6, 14, 2, 4, 9, 13, 2, 10, 5, 7, 1],
        },
        {
          array: [
            9, 2, 11, 5, 6, 8, 10, 15, 5, 7, 11, 6, 19, 19, 14, 15, 3, 9, 16,
          ],
        },
        {
          array: [2, 6, 1, 7, 1, 6, 6],
        },
        {
          array: [6, 3, 1, 8, 2, 2, 1, 7, 10, 8, 6, 4],
        },
        {
          array: [
            21, 17, 1, 8, 22, 8, 22, 8, 23, 3, 21, 5, 18, 2, 8, 21, 21, 22, 10,
            24, 13, 4, 20, 24,
          ],
        },
        {
          array: [
            16, 9, 13, 10, 18, 17, 11, 5, 11, 4, 2, 16, 15, 6, 3, 7, 15, 10, 1,
          ],
        },
        {
          array: [5, 5, 5, 4, 6, 6, 2],
        },
        {
          array: [5, 3, 8, 2, 9, 6, 8, 1, 6],
        },
        {
          array: [5, 5, 1, 5, 3, 7, 4, 4],
        },
        {
          array: [
            19, 4, 1, 6, 2, 5, 20, 13, 8, 6, 11, 12, 12, 12, 11, 18, 7, 13, 6,
            10,
          ],
        },
        {
          array: [3, 11, 11, 10, 11, 8, 8, 11, 10, 11, 10, 8, 10],
        },
        {
          array: [15, 3, 15, 6, 13, 3, 12, 10, 17, 8, 13, 1, 12, 9, 14, 7, 16],
        },
        {
          array: [2, 2, 2],
        },
        {
          array: [11, 6, 8, 8, 8, 9, 10, 6, 4, 1, 10, 1, 6],
        },
        {
          array: [2, 3, 16, 9, 11, 14, 13, 1, 10, 12, 5, 17, 4, 16, 10, 5, 4],
        },
        {
          array: [13, 4, 10, 10, 8, 13, 13, 7, 11, 6, 3, 2, 11],
        },
        {
          array: [6, 15, 7, 10, 9, 14, 10, 1, 10, 1, 2, 11, 1, 6, 8],
        },
      ],
      jsonTests: [
        {
          array: [2, 1, 5, 2, 3, 3, 4],
        },
        {
          array: [2, 1, 5, 3, 3, 2, 4],
        },
        {
          array: [1, 1, 2, 3, 3, 2, 2],
        },
        {
          array: [3, 1, 3, 1, 1, 4, 4],
        },
        {
          array: [],
        },
        {
          array: [1],
        },
        {
          array: [1, 1],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10],
        },
        {
          array: [2, 1, 1],
        },
        {
          array: [2, 2, 2, 2, 2, 2, 2, 2, 2],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [7, 6, 5, 3, 6, 4, 3, 5, 2],
        },
        {
          array: [9, 13, 6, 2, 3, 5, 5, 5, 3, 2, 2, 2, 2, 4, 3],
        },
        {
          array: [
            23, 21, 22, 5, 3, 13, 11, 16, 5, 11, 9, 14, 23, 3, 2, 2, 5, 11, 6,
            11, 23, 8, 1,
          ],
        },
        {
          array: [
            8, 20, 4, 12, 14, 9, 19, 17, 14, 20, 22, 9, 6, 15, 1, 15, 10, 9, 17,
            7, 22, 17,
          ],
        },
        {
          array: [3, 3, 2],
        },
        {
          array: [6, 6, 5, 1, 3, 7, 7, 8],
        },
        {
          array: [
            23, 25, 9, 26, 2, 19, 24, 18, 25, 17, 13, 3, 14, 17, 9, 20, 26, 15,
            21, 2, 6, 11, 2, 12, 23, 5, 4, 20,
          ],
        },
        {
          array: [
            12, 22, 6, 18, 5, 17, 18, 22, 22, 4, 6, 14, 12, 8, 5, 6, 10, 7, 13,
            22, 17, 18,
          ],
        },
        {
          array: [
            16, 6, 6, 18, 6, 13, 28, 9, 3, 26, 10, 2, 23, 5, 20, 21, 11, 20, 6,
            11, 26, 20, 26, 25, 13, 3, 12, 4,
          ],
        },
        {
          array: [
            15, 2, 6, 3, 3, 22, 14, 16, 6, 21, 4, 16, 2, 17, 9, 13, 1, 3, 5, 6,
            1, 2, 23, 16, 16,
          ],
        },
        {
          array: [4, 7, 9, 7, 1, 3, 2, 3, 1, 12, 12, 5],
        },
        {
          array: [
            9, 21, 9, 22, 3, 23, 4, 26, 7, 11, 25, 25, 19, 13, 23, 28, 5, 23,
            19, 13, 10, 26, 28, 9, 28, 16, 7, 13, 22,
          ],
        },
        {
          array: [
            29, 3, 23, 16, 1, 22, 21, 14, 15, 21, 12, 27, 9, 12, 11, 3, 22, 5,
            21, 24, 14, 26, 11, 5, 21, 25, 15, 19, 13, 4,
          ],
        },
        {
          array: [13, 2, 8, 8, 10, 11, 13, 11, 9, 13, 4, 5, 7],
        },
        {
          array: [
            4, 7, 7, 14, 14, 10, 15, 14, 14, 16, 14, 11, 5, 12, 17, 7, 1, 6, 13,
          ],
        },
        {
          array: [2, 5, 1, 4, 1],
        },
        {
          array: [11, 10, 5, 3, 1, 7, 10, 6, 10, 11, 7],
        },
        {
          array: [2, 13, 3, 9, 1, 9, 1, 11, 11, 5, 3, 1, 9, 12],
        },
        {
          array: [3, 3, 1, 1],
        },
        {
          array: [
            26, 18, 21, 26, 26, 16, 16, 3, 19, 9, 10, 24, 21, 9, 8, 11, 17, 21,
            18, 22, 17, 27, 6, 7, 6, 10, 4,
          ],
        },
        {
          array: [
            27, 16, 15, 21, 10, 21, 3, 21, 5, 12, 27, 24, 20, 26, 5, 13, 26, 22,
            26, 8, 23, 10, 14, 17, 7, 5, 3,
          ],
        },
        {
          array: [
            11, 6, 1, 1, 4, 19, 10, 12, 19, 8, 12, 15, 26, 9, 6, 20, 17, 12, 26,
            15, 25, 18, 26, 5, 3, 5, 16, 5,
          ],
        },
        {
          array: [
            16, 22, 20, 22, 26, 19, 8, 17, 18, 24, 17, 19, 19, 11, 18, 13, 10,
            20, 6, 23, 20, 19, 21, 6, 17, 7,
          ],
        },
        {
          array: [11, 13, 6, 12, 4, 15, 4, 9, 3, 10, 5, 8, 15, 5, 8],
        },
        {
          array: [7, 9, 5, 6, 4, 11, 2, 8, 2, 5, 1],
        },
        {
          array: [8, 1, 5, 2, 9, 12, 9, 6, 9, 9, 5, 13, 5, 9],
        },
        {
          array: [11, 5, 2, 7, 11, 11, 3, 11, 4, 2, 9],
        },
        {
          array: [
            2, 22, 3, 20, 18, 8, 29, 25, 7, 12, 12, 17, 1, 28, 3, 6, 11, 2, 28,
            16, 23, 27, 8, 28, 4, 29, 24, 12, 29,
          ],
        },
        {
          array: [5, 1, 3, 5, 1],
        },
        {
          array: [
            20, 12, 3, 18, 9, 16, 4, 18, 6, 19, 14, 23, 10, 13, 6, 1, 22, 11,
            11, 16, 13, 15, 17, 19, 14, 12, 20,
          ],
        },
        {
          array: [
            23, 15, 11, 5, 13, 11, 9, 9, 13, 8, 22, 12, 2, 24, 6, 2, 15, 24, 12,
            9, 13, 13, 22, 18,
          ],
        },
        {
          array: [4, 1, 5, 1, 4],
        },
        {
          array: [
            7, 14, 4, 6, 17, 17, 3, 14, 1, 16, 18, 4, 12, 13, 8, 19, 1, 2, 4,
            14,
          ],
        },
        {
          array: [5, 6, 6, 4, 3, 5],
        },
        {
          array: [3, 2, 3, 1],
        },
        {
          array: [9, 12, 14, 6, 14, 2, 4, 9, 13, 2, 10, 5, 7, 1],
        },
        {
          array: [
            9, 2, 11, 5, 6, 8, 10, 15, 5, 7, 11, 6, 19, 19, 14, 15, 3, 9, 16,
          ],
        },
        {
          array: [2, 6, 1, 7, 1, 6, 6],
        },
        {
          array: [6, 3, 1, 8, 2, 2, 1, 7, 10, 8, 6, 4],
        },
        {
          array: [
            21, 17, 1, 8, 22, 8, 22, 8, 23, 3, 21, 5, 18, 2, 8, 21, 21, 22, 10,
            24, 13, 4, 20, 24,
          ],
        },
        {
          array: [
            16, 9, 13, 10, 18, 17, 11, 5, 11, 4, 2, 16, 15, 6, 3, 7, 15, 10, 1,
          ],
        },
        {
          array: [5, 5, 5, 4, 6, 6, 2],
        },
        {
          array: [5, 3, 8, 2, 9, 6, 8, 1, 6],
        },
        {
          array: [5, 5, 1, 5, 3, 7, 4, 4],
        },
        {
          array: [
            19, 4, 1, 6, 2, 5, 20, 13, 8, 6, 11, 12, 12, 12, 11, 18, 7, 13, 6,
            10,
          ],
        },
        {
          array: [3, 11, 11, 10, 11, 8, 8, 11, 10, 11, 10, 8, 10],
        },
        {
          array: [15, 3, 15, 6, 13, 3, 12, 10, 17, 8, 13, 1, 12, 9, 14, 7, 16],
        },
        {
          array: [2, 2, 2],
        },
        {
          array: [11, 6, 8, 8, 8, 9, 10, 6, 4, 1, 10, 1, 6],
        },
        {
          array: [2, 3, 16, 9, 11, 14, 13, 1, 10, 12, 5, 17, 4, 16, 10, 5, 4],
        },
        {
          array: [13, 4, 10, 10, 8, 13, 13, 7, 11, 6, 3, 2, 11],
        },
        {
          array: [6, 15, 7, 10, 9, 14, 10, 1, 10, 1, 2, 11, 1, 6, 8],
        },
      ],
      changelog: [],
      id: 21,
    },
    {
      uid: "max-subset-sum-no-adjacent",
      testStrategy: "JSON",
      name: "Max Subset Sum No Adjacent",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Dynamic Programming",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 31969,
        failureCount: 12663,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "249798598",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 924,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of positive integers and returns the\n  maximum sum of non-adjacent elements in the array.\n</p>\n<p>If the input array is empty, the function should return <span>0</span>.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [75, 105, 120, 75, 90, 135]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n330 <span class="CodeEditor-promptComment">// 75 + 120 + 135</span>\n</pre>\n</div>',
      hints: [
        "<p>\nTry building an array of the same length as the input array. At each index in this new array, store the maximum sum that can be generated using no adjacent numbers located between index 0 and the current index.\n</p>\n",
        "\n<p>\nCan you come up with a formula that relates the max sum at index i to the max sums at indices i - 1 and i - 2?\n</p>\n",
        "\n<p>\nDo you really need to store the entire array mentioned in Hint #1, or can you somehow store just the max sums that you need at any point in time?\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint maxSubsetSumNoAdjacent(vector<int> array) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(n) time | O(n) space\nint maxSubsetSumNoAdjacent(vector<int> array) {\n  if (array.size() == 0) {\n    return 0;\n  } else if (array.size() == 1) {\n    return array[0];\n  }\n  vector<int> maxSums = array;\n  maxSums[1] = max(array[0], array[1]);\n  for (int i = 2; i < array.size(); i++) {\n    maxSums[i] = max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n  }\n  return maxSums[array.size() - 1];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(n) time | O(1) space\nint maxSubsetSumNoAdjacent(vector<int> array) {\n  if (array.size() == 0) {\n    return 0;\n  } else if (array.size() == 1) {\n    return array[0];\n  }\n  int second = array[0];\n  int first = max(array[0], array[1]);\n  for (int i = 2; i < array.size(); i++) {\n    int current = max(first, second + array[i]);\n    second = first;\n    first = current;\n  }\n  return first;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> vector{75, 105, 120, 75, 90, 135};\n      assert(maxSubsetSumNoAdjacent(vector) == 330);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> vector{75, 105, 120, 75, 90, 135};\n      assert(maxSubsetSumNoAdjacent(vector) == 330);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int MaxSubsetSumNoAdjacent(int[] array) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static int MaxSubsetSumNoAdjacent(int[] array) {\n\t\tif (array.Length == 0) {\n\t\t\treturn 0;\n\t\t} else if (array.Length == 1) {\n\t\t\treturn array[0];\n\t\t}\n\t\tint[] maxSums = (int[]) array.Clone();\n\t\tmaxSums[1] = Math.Max(array[0], array[1]);\n\t\tfor (int i = 2; i < array.Length; i++) {\n\t\t\tmaxSums[i] = Math.Max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n\t\t}\n\t\treturn maxSums[array.Length - 1];\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n) time | O(1) space\n\tpublic static int MaxSubsetSumNoAdjacent(int[] array) {\n\t\tif (array.Length == 0) {\n\t\t\treturn 0;\n\t\t} else if (array.Length == 1) {\n\t\t\treturn array[0];\n\t\t}\n\t\tint second = array[0];\n\t\tint first = Math.Max(array[0], array[1]);\n\t\tfor (int i = 2; i < array.Length; i++) {\n\t\t\tint current = Math.Max(first, second + array[i]);\n\t\t\tsecond = first;\n\t\t\tfirst = current;\n\t\t}\n\t\treturn first;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = {75, 105, 120, 75, 90, 135};\n\t\tUtils.AssertTrue(Program.MaxSubsetSumNoAdjacent(input) == 330);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] input = {75, 105, 120, 75, 90, 135};\n\t\tUtils.AssertTrue(Program.MaxSubsetSumNoAdjacent(input) == 330);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc MaxSubsetSumNoAdjacent(array []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space\nfunc MaxSubsetSumNoAdjacent(array []int) int {\n\tif len(array) == 0 {\n\t\treturn 0\n\t} else if len(array) == 1 {\n\t\treturn array[0]\n\t}\n\tmaxSums := make([]int, len(array))\n\tmaxSums[0], maxSums[1] = array[0], max(array[0], array[1])\n\tfor i := 2; i < len(array); i++ {\n\t\tmaxSums[i] = max(maxSums[i-1], maxSums[i-2]+array[i])\n\t}\n\treturn maxSums[len(array)-1]\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space\nfunc MaxSubsetSumNoAdjacent(array []int) int {\n\tif len(array) == 0 {\n\t\treturn 0\n\t} else if len(array) == 1 {\n\t\treturn array[0]\n\t}\n\tfirst := max(array[0], array[1])\n\tsecond := array[0]\n\tfor i := 2; i < len(array); i++ {\n\t\tcurrent := max(first, second+array[i])\n\t\tsecond = first\n\t\tfirst = current\n\t}\n\treturn first\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tres := MaxSubsetSumNoAdjacent([]int{75, 105, 120, 75, 90, 135})\n\trequire.Equal(t, res, 330)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tres := MaxSubsetSumNoAdjacent([]int{75, 105, 120, 75, 90, 135})\n\trequire.Equal(t, res, 330)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int maxSubsetSumNoAdjacent(int[] array) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  public static int maxSubsetSumNoAdjacent(int[] array) {\n    if (array.length == 0) {\n      return 0;\n    } else if (array.length == 1) {\n      return array[0];\n    }\n    int[] maxSums = array.clone();\n    maxSums[1] = Math.max(array[0], array[1]);\n    for (int i = 2; i < array.length; i++) {\n      maxSums[i] = Math.max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n    }\n    return maxSums[array.length - 1];\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  public static int maxSubsetSumNoAdjacent(int[] array) {\n    if (array.length == 0) {\n      return 0;\n    } else if (array.length == 1) {\n      return array[0];\n    }\n    int second = array[0];\n    int first = Math.max(array[0], array[1]);\n    for (int i = 2; i < array.length; i++) {\n      int current = Math.max(first, second + array[i]);\n      second = first;\n      first = current;\n    }\n    return first;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = {75, 105, 120, 75, 90, 135};\n    Utils.assertTrue(Program.maxSubsetSumNoAdjacent(input) == 330);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] input = {75, 105, 120, 75, 90, 135};\n    Utils.assertTrue(Program.maxSubsetSumNoAdjacent(input) == 330);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function maxSubsetSumNoAdjacent(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction maxSubsetSumNoAdjacent(array) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  const maxSums = array.slice();\n  maxSums[1] = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    maxSums[i] = Math.max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n  }\n  return maxSums[maxSums.length - 1];\n}\n\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nfunction maxSubsetSumNoAdjacent(array) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  let second = array[0];\n  let first = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    const current = Math.max(first, second + array[i]);\n    second = first;\n    first = current;\n  }\n  return first;\n}\n\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun maxSubsetSumNoAdjacent(array: List<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\nfun maxSubsetSumNoAdjacent(array: List<Int>): Int {\n    if (array.size == 0) {\n        return 0\n    } else if (array.size == 1) {\n        return array[0]\n    }\n    var maxSums = array.toMutableList()\n    maxSums[1] = max(array[0], array[1])\n    for (i in 2 until array.size) {\n        maxSums[i] = max(maxSums[i - 1], maxSums[i - 2] + array[i])\n    }\n    return maxSums[array.size - 1]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\nfun maxSubsetSumNoAdjacent(array: List<Int>): Int {\n    if (array.size == 0) {\n        return 0\n    } else if (array.size == 1) {\n        return array[0]\n    }\n    var second = array[0]\n    var first = max(array[0], array[1])\n    for (i in 2 until array.size) {\n        val current = max(first, second + array[i])\n        second = first\n        first = current\n    }\n    return first\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.maxSubsetSumNoAdjacent as maxSubsetSumNoAdjacent\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(75, 105, 120, 75, 90, 135)\n        val output = maxSubsetSumNoAdjacent(input)\n        val expected = 330\n        assert(output == expected)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.maxSubsetSumNoAdjacent as maxSubsetSumNoAdjacent\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(75, 105, 120, 75, 90, 135)\n        val output = maxSubsetSumNoAdjacent(input)\n        val expected = 330\n        assert(output == expected)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def maxSubsetSumNoAdjacent(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef maxSubsetSumNoAdjacent(array):\n    if not len(array):\n        return 0\n    elif len(array) == 1:\n        return array[0]\n    maxSums = array[:]\n    maxSums[1] = max(array[0], array[1])\n    for i in range(2, len(array)):\n        maxSums[i] = max(maxSums[i - 1], maxSums[i - 2] + array[i])\n    return maxSums[-1]\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space\ndef maxSubsetSumNoAdjacent(array):\n    if not len(array):\n        return 0\n    elif len(array) == 1:\n        return array[0]\n    second = array[0]\n    first = max(array[0], array[1])\n    for i in range(2, len(array)):\n        current = max(first, second + array[i])\n        second = first\n        first = current\n    return first\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135]), 330)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135]), 330)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def maxSubsetSumNoAdjacent(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def maxSubsetSumNoAdjacent(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def maxSubsetSumNoAdjacent(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.maxSubsetSumNoAdjacent\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.maxSubsetSumNoAdjacent\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func maximumSubsetSum(array: [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func maximumSubsetSum(array: [Int]) -> Int {\n    if array.count == 0 {\n      return 0\n    }\n\n    if array.count == 1 {\n      return array.first!\n    }\n\n    var maxSums = array\n    maxSums[1] = max(maxSums[0], maxSums[1])\n\n    for i in 2 ..< array.count {\n      maxSums[i] = max(maxSums[i - 1], maxSums[i - 2] + array[i])\n    }\n\n    return maxSums[maxSums.count - 1]\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  func maximumSubsetSum(array: [Int]) -> Int {\n    if array.count == 0 {\n      return 0\n    }\n\n    if array.count == 1 {\n      return array[0]\n    }\n\n    var second = array[0]\n    var first = max(array[0], array[1])\n\n    for i in 2 ..< array.count {\n      var current = max(first, second + array[i])\n      second = first\n      first = current\n    }\n\n    return first\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(330, program.maximumSubsetSum(array: [75, 105, 120, 75, 90, 135]))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(330, program.maximumSubsetSum(array: [75, 105, 120, 75, 90, 135]))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function maxSubsetSumNoAdjacent(array: number[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function maxSubsetSumNoAdjacent(array: number[]) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  const maxSums = array.slice();\n  maxSums[1] = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    maxSums[i] = Math.max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n  }\n  return maxSums[maxSums.length - 1];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nexport function maxSubsetSumNoAdjacent(array: number[]) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  let second = array[0];\n  let first = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    const current = Math.max(first, second + array[i]);\n    second = first;\n    first = current;\n  }\n  return first;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [75, 105, 120, 75, 90, 135],
          schema: {
            items: {
              minimum: 1,
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [75, 105, 120, 75, 90, 135],
        },
        {
          array: [],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [1, 15, 3],
        },
        {
          array: [7, 10, 12, 7, 9, 14],
        },
        {
          array: [4, 3, 5, 200, 5, 3],
        },
        {
          array: [10, 5, 20, 25, 15, 5, 5, 15],
        },
        {
          array: [10, 5, 20, 25, 15, 5, 5, 15, 3, 15, 5, 5, 15],
        },
        {
          array: [125, 210, 250, 120, 150, 300],
        },
        {
          array: [30, 25, 50, 55, 100],
        },
        {
          array: [30, 25, 50, 55, 100, 120],
        },
        {
          array: [7, 10, 12, 7, 9, 14, 15, 16, 25, 20, 4],
        },
      ],
      jsonTests: [
        {
          array: [75, 105, 120, 75, 90, 135],
        },
        {
          array: [],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [1, 2, 3],
        },
        {
          array: [1, 15, 3],
        },
        {
          array: [7, 10, 12, 7, 9, 14],
        },
        {
          array: [4, 3, 5, 200, 5, 3],
        },
        {
          array: [10, 5, 20, 25, 15, 5, 5, 15],
        },
        {
          array: [10, 5, 20, 25, 15, 5, 5, 15, 3, 15, 5, 5, 15],
        },
        {
          array: [125, 210, 250, 120, 150, 300],
        },
        {
          array: [30, 25, 50, 55, 100],
        },
        {
          array: [30, 25, 50, 55, 100, 120],
        },
        {
          array: [7, 10, 12, 7, 9, 14, 15, 16, 25, 20, 4],
        },
      ],
      changelog: [],
      id: 22,
    },
    {
      uid: "phone-number-mnemonics",
      testStrategy: "JSON",
      name: "Phone Number Mnemonics",
      version: 0,
      releaseDate: "2021-01-19T00:00:00Z",
      category: "Recursion",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 8724,
        failureCount: 3078,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "499295958",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1814,
      },
      prompt:
        '<div class="html">\n<p>If you open the keypad of your mobile phone, it\'ll likely look like this:</p>\n<pre>\n   ----- ----- -----\n  |     |     |     |\n  |  1  |  2  |  3  |\n  |     | abc | def |\n   ----- ----- -----\n  |     |     |     |\n  |  4  |  5  |  6  |\n  | ghi | jkl | mno |\n   ----- ----- -----\n  |     |     |     |\n  |  7  |  8  |  9  |\n  | pqrs| tuv | wxyz|\n   ----- ----- -----\n        |     |\n        |  0  |\n        |     |\n         -----\n</pre>\n<p>\n  Almost every digit is associated with some letters in the alphabet; this\n  allows certain phone numbers to spell out actual words. For example, the phone\n  number <span>8464747328</span> can be written as <span>timisgreat</span>;\n  similarly, the phone number <span>2686463</span> can be written as\n  <span>antoine</span> or as <span>ant6463</span>.\n</p>\n<p>\n  It\'s important to note that a phone number doesn\'t represent a single sequence\n  of letters, but rather multiple combinations of letters. For instance, the\n  digit <span>2</span> can represent three different letters (a, b, and c).\n</p>\n<p>\n  A mnemonic is defined as a pattern of letters, ideas, or associations that\n  assist in remembering something. Companies oftentimes use a mnemonic for their\n  phone number to make it easier to remember.\n</p>\n<p>\n  Given a stringified phone number of any non-zero length, write a function that\n  returns all mnemonics for this phone number, in any order.\n</p>\n<p>\n  For this problem, a valid mnemonic may only contain letters and the digits\n  <span>0</span> and <span>1</span>. In other words, if a digit is able to be\n  represented by a letter, then it must be. Digits <span>0</span> and\n  <span>1</span> are the only two digits that don\'t have letter representations\n  on the keypad.\n</p>\n<p>\n  Note that you should rely on the keypad illustrated above for digit-letter\n  associations.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">phoneNumber</span> = "1905"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  "1w0j",\n  "1w0k",\n  "1w0l",\n  "1x0j",\n  "1x0k",\n  "1x0l",\n  "1y0j",\n  "1y0k",\n  "1y0l",\n  "1z0j",\n  "1z0k",\n  "1z0l",\n]\n<span class="CodeEditor-promptComment">// The mnemonics could be ordered differently.</span>\n</pre>\n</div>',
      hints: [
        "<p>\nThe first thing you'll need to do is create a mapping from digits to letters. You can do this by creating a hash table mapping all string digits to lists of their respective characters.\n</p>\n",
        "\n<p>\nThis problem can be solved fairly easily using recursion. Try generating all characters for the first digit in the phone number one at a time, and for each character, recursively performing the same action on the the next digit, and then on the digit after that, and so on and so forth until you've done so for all digits in the phone number.\n</p>\n",
        "\n<p>\nYou can recursively generate characters one digit at a time and store the intermediate results in a array. Once you've reached the last digit in the phone number, you can add the currently generated mnemonic (stored in the previously mentioned array) to a final array that stores all the results.\n</p>",
      ],
      spaceTime:
        "O(4^n * n) time | O(4^n * n) space - where n is the length of the phone number",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<string> phoneNumberMnemonics(string phoneNumber) {\n  // Write your code here.\n  return {phoneNumber};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <numeric>\n#include <unordered_map>\nusing namespace std;\n\nvoid phoneNumberMnemonicsHelper(int idx, string phoneNumber,\n                                vector<char> &currentMnemonic,\n                                vector<string> &mnemonicsFound);\nunordered_map<int, vector<char>> DIGIT_LETTERS{\n    {0, {'0'}},           {1, {'1'}},\n    {2, {'a', 'b', 'c'}}, {3, {'d', 'e', 'f'}},\n    {4, {'g', 'h', 'i'}}, {5, {'j', 'k', 'l'}},\n    {6, {'m', 'n', 'o'}}, {7, {'p', 'q', 'r', 's'}},\n    {8, {'t', 'u', 'v'}}, {9, {'w', 'x', 'y', 'z'}}};\n\n// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nvector<string> phoneNumberMnemonics(string phoneNumber) {\n  vector<char> currentMnemonic(phoneNumber.size(), '0');\n  vector<string> mnemonicsFound;\n  cout << (int)'4' << endl;\n  phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n  return mnemonicsFound;\n}\n\nvoid phoneNumberMnemonicsHelper(int idx, string phoneNumber,\n                                vector<char> &currentMnemonic,\n                                vector<string> &mnemonicsFound) {\n  if (idx == phoneNumber.size()) {\n    string mnemonic =\n        accumulate(currentMnemonic.begin(), currentMnemonic.end(), string{});\n    mnemonicsFound.push_back(mnemonic);\n  } else {\n    int digit = phoneNumber[idx] - '0';\n    vector<char> letters = DIGIT_LETTERS[digit];\n    for (auto letter : letters) {\n      currentMnemonic[idx] = letter;\n      phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic,\n                                 mnemonicsFound);\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string phoneNumber = "1905";\n      vector<string> expected = {"1w0j", "1w0k", "1w0l", "1x0j",\n                                 "1x0k", "1x0l", "1y0j", "1y0k",\n                                 "1y0l", "1z0j", "1z0k", "1z0l"};\n      auto actual = phoneNumberMnemonics(phoneNumber);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      string phoneNumber = "1905";\n      vector<string> expected = {"1w0j", "1w0k", "1w0l", "1x0j",\n                                 "1x0k", "1x0l", "1y0j", "1y0k",\n                                 "1y0l", "1z0j", "1z0k", "1z0l"};\n      auto actual = phoneNumberMnemonics(phoneNumber);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\tpublic List<string> PhoneNumberMnemonics(string phoneNumber) {\n\t\t// Write your code here.\n\t\treturn new List<string>();\n\t}\n}\n\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\tpublic static Dictionary<char, string[]> DIGIT_LETTERS = new Dictionary<char, string[]> {\n\t\t{\'0\', new string[] {"0"}},\n\t\t{\'1\', new string[] {"1"}},\n\t\t{\'2\', new string[] {"a", "b", "c"}},\n\t\t{\'3\', new string[] {"d", "e", "f"}},\n\t\t{\'4\', new string[] {"g", "h", "i"}},\n\t\t{\'5\', new string[] {"j", "k", "l"}},\n\t\t{\'6\', new string[] {"m", "n", "o"}},\n\t\t{\'7\', new string[] {"p", "q", "r", "s"}},\n\t\t{\'8\', new string[] {"t", "u", "v"}},\n\t\t{\'9\', new string[] {"w", "x", "y", "z"}}\n\t};\n\n\t// O(4^n * n) time | O(4^n * n) space - where\n\t// n is the length of the phone number\n\tpublic List<string> PhoneNumberMnemonics(string phoneNumber) {\n\n\t\tstring[] currentMnemonic = new string[phoneNumber.Length];\n\t\tArray.Fill(currentMnemonic, "0");\n\n\t\tList<string> mnemonicsFound = new List<string>();\n\t\tPhoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n\t\treturn mnemonicsFound;\n\t}\n\n\tpublic void PhoneNumberMnemonicsHelper(int idx, string phoneNumber,\n\t  string[] currentMnemonic,\n\t  List<string> mnemonicsFound) {\n\t\tif (idx == phoneNumber.Length) {\n\t\t\tstring mnemonic = String.Join("", currentMnemonic);\n\t\t\tmnemonicsFound.Add(mnemonic);\n\t\t} else {\n\t\t\tchar digit = phoneNumber[idx];\n\t\t\tstring[] letters = DIGIT_LETTERS[digit];\n\t\t\tforeach (var letter in letters) {\n\t\t\t\tcurrentMnemonic[idx] = letter;\n\t\t\t\tPhoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic,\n\t\t\t\t  mnemonicsFound);\n\t\t\t}\n\t\t}\n\t}\n}\n\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring phoneNumber = "1905";\n\t\tstring[] expectedValues = new string[] {\n\t\t\t"1w0j",\n\t\t\t"1w0k",\n\t\t\t"1w0l",\n\t\t\t"1x0j",\n\t\t\t"1x0k",\n\t\t\t"1x0l",\n\t\t\t"1y0j",\n\t\t\t"1y0k",\n\t\t\t"1y0l",\n\t\t\t"1z0j",\n\t\t\t"1z0k",\n\t\t\t"1z0l"\n\t\t};\n\t\tList<string> expected = new List<string>();\n\t\tfor (int i = 0; i < expectedValues.Length; i++) {\n\t\t\texpected.Add(expectedValues[i]);\n\t\t}\n\t\tvar actual = new Program().PhoneNumberMnemonics(phoneNumber);\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n\t}\n}\n',
          unitTests:
            'using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring phoneNumber = "1905";\n\t\tstring[] expectedValues = new string[] {\n\t\t\t"1w0j",\n\t\t\t"1w0k",\n\t\t\t"1w0l",\n\t\t\t"1x0j",\n\t\t\t"1x0k",\n\t\t\t"1x0l",\n\t\t\t"1y0j",\n\t\t\t"1y0k",\n\t\t\t"1y0l",\n\t\t\t"1z0j",\n\t\t\t"1z0k",\n\t\t\t"1z0l"\n\t\t};\n\t\tList<string> expected = new List<string>();\n\t\tfor (int i = 0; i < expectedValues.Length; i++) {\n\t\t\texpected.Add(expectedValues[i]);\n\t\t}\n\t\tvar actual = new Program().PhoneNumberMnemonics(phoneNumber);\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(expected, actual));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc PhoneNumberMnemonics(phoneNumber string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nfunc PhoneNumberMnemonics(phoneNumber string) []string {\n\tcurrentMnemonic := make([]byte, len(phoneNumber))\n\tfor i := range currentMnemonic {\n\t\tcurrentMnemonic[i] = '0'\n\t}\n\tmnemonicsFound := make([]string, 0)\n\n\tphoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, &mnemonicsFound)\n\treturn mnemonicsFound\n}\n\nfunc phoneNumberMnemonicsHelper(idx int, phoneNumber string, currentMnemonic []byte, mnemonicsFound *[]string) {\n\tif idx == len(phoneNumber) {\n\t\tmnemonic := string(currentMnemonic)\n\t\t*mnemonicsFound = append(*mnemonicsFound, mnemonic)\n\t} else {\n\t\tdigit := phoneNumber[idx]\n\t\tletters := DigitLetters[digit]\n\t\tfor _, letter := range letters {\n\t\t\tcurrentMnemonic[idx] = letter\n\t\t\tphoneNumberMnemonicsHelper(idx+1, phoneNumber, currentMnemonic, mnemonicsFound)\n\t\t}\n\t}\n}\n\nvar DigitLetters = map[byte][]byte{\n\t'0': {'0'},\n\t'1': {'1'},\n\t'2': {'a', 'b', 'c'},\n\t'3': {'d', 'e', 'f'},\n\t'4': {'g', 'h', 'i'},\n\t'5': {'j', 'k', 'l'},\n\t'6': {'m', 'n', 'o'},\n\t'7': {'p', 'q', 'r', 's'},\n\t'8': {'t', 'u', 'v'},\n\t'9': {'w', 'x', 'y', 'z'},\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tphoneNumber := "1905"\n\texpected := []string{\n\t\t"1w0j",\n\t\t"1w0k",\n\t\t"1w0l",\n\t\t"1x0j",\n\t\t"1x0k",\n\t\t"1x0l",\n\t\t"1y0j",\n\t\t"1y0k",\n\t\t"1y0l",\n\t\t"1z0j",\n\t\t"1z0k",\n\t\t"1z0l",\n\t}\n\tactual := PhoneNumberMnemonics(phoneNumber)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tphoneNumber := "1905"\n\texpected := []string{\n\t\t"1w0j",\n\t\t"1w0k",\n\t\t"1w0l",\n\t\t"1x0j",\n\t\t"1x0k",\n\t\t"1x0l",\n\t\t"1y0j",\n\t\t"1y0k",\n\t\t"1y0l",\n\t\t"1z0j",\n\t\t"1z0k",\n\t\t"1z0l",\n\t}\n\tactual := PhoneNumberMnemonics(phoneNumber)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public ArrayList<String> phoneNumberMnemonics(String phoneNumber) {\n    // Write your code here.\n    return new ArrayList<String>();\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  public static Map<Character, String[]> DIGIT_LETTERS = new HashMap<Character, String[]>();\n\n  static {\n    DIGIT_LETTERS.put(\'0\', new String[] {"0"});\n    DIGIT_LETTERS.put(\'1\', new String[] {"1"});\n    DIGIT_LETTERS.put(\'2\', new String[] {"a", "b", "c"});\n    DIGIT_LETTERS.put(\'3\', new String[] {"d", "e", "f"});\n    DIGIT_LETTERS.put(\'4\', new String[] {"g", "h", "i"});\n    DIGIT_LETTERS.put(\'5\', new String[] {"j", "k", "l"});\n    DIGIT_LETTERS.put(\'6\', new String[] {"m", "n", "o"});\n    DIGIT_LETTERS.put(\'7\', new String[] {"p", "q", "r", "s"});\n    DIGIT_LETTERS.put(\'8\', new String[] {"t", "u", "v"});\n    DIGIT_LETTERS.put(\'9\', new String[] {"w", "x", "y", "z"});\n  }\n\n  // O(4^n * n) time | O(4^n * n) space - where\n  // n is the length of the phone number\n  public ArrayList<String> phoneNumberMnemonics(String phoneNumber) {\n\n    String[] currentMnemonic = new String[phoneNumber.length()];\n    Arrays.fill(currentMnemonic, "0");\n\n    ArrayList<String> mnemonicsFound = new ArrayList<String>();\n    phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n    return mnemonicsFound;\n  }\n\n  public void phoneNumberMnemonicsHelper(\n      int idx, String phoneNumber, String[] currentMnemonic, ArrayList<String> mnemonicsFound) {\n    if (idx == phoneNumber.length()) {\n      String mnemonic = String.join("", currentMnemonic);\n      mnemonicsFound.add(mnemonic);\n    } else {\n      char digit = phoneNumber.charAt(idx);\n      String[] letters = DIGIT_LETTERS.get(digit);\n      for (String letter : letters) {\n        currentMnemonic[idx] = letter;\n        phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound);\n      }\n    }\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String phoneNumber = "1905";\n    String[] expectedValues =\n        new String[] {\n          "1w0j", "1w0k", "1w0l", "1x0j", "1x0k", "1x0l", "1y0j", "1y0k", "1y0l", "1z0j", "1z0k",\n          "1z0l"\n        };\n    ArrayList<String> expected = new ArrayList<String>();\n    for (int i = 0; i < expectedValues.length; i++) {\n      expected.add(expectedValues[i]);\n    }\n    var actual = new Program().phoneNumberMnemonics(phoneNumber);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    String phoneNumber = "1905";\n    String[] expectedValues =\n        new String[] {\n          "1w0j", "1w0k", "1w0l", "1x0j", "1x0k", "1x0l", "1y0j", "1y0k", "1y0l", "1z0j", "1z0k",\n          "1z0l"\n        };\n    ArrayList<String> expected = new ArrayList<String>();\n    for (int i = 0; i < expectedValues.length; i++) {\n      expected.add(expectedValues[i]);\n    }\n    var actual = new Program().phoneNumberMnemonics(phoneNumber);\n    Utils.assertTrue(expected.equals(actual));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function phoneNumberMnemonics(phoneNumber) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.phoneNumberMnemonics = phoneNumberMnemonics;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nfunction phoneNumberMnemonics(phoneNumber) {\n  const currentMnemonic = new Array(phoneNumber.length).fill('0');\n  const mnemonicsFound = [];\n\n  phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n  return mnemonicsFound;\n}\n\nfunction phoneNumberMnemonicsHelper(idx, phoneNumber, currentMnemonic, mnemonicsFound) {\n  if (idx === phoneNumber.length) {\n    const mnemonic = currentMnemonic.join('');\n    mnemonicsFound.push(mnemonic);\n  } else {\n    const digit = phoneNumber[idx];\n    const letters = DIGIT_LETTERS[digit];\n    for (const letter of letters) {\n      currentMnemonic[idx] = letter;\n      phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound);\n    }\n  }\n}\n\nconst DIGIT_LETTERS = {\n  0: ['0'],\n  1: ['1'],\n  2: ['a', 'b', 'c'],\n  3: ['d', 'e', 'f'],\n  4: ['g', 'h', 'i'],\n  5: ['j', 'k', 'l'],\n  6: ['m', 'n', 'o'],\n  7: ['p', 'q', 'r', 's'],\n  8: ['t', 'u', 'v'],\n  9: ['w', 'x', 'y', 'z'],\n};\n\n// Do not edit the line below.\nexports.phoneNumberMnemonics = phoneNumberMnemonics;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = ['1w0j', '1w0k', '1w0l', '1x0j', '1x0k', '1x0l', '1y0j', '1y0k', '1y0l', '1z0j', '1z0k', '1z0l'];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = ['1w0j', '1w0k', '1w0l', '1x0j', '1x0k', '1x0l', '1y0j', '1y0k', '1y0l', '1z0j', '1z0k', '1z0l'];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun phoneNumberMnemonics(phoneNumber: String): List<String> {\n    // Write your code here.\n    return listOf()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nfun phoneNumberMnemonics(phoneNumber: String): List<String> {\n    val currentMnemonic = MutableList(phoneNumber.length) { '0' }\n    val mnemonicsFound = mutableListOf<String>()\n\n    phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound)\n    return mnemonicsFound\n}\n\nfun phoneNumberMnemonicsHelper(idx: Int, phoneNumber: String, currentMnemonic: MutableList<Char>, mnemonicsFound: MutableList<String>) {\n    if (idx == phoneNumber.length) {\n        val mnemonic = currentMnemonic.joinToString(\"\")\n        mnemonicsFound.add(mnemonic)\n    } else {\n        val digit = phoneNumber[idx]\n        val letters = DIGIT_LETTERS[digit]!!\n        for (letter in letters) {\n            currentMnemonic[idx] = letter\n            phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound)\n        }\n    }\n}\n\nval DIGIT_LETTERS = mutableMapOf(\n    '0' to listOf('0'),\n    '1' to listOf('1'),\n    '2' to listOf('a', 'b', 'c'),\n    '3' to listOf('d', 'e', 'f'),\n    '4' to listOf('g', 'h', 'i'),\n    '5' to listOf('j', 'k', 'l'),\n    '6' to listOf('m', 'n', 'o'),\n    '7' to listOf('p', 'q', 'r', 's'),\n    '8' to listOf('t', 'u', 'v'),\n    '9' to listOf('w', 'x', 'y', 'z')\n)\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.phoneNumberMnemonics\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val phoneNumber = "1905"\n        val expected = listOf(\n            "1w0j",\n            "1w0k",\n            "1w0l",\n            "1x0j",\n            "1x0k",\n            "1x0l",\n            "1y0j",\n            "1y0k",\n            "1y0l",\n            "1z0j",\n            "1z0k",\n            "1z0l"\n        )\n        val output = phoneNumberMnemonics(phoneNumber)\n        assert(expected == output)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.phoneNumberMnemonics\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val phoneNumber = "1905"\n        val expected = listOf(\n            "1w0j",\n            "1w0k",\n            "1w0l",\n            "1x0j",\n            "1x0k",\n            "1x0l",\n            "1y0j",\n            "1y0k",\n            "1y0l",\n            "1z0j",\n            "1z0k",\n            "1z0l"\n        )\n        val output = phoneNumberMnemonics(phoneNumber)\n        assert(expected == output)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def phoneNumberMnemonics(phoneNumber):\n    # Write your code here.\n    return []\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(4^n * n) time | O(4^n * n) space - where\n# n is the length of the phone number\ndef phoneNumberMnemonics(phoneNumber):\n    currentMnemonic = ["0"] * len(phoneNumber)\n    mnemonicsFound = []\n\n    phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound)\n    return mnemonicsFound\n\n\ndef phoneNumberMnemonicsHelper(idx, phoneNumber, currentMnemonic, mnemonicsFound):\n    if idx == len(phoneNumber):\n        mnemonic = "".join(currentMnemonic)\n        mnemonicsFound.append(mnemonic)\n    else:\n        digit = phoneNumber[idx]\n        letters = DIGIT_LETTERS[digit]\n        for letter in letters:\n            currentMnemonic[idx] = letter\n            phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound)\n\n\nDIGIT_LETTERS = {\n    "0": ["0"],\n    "1": ["1"],\n    "2": ["a", "b", "c"],\n    "3": ["d", "e", "f"],\n    "4": ["g", "h", "i"],\n    "5": ["j", "k", "l"],\n    "6": ["m", "n", "o"],\n    "7": ["p", "q", "r", "s"],\n    "8": ["t", "u", "v"],\n    "9": ["w", "x", "y", "z"],\n}\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        phoneNumber = "1905"\n        expected = ["1w0j", "1w0k", "1w0l", "1x0j", "1x0k", "1x0l", "1y0j", "1y0k", "1y0l", "1z0j", "1z0k", "1z0l"]\n        actual = program.phoneNumberMnemonics(phoneNumber)\n        self.assertEqual(actual, expected)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        phoneNumber = "1905"\n        expected = ["1w0j", "1w0k", "1w0l", "1x0j", "1x0k", "1x0l", "1y0j", "1y0k", "1y0l", "1z0j", "1z0k", "1z0l"]\n        actual = program.phoneNumberMnemonics(phoneNumber)\n        self.assertEqual(actual, expected)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def phoneNumberMnemonics(phoneNumber)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def phoneNumberMnemonics(phoneNumber)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.phoneNumberMnemonics\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.phoneNumberMnemonics\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func phoneNumberMnemonics(_ phoneNumber: String) -> [String] {\n    // Write your code here.\n    return [String]()\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(4^n * n) time | O(4^n * n) space - where\n  // n is the length of the phone number\n  func phoneNumberMnemonics(_ phoneNumber: String) -> [String] {\n    var currentMnemonic = Array(repeating: Character("0"), count: phoneNumber.count)\n    var mnemonicsFound = [String]()\n    var indexedPhoneNumber = Array(phoneNumber)\n\n    phoneNumberMnemonicsHelper(0, &indexedPhoneNumber, &currentMnemonic, &mnemonicsFound)\n    return mnemonicsFound\n  }\n\n  func phoneNumberMnemonicsHelper(_ idx: Int, _ phoneNumber: inout [Character], _ currentMnemonic: inout [Character],\n                                  _ mnemonicsFound: inout [String])\n  {\n    if idx == phoneNumber.count {\n      let mnemonic = String(currentMnemonic)\n      mnemonicsFound.append(mnemonic)\n    } else {\n      let digit = phoneNumber[idx]\n      let letters = DigitLetters[digit]!\n      for letter in letters {\n        currentMnemonic[idx] = letter\n        phoneNumberMnemonicsHelper(idx + 1, &phoneNumber, &currentMnemonic, &mnemonicsFound)\n      }\n    }\n  }\n\n  let DigitLetters: [Character: [Character]] = [\n    "0": ["0"],\n    "1": ["1"],\n    "2": ["a", "b", "c"],\n    "3": ["d", "e", "f"],\n    "4": ["g", "h", "i"],\n    "5": ["j", "k", "l"],\n    "6": ["m", "n", "o"],\n    "7": ["p", "q", "r", "s"],\n    "8": ["t", "u", "v"],\n    "9": ["w", "x", "y", "z"],\n  ]\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let phoneNumber = "1905"\n      let expected = [\n        "1w0j",\n        "1w0k",\n        "1w0l",\n        "1x0j",\n        "1x0k",\n        "1x0l",\n        "1y0j",\n        "1y0k",\n        "1y0l",\n        "1z0j",\n        "1z0k",\n        "1z0l",\n      ]\n      var actual = Program().phoneNumberMnemonics(phoneNumber)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let phoneNumber = "1905"\n      let expected = [\n        "1w0j",\n        "1w0k",\n        "1w0l",\n        "1x0j",\n        "1x0k",\n        "1x0l",\n        "1y0j",\n        "1y0k",\n        "1y0l",\n        "1z0j",\n        "1z0k",\n        "1z0l",\n      ]\n      var actual = Program().phoneNumberMnemonics(phoneNumber)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function phoneNumberMnemonics(phoneNumber: string) {\n  // Write your code here.\n  return [phoneNumber];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nexport function phoneNumberMnemonics(phoneNumber: string) {\n  const currentMnemonic = new Array(phoneNumber.length).fill('0');\n  const mnemonicsFound: string[] = [];\n\n  phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n  return mnemonicsFound;\n}\n\nfunction phoneNumberMnemonicsHelper(\n  idx: number,\n  phoneNumber: string,\n  currentMnemonic: string[],\n  mnemonicsFound: string[],\n) {\n  if (idx === phoneNumber.length) {\n    const mnemonic = currentMnemonic.join('');\n    mnemonicsFound.push(mnemonic);\n  } else {\n    const digit = phoneNumber[idx];\n    const letters = DIGIT_LETTERS[digit];\n    for (const letter of letters) {\n      currentMnemonic[idx] = letter;\n      phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound);\n    }\n  }\n}\n\nconst DIGIT_LETTERS: {[digit: string]: string[]} = {\n  0: ['0'],\n  1: ['1'],\n  2: ['a', 'b', 'c'],\n  3: ['d', 'e', 'f'],\n  4: ['g', 'h', 'i'],\n  5: ['j', 'k', 'l'],\n  6: ['m', 'n', 'o'],\n  7: ['p', 'q', 'r', 's'],\n  8: ['t', 'u', 'v'],\n  9: ['w', 'x', 'y', 'z'],\n};\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = ['1w0j', '1w0k', '1w0l', '1x0j', '1x0k', '1x0l', '1y0j', '1y0k', '1y0l', '1z0j', '1z0k', '1z0l'];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = ['1w0j', '1w0k', '1w0l', '1x0j', '1x0k', '1x0l', '1y0j', '1y0k', '1y0l', '1z0j', '1z0k', '1z0l'];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "phoneNumber",
          example: "1905",
          schema: {
            minLength: 1,
            type: "string",
          },
        },
      ],
      tests: [
        {
          phoneNumber: "1905",
        },
        {
          phoneNumber: "1111",
        },
        {
          phoneNumber: "002",
        },
        {
          phoneNumber: "444",
        },
        {
          phoneNumber: "9056661234",
        },
        {
          phoneNumber: "4163420000",
        },
        {
          phoneNumber: "1",
        },
        {
          phoneNumber: "0",
        },
        {
          phoneNumber: "23",
        },
        {
          phoneNumber: "1212",
        },
        {
          phoneNumber: "97",
        },
        {
          phoneNumber: "980016",
        },
      ],
      jsonTests: [
        {
          phoneNumber: "1905",
        },
        {
          phoneNumber: "1111",
        },
        {
          phoneNumber: "002",
        },
        {
          phoneNumber: "444",
        },
        {
          phoneNumber: "9056661234",
        },
        {
          phoneNumber: "4163420000",
        },
        {
          phoneNumber: "1",
        },
        {
          phoneNumber: "0",
        },
        {
          phoneNumber: "23",
        },
        {
          phoneNumber: "1212",
        },
        {
          phoneNumber: "97",
        },
        {
          phoneNumber: "980016",
        },
      ],
      changelog: [],
      id: 23,
    },
    {
      uid: "index-equals-value",
      testStrategy: "JSON",
      name: "Index Equals Value",
      version: 0,
      releaseDate: "2020-11-16T00:00:00Z",
      category: "Searching",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 6210,
        failureCount: 2562,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "558316280",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1112,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a sorted array of distinct integers and returns\n  the first index in the array that is equal to the value at that index. In\n  other words, your function should return the minimum index where\n  <span>index == array[index]</span>.\n</p>\n<p>If there is no such index, your function should return <span>-1</span>.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [-5, -3, 0, 3, 4, 5, 9]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// 3 == array[3]</span>\n</pre>\n</div>',
      hints: [
        "<p>\nFirst think about a simple brute-force approach to solve this problem. What is the time complexity of this approach and what improvements could be made to this time complexity?\n</p>\n",
        "\n<p>\nIf the brute force solution runs in linear time complexity, then a better solution would have to run in O(log(n)) time. Which algorithm has an O(log(n)) time complexity?\n</p>\n",
        "\n<p>\nImplement a variation of binary search to solve this problem. Think about what conditions or checks must be added to search for the desired index-value pair.\n</p>\n",
        "\n<p>\nAs you perform a variation of binary search on the input array, if the value that you're looking at is smaller than its index, cut the left half of the array from the search space, because all values to the left will be smaller than their corresponding indices; this is guaranteed to be true, since left indices will naturally decrement by 1 each and left values will decrement by at least 1 each due to the array being sorted. Similar logic applies to the right side of the array when the value that you're looking at is greater than its index.\n</p>\n",
        "\n<p>\nWhen you encounter a value that's equal to its index, you'll have to perform some additional logic to make sure that you're not potentially missing other values in the array that are equal to their index and that come before the value that you're looking at.\n</p>",
      ],
      spaceTime:
        "O(log(n)) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint indexEqualsValue(vector<int> array) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(n) time | O(1) space - where n is the length of the input array\nint indexEqualsValue(vector<int> array) {\n  for (int i = 0; i < array.size(); i++) {\n    if (i == array[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint indexEqualsValueHelper(vector<int> &, int leftIndex, int rightIndex);\n\n// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nint indexEqualsValue(vector<int> array) {\n  return indexEqualsValueHelper(array, 0, array.size() - 1);\n}\n\nint indexEqualsValueHelper(vector<int> &array, int leftIndex, int rightIndex) {\n  if (leftIndex > rightIndex) {\n    return -1;\n  }\n\n  int middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\n  int middleValue = array[middleIndex];\n  if (middleValue < middleIndex) {\n    return indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n  } else if (middleValue == middleIndex && middleIndex == 0) {\n    return middleIndex;\n  } else if (middleValue == middleIndex &&\n             array[middleIndex - 1] < middleIndex - 1) {\n    return middleIndex;\n  } else {\n    return indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(log(n)) time | O(1) space - where n is the length of the input array\nint indexEqualsValue(vector<int> array) {\n  int leftIndex = 0;\n  int rightIndex = array.size() - 1;\n\n  while (leftIndex <= rightIndex) {\n    int middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\n    int middleValue = array[middleIndex];\n\n    if (middleValue < middleIndex) {\n      leftIndex = middleIndex + 1;\n    } else if (middleValue == middleIndex && middleIndex == 0) {\n      return middleIndex;\n    } else if (middleValue == middleIndex &&\n               array[middleIndex - 1] < middleIndex - 1) {\n      return middleIndex;\n    } else {\n      rightIndex = middleIndex - 1;\n    }\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {-5, -3, 0, 3, 4, 5, 9};\n      int expected = 3;\n      int actual = indexEqualsValue(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {-5, -3, 0, 3, 4, 5, 9};\n      int expected = 3;\n      int actual = indexEqualsValue(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\tpublic int IndexEqualsValue(int[] array) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(n) time | O(1) space - where n is the length of the input array\n\tpublic int IndexEqualsValue(int[] array) {\n\t\tfor (int index = 0; index < array.Length; index++) {\n\t\t\tint value = array[index];\n\t\t\tif (index == value) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(log(n)) time | O(log(n)) space - where n is the length of the input array\n\tpublic int IndexEqualsValue(int[] array) {\n\t\treturn indexEqualsValueHelper(array, 0, array.Length - 1);\n\t}\n\n\tpublic int indexEqualsValueHelper(int[] array, int leftIndex, int rightIndex) {\n\t\tif (leftIndex > rightIndex) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tint middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\n\t\tint middleValue = array[middleIndex];\n\n\t\tif (middleValue < middleIndex) {\n\t\t\treturn indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n\t\t} else if ((middleValue == middleIndex) && (middleIndex == 0)) {\n\t\t\treturn middleIndex;\n\t\t} else if ((middleValue == middleIndex) &&\n\t\t  (array[middleIndex - 1] < (middleIndex - 1))) {\n\t\t\treturn middleIndex;\n\t\t} else {\n\t\t\treturn indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n\t\t}\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// O(log(n)) time | O(1) space - where n is the length of the input array\n\tpublic int IndexEqualsValue(int[] array) {\n\t\tint leftIndex = 0;\n\t\tint rightIndex = array.Length - 1;\n\n\t\twhile (leftIndex <= rightIndex) {\n\t\t\tint middleIndex = rightIndex + (leftIndex - rightIndex) / 2;\n\t\t\tint middleValue = array[middleIndex];\n\n\t\t\tif (middleValue < middleIndex) {\n\t\t\t\tleftIndex = middleIndex + 1;\n\t\t\t} else if ((middleValue == middleIndex) && (middleIndex == 0)) {\n\t\t\t\treturn middleIndex;\n\t\t\t} else if ((middleValue == middleIndex) &&\n\t\t\t  (array[middleIndex - 1] < (middleIndex - 1))) {\n\t\t\t\treturn middleIndex;\n\t\t\t} else {\n\t\t\t\trightIndex = middleIndex - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(\n\t\t\tnew Program().IndexEqualsValue(new int[] {-5, -3, 0, 3, 4, 5, 9}) == 3);\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(\n\t\t\tnew Program().IndexEqualsValue(new int[] {-5, -3, 0, 3, 4, 5, 9}) == 3);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc IndexEqualsValue(array []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunc IndexEqualsValue(array []int) int {\n\tfor index, value := range array {\n\t\tif index == value {\n\t\t\treturn index\n\t\t}\n\t}\n\treturn -1\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nfunc IndexEqualsValue(array []int) int {\n\treturn indexEqualsValueHelper(array, 0, len(array)-1)\n}\n\nfunc indexEqualsValueHelper(array []int, leftIndex int, rightIndex int) int {\n\tif leftIndex > rightIndex {\n\t\treturn -1\n\t}\n\n\tmiddleIndex := leftIndex + (rightIndex-leftIndex)/2\n\tmiddleValue := array[middleIndex]\n\tif middleValue < middleIndex {\n\t\treturn indexEqualsValueHelper(array, middleIndex+1, rightIndex)\n\t} else if middleValue == middleIndex && middleIndex == 0 {\n\t\treturn middleIndex\n\t} else if middleValue == middleIndex && array[middleIndex-1] < middleIndex-1 {\n\t\treturn middleIndex\n\t} else {\n\t\treturn indexEqualsValueHelper(array, leftIndex, middleIndex-1)\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(1) space - where n is the length of the input array\nfunc IndexEqualsValue(array []int) int {\n\tleftIndex := 0\n\trightIndex := len(array) - 1\n\n\tfor leftIndex <= rightIndex {\n\t\tmiddleIndex := leftIndex + (rightIndex-leftIndex)/2\n\t\tmiddleValue := array[middleIndex]\n\n\t\tif middleValue < middleIndex {\n\t\t\tleftIndex = middleIndex + 1\n\t\t} else if middleValue == middleIndex && middleIndex == 0 {\n\t\t\treturn middleIndex\n\t\t} else if middleValue == middleIndex && array[middleIndex-1] < middleIndex-1 {\n\t\t\treturn middleIndex\n\t\t} else {\n\t\t\trightIndex = middleIndex - 1\n\t\t}\n\t}\n\treturn -1\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{-5, -3, 0, 3, 4, 5, 9}\n\texpected := 3\n\tactual := IndexEqualsValue(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{-5, -3, 0, 3, 4, 5, 9}\n\texpected := 3\n\tactual := IndexEqualsValue(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public int indexEqualsValue(int[] array) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n) time | O(1) space - where n is the length of the input array\n  public int indexEqualsValue(int[] array) {\n    for (int index = 0; index < array.length; index++) {\n      int value = array[index];\n      if (index == value) {\n        return index;\n      }\n    }\n\n    return -1;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(log(n)) time | O(log(n)) space - where n is the length of the input array\n  public int indexEqualsValue(int[] array) {\n    return indexEqualsValueHelper(array, 0, array.length - 1);\n  }\n\n  public int indexEqualsValueHelper(int[] array, int leftIndex, int rightIndex) {\n    if (leftIndex > rightIndex) {\n      return -1;\n    }\n\n    int middleIndex = leftIndex + (rightIndex - leftIndex) / 2;\n    int middleValue = array[middleIndex];\n\n    if (middleValue < middleIndex) {\n      return indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n    } else if ((middleValue == middleIndex) && (middleIndex == 0)) {\n      return middleIndex;\n    } else if ((middleValue == middleIndex) && (array[middleIndex - 1] < (middleIndex - 1))) {\n      return middleIndex;\n    } else {\n      return indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(log(n)) time | O(1) space - where n is the length of the input array\n  public int indexEqualsValue(int[] array) {\n    int leftIndex = 0;\n    int rightIndex = array.length - 1;\n\n    while (leftIndex <= rightIndex) {\n      int middleIndex = rightIndex + (leftIndex - rightIndex) / 2;\n      int middleValue = array[middleIndex];\n\n      if (middleValue < middleIndex) {\n        leftIndex = middleIndex + 1;\n      } else if ((middleValue == middleIndex) && (middleIndex == 0)) {\n        return middleIndex;\n      } else if ((middleValue == middleIndex) && (array[middleIndex - 1] < (middleIndex - 1))) {\n        return middleIndex;\n      } else {\n        rightIndex = middleIndex - 1;\n      }\n    }\n\n    return -1;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(new Program().indexEqualsValue(new int[] {-5, -3, 0, 3, 4, 5, 9}) == 3);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(new Program().indexEqualsValue(new int[] {-5, -3, 0, 3, 4, 5, 9}) == 3);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function indexEqualsValue(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.indexEqualsValue = indexEqualsValue;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  for (let index = 0; index < array.length; index++) {\n    const value = array[index];\n    if (index === value) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  return indexEqualsValueHelper(array, 0, array.length - 1);\n}\n\nfunction indexEqualsValueHelper(array, leftIndex, rightIndex) {\n  if (leftIndex > rightIndex) return -1;\n\n  const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n  const middleValue = array[middleIndex];\n\n  if (middleValue < middleIndex) {\n    return indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n  } else if (middleValue === middleIndex && middleIndex === 0) {\n    return middleIndex;\n  } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n    return middleIndex;\n  } else {\n    return indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n  }\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  let leftIndex = 0;\n  let rightIndex = array.length - 1;\n\n  while (leftIndex <= rightIndex) {\n    const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n    const middleValue = array[middleIndex];\n\n    if (middleValue < middleIndex) {\n      leftIndex = middleIndex + 1;\n    } else if (middleValue === middleIndex && middleIndex === 0) {\n      return middleIndex;\n    } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n      return middleIndex;\n    } else {\n      rightIndex = middleIndex - 1;\n    }\n  }\n\n  return -1;\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun indexEqualsValue(array: List<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(1) space - where n is the length of the input array\nfun indexEqualsValue(array: List<Int>): Int {\n    for (index in 0 until array.size) {\n        val value = array[index]\n        if (index == value) return index\n    }\n    return -1\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nfun indexEqualsValue(array: List<Int>): Int {\n    return indexEqualsValueHelper(array, 0, array.size - 1)\n}\n\nfun indexEqualsValueHelper(array: List<Int>, leftIndex: Int, rightIndex: Int): Int {\n\tif (leftIndex > rightIndex) return -1\n\n\tval middleIndex = leftIndex + (rightIndex - leftIndex) / 2\n\tval middleValue = array[middleIndex]\n\n\tif (middleValue < middleIndex) {\n\t\treturn indexEqualsValueHelper(array, middleIndex + 1, rightIndex)\n    } else if (middleValue == middleIndex && middleIndex == 0) {\n\t\treturn middleIndex\n    } else if (middleValue == middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n\t\treturn middleIndex\n    } else {\n\t\treturn indexEqualsValueHelper(array, leftIndex, middleIndex - 1)\n    }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(1) space - where n is the length of the input array\nfun indexEqualsValue(array: List<Int>): Int {\n    var leftIndex = 0\n    var rightIndex = array.size - 1\n\n    while (leftIndex <= rightIndex) {\n        val middleIndex = leftIndex + (rightIndex - leftIndex) / 2\n        val middleValue = array[middleIndex]\n\n        if (middleValue < middleIndex) {\n            leftIndex = middleIndex + 1\n        } else if (middleValue == middleIndex && middleIndex == 0) {\n            return middleIndex\n        } else if (middleValue == middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n            return middleIndex\n        } else {\n            rightIndex = middleIndex - 1\n        }\n    }\n\n    return -1\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.indexEqualsValue\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(-5, -3, 0, 3, 4, 5, 9)\n        val expected = 3\n        val output = indexEqualsValue(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.indexEqualsValue\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(-5, -3, 0, 3, 4, 5, 9)\n        val expected = 3\n        val output = indexEqualsValue(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def indexEqualsValue(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space - where n is the length of the input array\ndef indexEqualsValue(array):\n    for index in range(len(array)):\n        value = array[index]\n        if index == value:\n            return index\n\n    return -1\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(log(n)) space - where n is the length of the input array\ndef indexEqualsValue(array):\n    return indexEqualsValueHelper(array, 0, len(array) - 1)\n\n\ndef indexEqualsValueHelper(array, leftIndex, rightIndex):\n    if leftIndex > rightIndex:\n        return -1\n\n    middleIndex = leftIndex + (rightIndex - leftIndex) // 2\n    middleValue = array[middleIndex]\n\n    if middleValue < middleIndex:\n        return indexEqualsValueHelper(array, middleIndex + 1, rightIndex)\n    elif middleValue == middleIndex and middleIndex == 0:\n        return middleIndex\n    elif middleValue == middleIndex and array[middleIndex - 1] < middleIndex - 1:\n        return middleIndex\n    else:\n        return indexEqualsValueHelper(array, leftIndex, middleIndex - 1)\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(1) space - where n is the length of the input array\ndef indexEqualsValue(array):\n    leftIndex = 0\n    rightIndex = len(array) - 1\n\n    while leftIndex <= rightIndex:\n        middleIndex = leftIndex + (rightIndex - leftIndex) // 2\n        middleValue = array[middleIndex]\n\n        if middleValue < middleIndex:\n            leftIndex = middleIndex + 1\n        elif middleValue == middleIndex and middleIndex == 0:\n            return middleIndex\n        elif middleValue == middleIndex and array[middleIndex - 1] < middleIndex - 1:\n            return middleIndex\n        else:\n            rightIndex = middleIndex - 1\n\n    return -1\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [-5, -3, 0, 3, 4, 5, 9]\n        expected = 3\n        actual = program.indexEqualsValue(array)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [-5, -3, 0, 3, 4, 5, 9]\n        expected = 3\n        actual = program.indexEqualsValue(array)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def indexEqualsValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def indexEqualsValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def indexEqualsValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def indexEqualsValue(array)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.indexEqualsValue\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.indexEqualsValue\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func indexEqualsValue(_ array: [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space - where n is the length of the input array\n  func indexEqualsValue(_ array: [Int]) -> Int {\n    for (index, value) in array.enumerated() {\n      if index == value {\n        return index\n      }\n    }\n    return -1\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(log(n)) space - where n is the length of the input array\n  func indexEqualsValue(_ array: [Int]) -> Int {\n    return indexEqualsValueHelper(array, 0, array.count - 1)\n  }\n\n  func indexEqualsValueHelper(_ array: [Int], _ leftIndex: Int, _ rightIndex: Int) -> Int {\n    if leftIndex > rightIndex {\n      return -1\n    }\n\n    var middleIndex = leftIndex + (rightIndex - leftIndex) / 2\n    var middleValue = array[middleIndex]\n    if middleValue < middleIndex {\n      return indexEqualsValueHelper(array, middleIndex + 1, rightIndex)\n    } else if middleValue == middleIndex, middleIndex == 0 {\n      return middleIndex\n    } else if middleValue == middleIndex, array[middleIndex - 1] < middleIndex - 1 {\n      return middleIndex\n    } else {\n      return indexEqualsValueHelper(array, leftIndex, middleIndex - 1)\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(1) space - where n is the length of the input array\n  func indexEqualsValue(_ array: [Int]) -> Int {\n    var leftIndex = 0\n    var rightIndex = array.count - 1\n\n    while leftIndex <= rightIndex {\n      var middleIndex = leftIndex + (rightIndex - leftIndex) / 2\n      var middleValue = array[middleIndex]\n\n      if middleValue < middleIndex {\n        leftIndex = middleIndex + 1\n      } else if middleValue == middleIndex, middleIndex == 0 {\n        return middleIndex\n      } else if middleValue == middleIndex, array[middleIndex - 1] < middleIndex - 1 {\n        return middleIndex\n      } else {\n        rightIndex = middleIndex - 1\n      }\n    }\n    return -1\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [-5, -3, 0, 3, 4, 5, 9]\n      var expected = 3\n      var actual = Program().indexEqualsValue(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [-5, -3, 0, 3, 4, 5, 9]\n      var expected = 3\n      var actual = Program().indexEqualsValue(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function indexEqualsValue(array: number[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space - where n is the length of the input array\nexport function indexEqualsValue(array: number[]) {\n  for (let index = 0; index < array.length; index++) {\n    const value = array[index];\n    if (index === value) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nexport function indexEqualsValue(array: number[]) {\n  return indexEqualsValueHelper(array, 0, array.length - 1);\n}\n\nfunction indexEqualsValueHelper(array: number[], leftIndex: number, rightIndex: number): number {\n  if (leftIndex > rightIndex) return -1;\n\n  const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n  const middleValue = array[middleIndex];\n\n  if (middleValue < middleIndex) {\n    return indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n  } else if (middleValue === middleIndex && middleIndex === 0) {\n    return middleIndex;\n  } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n    return middleIndex;\n  } else {\n    return indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space - where n is the length of the input array\nexport function indexEqualsValue(array: number[]) {\n  let leftIndex = 0;\n  let rightIndex = array.length - 1;\n\n  while (leftIndex <= rightIndex) {\n    const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n    const middleValue = array[middleIndex];\n\n    if (middleValue < middleIndex) {\n      leftIndex = middleIndex + 1;\n    } else if (middleValue === middleIndex && middleIndex === 0) {\n      return middleIndex;\n    } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n      return middleIndex;\n    } else {\n      rightIndex = middleIndex - 1;\n    }\n  }\n\n  return -1;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [-5, -3, 0, 3, 4, 5, 9],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
            uniqueItems: true,
          },
        },
      ],
      tests: [
        {
          array: [-5, -3, 0, 3, 4, 5, 9],
        },
        {
          array: [-12, 1, 2, 3, 12],
        },
        {
          array: [-5, -4, -3, -2, -1, 0, 1, 3, 5, 6, 7, 11, 12, 14, 19, 20],
        },
        {
          array: [-3, -1, 1, 3, 5, 7, 9],
        },
        {
          array: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
        },
        {
          array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [0],
        },
        {
          array: [0, 1],
        },
        {
          array: [1, 2],
        },
        {
          array: [-50, 1, 2, 3, 4],
        },
        {
          array: [-40, -20, 0, 2, 4, 6, 8, 10],
        },
        {
          array: [-1000, 0, 1, 5000, 5001, 5002, 5005],
        },
        {
          array: [-1000, 0, 1, 2, 3, 4, 6, 5000, 5001, 5002, 5005],
        },
        {
          array: [-999, 0, 2, 500, 1000, 1500, 2000, 2500, 3000, 3500],
        },
        {
          array: [
            -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 18,
          ],
        },
        {
          array: [],
        },
      ],
      jsonTests: [
        {
          array: [-5, -3, 0, 3, 4, 5, 9],
        },
        {
          array: [-12, 1, 2, 3, 12],
        },
        {
          array: [-5, -4, -3, -2, -1, 0, 1, 3, 5, 6, 7, 11, 12, 14, 19, 20],
        },
        {
          array: [-3, -1, 1, 3, 5, 7, 9],
        },
        {
          array: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
        },
        {
          array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        },
        {
          array: [0],
        },
        {
          array: [0, 1],
        },
        {
          array: [1, 2],
        },
        {
          array: [-50, 1, 2, 3, 4],
        },
        {
          array: [-40, -20, 0, 2, 4, 6, 8, 10],
        },
        {
          array: [-1000, 0, 1, 5000, 5001, 5002, 5005],
        },
        {
          array: [-1000, 0, 1, 2, 3, 4, 6, 5000, 5001, 5002, 5005],
        },
        {
          array: [-999, 0, 2, 500, 1000, 1500, 2000, 2500, 3000, 3500],
        },
        {
          array: [
            -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 18,
          ],
        },
        {
          array: [],
        },
      ],
      changelog: [],
      id: 24,
    },
    {
      uid: "shifted-binary-search",
      testStrategy: "JSON",
      name: "Shifted Binary Search",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Searching",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 9251,
        failureCount: 3414,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226676392",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1100,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a sorted array of distinct integers as well as a target\n  integer. The caveat is that the integers in the array have been shifted by\n  some amount; in other words, they\'ve been moved to the left or to the right by\n  one or more positions. For example, <span>[1, 2, 3, 4]</span> might have\n  turned into <span>[3, 4, 1, 2]</span>.\n</p>\n<p>\n  The function should use a variation of the Binary Search algorithm to\n  determine if the target integer is contained in the array and should return\n  its index if it is, otherwise <span>-1</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Binary Search, we recommend watching the Conceptual\n  Overview section of the Binary Search question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [45, 61, 71, 72, 73, 0, 1, 21, 33, 37]\n<span class="CodeEditor-promptParameter">target</span> = 33\n</pre>\n<h3>Sample Output</h3>\n<pre>8</pre>\n</div>',
      hints: [
        "<p>\nThe Binary Search algorithm involves a left pointer and a right pointer and using those pointers to find the middle number in an array. Unlike with a normal sorted array however, you cannot simply find the middle number of the array and compare it to the target here, because the shift could lead you in the wrong direction. Instead, realize that whenever you find the middle number in the array, the following two scenarios are possible (assuming the middle number is not equal to the target number, in which case you're done): either the left-pointer number is smaller than or equal to the middle number, or it is bigger. Figure out a way to eliminate half of the array depending on the scenario.\n</p>\n",
        "\n<p>\nIn the scenario where the left-pointer number is smaller than or equal to the middle number, two other scenarios can arise: either the target number is smaller than the middle number and greater than or equal to the left-pointer number, or it's not. In the first scenario, the right half of the array can be eliminated; in the second scenario, the left half can be eliminated. Figure out the scenarios that can arise if the left-pointer number is greater than the middle number and apply whatever logic you come up with recursively until you find the target number or until you run out of numbers in the array.\n</p>\n",
        "\n<p>\nCan you implement this algorithm iteratively? Are there any advantages to doing so?\n</p>",
      ],
      spaceTime:
        "O(log(n)) time | O(1) space - where n is the length of the input array",
      notes:
        '<div class="html">\n<p>\n  The numbers in the input array must be distinct in order for this algorithm to\n  work all the time. The sample array in the video, which has a repeated\n  <span>45</span>, happens to work fine, but this is an exception—not the rule.\n</p>\n<p>\n  To understand why the numbers must be distinct, consider the following inputs:\n</p>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [45, 33, 45, 45, 45]\n<span class="CodeEditor-promptParameter">target</span> = 33\n</pre>\n<p>\n  With these inputs, our first binary-search step would have the following\n  indices:\n</p>\n<pre>\n<span class="CodeEditor-promptParameter">leftIdx</span> = 0 <span class="CodeEditor-promptComment">// 45</span>\n<span class="CodeEditor-promptParameter">middleIdx</span> = 2 <span class="CodeEditor-promptComment">// 45</span>\n<span class="CodeEditor-promptParameter">rightIdx</span> = 4 <span class="CodeEditor-promptComment">// 45</span>\n</pre>\n<p>\n  We would then compare the left <span>45</span> to the middle\n  <span>45</span> and conclude that the left half of the array was sorted, since\n  <span>45 <= 45</span>.\n</p>\n<p>\n  This would be incorrect, since the left subarray\n  <span>[45, 33, 45]</span> clearly isn\'t sorted.\n</p>\n<p>\n  This would lead our algorithm down the wrong path, and our function would end\n  up returning <span>-1</span>, which would be incorrect.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint shiftedBinarySearch(vector<int> array, int target) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint shiftedBinarySearch(vector<int> array, int target);\nint shiftedBinarySearchHelper(vector<int> array, int target, int left,\n                              int right);\n\n// O(log(n)) time | O(log(n)) space\nint shiftedBinarySearch(vector<int> array, int target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.size() - 1);\n}\n\nint shiftedBinarySearchHelper(vector<int> array, int target, int left,\n                              int right) {\n  if (left > right) {\n    return -1;\n  }\n  int middle = (left + right) / 2;\n  int potentialMatch = array[middle];\n  int leftNum = array[left];\n  int rightNum = array[right];\n  if (target == potentialMatch) {\n    return middle;\n  } else if (leftNum <= potentialMatch) {\n    if (target < potentialMatch && target >= leftNum) {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    } else {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    }\n  } else {\n    if (target > potentialMatch && target <= rightNum) {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    } else {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint shiftedBinarySearch(vector<int> array, int target);\nint shiftedBinarySearchHelper(vector<int> array, int target, int left,\n                              int right);\n\n// O(log(n)) time | O(1) space\nint shiftedBinarySearch(vector<int> array, int target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.size() - 1);\n}\n\nint shiftedBinarySearchHelper(vector<int> array, int target, int left,\n                              int right) {\n  while (left <= right) {\n    int middle = (left + right) / 2;\n    int potentialMatch = array[middle];\n    int leftNum = array[left];\n    int rightNum = array[right];\n    if (target == potentialMatch) {\n      return middle;\n    } else if (leftNum <= potentialMatch) {\n      if (target < potentialMatch && target >= leftNum) {\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    } else {\n      if (target > potentialMatch && target <= rightNum) {\n        left = middle + 1;\n      } else {\n        right = middle - 1;\n      }\n    }\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(shiftedBinarySearch({45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33) ==\n             8);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(shiftedBinarySearch({45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33) ==\n             8);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int ShiftedBinarySearch(int[] array, int target) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(log(n)) time | O(log(n)) space\n\tpublic static int ShiftedBinarySearch(int[] array, int target) {\n\t\treturn ShiftedBinarySearch(array, target, 0, array.Length - 1);\n\t}\n\n\tpublic static int ShiftedBinarySearch(int[] array, int target, int left, int right) {\n\t\tif (left > right) {\n\t\t\treturn -1;\n\t\t}\n\t\tint middle = (left + right) / 2;\n\t\tint potentialMatch = array[middle];\n\t\tint leftNum = array[left];\n\t\tint rightNum = array[right];\n\t\tif (target == potentialMatch) {\n\t\t\treturn middle;\n\t\t} else if (leftNum <= potentialMatch) {\n\t\t\tif (target < potentialMatch && target >= leftNum) {\n\t\t\t\treturn ShiftedBinarySearch(array, target, left, middle - 1);\n\t\t\t} else {\n\t\t\t\treturn ShiftedBinarySearch(array, target, middle + 1, right);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target > potentialMatch && target <= rightNum) {\n\t\t\t\treturn ShiftedBinarySearch(array, target, middle + 1, right);\n\t\t\t} else {\n\t\t\t\treturn ShiftedBinarySearch(array, target, left, middle - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(log(n)) time | O(1) space\n\tpublic static int ShiftedBinarySearch(int[] array, int target) {\n\t\treturn ShiftedBinarySearch(array, target, 0, array.Length - 1);\n\t}\n\n\tpublic static int ShiftedBinarySearch(int[] array, int target, int left, int right) {\n\t\twhile (left <= right) {\n\t\t\tint middle = (left + right) / 2;\n\t\t\tint potentialMatch = array[middle];\n\t\t\tint leftNum = array[left];\n\t\t\tint rightNum = array[right];\n\t\t\tif (target == potentialMatch) {\n\t\t\t\treturn middle;\n\t\t\t} else if (leftNum <= potentialMatch) {\n\t\t\t\tif (target < potentialMatch && target >= leftNum) {\n\t\t\t\t\tright = middle - 1;\n\t\t\t\t} else {\n\t\t\t\t\tleft = middle + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (target > potentialMatch && target <= rightNum) {\n\t\t\t\t\tleft = middle + 1;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.ShiftedBinarySearch(new int[] {45, 61, 71, 72, 73, 0, 1,\n\t\t                                                        21, 33, 37}, 33) == 8);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.ShiftedBinarySearch(new int[] {45, 61, 71, 72, 73, 0, 1,\n\t\t                                                        21, 33, 37}, 33) == 8);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc ShiftedBinarySearch(array []int, target int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(log(n)) space\nfunc ShiftedBinarySearch(array []int, target int) int {\n\treturn helper(array, target, 0, len(array)-1)\n}\n\nfunc helper(array []int, target int, left int, right int) int {\n\tif left > right {\n\t\treturn -1\n\t}\n\tmiddle := (left + right) / 2\n\tpotentialMatch := array[middle]\n\tleftNum, rightNum := array[left], array[right]\n\tnewleft, newright := middle+1, right\n\tif target == potentialMatch {\n\t\treturn middle\n\t} else if leftNum <= potentialMatch {\n\t\tif target < potentialMatch && target >= leftNum {\n\t\t\tnewleft, newright = left, middle-1\n\t\t}\n\t} else {\n\t\tif !(target > potentialMatch && target <= rightNum) {\n\t\t\tnewleft, newright = left, middle-1\n\t\t}\n\t}\n\treturn helper(array, target, newleft, newright)\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(1) space\nfunc ShiftedBinarySearch(array []int, target int) int {\n\treturn helper(array, target, 0, len(array)-1)\n}\n\nfunc helper(array []int, target int, left int, right int) int {\n\tfor left <= right {\n\t\tmiddle := (left + right) / 2\n\t\tpotentialMatch := array[middle]\n\t\tleftnum, rightnum := array[left], array[right]\n\t\tif target == potentialMatch {\n\t\t\treturn middle\n\t\t} else if leftnum <= potentialMatch {\n\t\t\tif target < potentialMatch && target >= leftnum {\n\t\t\t\tright = middle - 1\n\t\t\t} else {\n\t\t\t\tleft = middle + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif target > potentialMatch && target <= rightnum {\n\t\t\t\tleft = middle + 1\n\t\t\t} else {\n\t\t\t\tright = middle - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 8\n\toutput := ShiftedBinarySearch([]int{45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 8\n\toutput := ShiftedBinarySearch([]int{45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int shiftedBinarySearch(int[] array, int target) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(log(n)) space\n  public static int shiftedBinarySearch(int[] array, int target) {\n    return shiftedBinarySearch(array, target, 0, array.length - 1);\n  }\n\n  public static int shiftedBinarySearch(int[] array, int target, int left, int right) {\n    if (left > right) {\n      return -1;\n    }\n    int middle = (left + right) / 2;\n    int potentialMatch = array[middle];\n    int leftNum = array[left];\n    int rightNum = array[right];\n    if (target == potentialMatch) {\n      return middle;\n    } else if (leftNum <= potentialMatch) {\n      if (target < potentialMatch && target >= leftNum) {\n        return shiftedBinarySearch(array, target, left, middle - 1);\n      } else {\n        return shiftedBinarySearch(array, target, middle + 1, right);\n      }\n    } else {\n      if (target > potentialMatch && target <= rightNum) {\n        return shiftedBinarySearch(array, target, middle + 1, right);\n      } else {\n        return shiftedBinarySearch(array, target, left, middle - 1);\n      }\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(1) space\n  public static int shiftedBinarySearch(int[] array, int target) {\n    return shiftedBinarySearch(array, target, 0, array.length - 1);\n  }\n\n  public static int shiftedBinarySearch(int[] array, int target, int left, int right) {\n    while (left <= right) {\n      int middle = (left + right) / 2;\n      int potentialMatch = array[middle];\n      int leftNum = array[left];\n      int rightNum = array[right];\n      if (target == potentialMatch) {\n        return middle;\n      } else if (leftNum <= potentialMatch) {\n        if (target < potentialMatch && target >= leftNum) {\n          right = middle - 1;\n        } else {\n          left = middle + 1;\n        }\n      } else {\n        if (target > potentialMatch && target <= rightNum) {\n          left = middle + 1;\n        } else {\n          right = middle - 1;\n        }\n      }\n    }\n    return -1;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.shiftedBinarySearch(new int[] {45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33) == 8);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.shiftedBinarySearch(new int[] {45, 61, 71, 72, 73, 0, 1, 21, 33, 37}, 33) == 8);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function shiftedBinarySearch(array, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.shiftedBinarySearch = shiftedBinarySearch;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space\nfunction shiftedBinarySearch(array, target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array, target, left, right) {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  const leftNum = array[left];\n  const rightNum = array[right];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (leftNum <= potentialMatch) {\n    if (target < potentialMatch && target >= leftNum) {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    } else {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    }\n  } else {\n    if (target > potentialMatch && target <= rightNum) {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    } else {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    }\n  }\n}\n\nexports.shiftedBinarySearch = shiftedBinarySearch;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space\nfunction shiftedBinarySearch(array, target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array, target, left, right) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    const leftNum = array[left];\n    const rightNum = array[right];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (leftNum <= potentialMatch) {\n      if (target < potentialMatch && target >= leftNum) {\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    } else {\n      if (target > potentialMatch && target <= rightNum) {\n        left = middle + 1;\n      } else {\n        right = middle - 1;\n      }\n    }\n  }\n  return -1;\n}\n\nexports.shiftedBinarySearch = shiftedBinarySearch;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33)).to.deep.equal(8);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33)).to.deep.equal(8);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun shiftedBinarySearch(array: List<Int>, target: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(log(n)) space\nfun shiftedBinarySearch(array: List<Int>, target: Int): Int {\n    return shiftedBinarySearch(array, target, 0, array.size - 1)\n}\n\nfun shiftedBinarySearch(array: List<Int>, target: Int, left: Int, right: Int): Int {\n    if (left > right) {\n        return -1\n    }\n    val middle = (left + right) / 2\n    val potentialMatch = array[middle]\n    val leftNum = array[left]\n    val rightNum = array[right]\n    if (target == potentialMatch) {\n        return middle\n    } else if (leftNum <= potentialMatch) {\n        if (target < potentialMatch && target >= leftNum) {\n            return shiftedBinarySearch(array, target, left, middle - 1)\n        } else {\n            return shiftedBinarySearch(array, target, middle + 1, right)\n        }\n    } else {\n        if (target > potentialMatch && target <= rightNum) {\n            return shiftedBinarySearch(array, target, middle + 1, right)\n        } else {\n            return shiftedBinarySearch(array, target, left, middle - 1)\n        }\n    }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(1) space\nfun shiftedBinarySearch(array: List<Int>, target: Int): Int {\n    return shiftedBinarySearch(array, target, 0, array.size - 1)\n}\n\nfun shiftedBinarySearch(array: List<Int>, target: Int, leftStart: Int, rightStart: Int): Int {\n    var left = leftStart\n    var right = rightStart\n    while (left <= right) {\n        val middle = (left + right) / 2\n        val potentialMatch = array[middle]\n        val leftNum = array[left]\n        val rightNum = array[right]\n        if (target == potentialMatch) {\n            return middle\n        } else if (leftNum <= potentialMatch) {\n            if (target < potentialMatch && target >= leftNum) {\n                right = middle - 1\n            } else {\n                left = middle + 1\n            }\n        } else {\n            if (target > potentialMatch && target <= rightNum) {\n                left = middle + 1\n            } else {\n                right = middle - 1\n            }\n        }\n    }\n    return -1\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.shiftedBinarySearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(45, 61, 71, 72, 73, 0, 1, 21, 33, 37)\n        assert(shiftedBinarySearch(input, 33) == 8)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.shiftedBinarySearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(45, 61, 71, 72, 73, 0, 1, 21, 33, 37)\n        assert(shiftedBinarySearch(input, 33) == 8)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def shiftedBinarySearch(array, target):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(log(n)) space\ndef shiftedBinarySearch(array, target):\n    return shiftedBinarySearchHelper(array, target, 0, len(array) - 1)\n\n\ndef shiftedBinarySearchHelper(array, target, left, right):\n    if left > right:\n        return -1\n    middle = (left + right) // 2\n    potentialMatch = array[middle]\n    leftNum = array[left]\n    rightNum = array[right]\n    if target == potentialMatch:\n        return middle\n    elif leftNum <= potentialMatch:\n        if target < potentialMatch and target >= leftNum:\n            return shiftedBinarySearchHelper(array, target, left, middle - 1)\n        else:\n            return shiftedBinarySearchHelper(array, target, middle + 1, right)\n    else:\n        if target > potentialMatch and target <= rightNum:\n            return shiftedBinarySearchHelper(array, target, middle + 1, right)\n        else:\n            return shiftedBinarySearchHelper(array, target, left, middle - 1)\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(1) space\ndef shiftedBinarySearch(array, target):\n    return shiftedBinarySearchHelper(array, target, 0, len(array) - 1)\n\n\ndef shiftedBinarySearchHelper(array, target, left, right):\n    while left <= right:\n        middle = (left + right) // 2\n        potentialMatch = array[middle]\n        leftNum = array[left]\n        rightNum = array[right]\n        if target == potentialMatch:\n            return middle\n        elif leftNum <= potentialMatch:\n            if target < potentialMatch and target >= leftNum:\n                right = middle - 1\n            else:\n                left = middle + 1\n        else:\n            if target > potentialMatch and target <= rightNum:\n                left = middle + 1\n            else:\n                right = middle - 1\n    return -1\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33), 8)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33), 8)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def shiftedBinarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def shiftedBinarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def shiftedBinarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.shiftedBinarySearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.shiftedBinarySearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func shiftedBinarySearch(_ array: [Int], _ target: Int) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(log(n)) space\n  func shiftedBinarySearch(_ array: [Int], _ target: Int) -> Int {\n    return shiftedBinarySearchHelper(array, target, 0, array.count - 1)\n  }\n\n  func shiftedBinarySearchHelper(_ array: [Int], _ target: Int, _ leftPointer: Int, _ rightPointer: Int) -> Int {\n    if leftPointer > rightPointer {\n      return -1\n    }\n\n    let middle = (leftPointer + rightPointer) / 2\n    let potentialMatch = array[middle]\n    let leftNumber = array[leftPointer]\n    let rightNumber = array[rightPointer]\n\n    if target == potentialMatch {\n      return middle\n    } else if leftNumber < potentialMatch {\n      if target < potentialMatch, target >= leftNumber {\n        return shiftedBinarySearchHelper(array, target, leftPointer, middle - 1)\n      } else {\n        return shiftedBinarySearchHelper(array, target, middle + 1, rightPointer)\n      }\n    } else {\n      if target <= rightNumber, target > potentialMatch {\n        return shiftedBinarySearchHelper(array, target, middle + 1, rightPointer)\n      } else {\n        return shiftedBinarySearchHelper(array, target, leftPointer, middle - 1)\n      }\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(1) space\n  func shiftedBinarySearch(_ array: [Int], _ target: Int) -> Int {\n    var leftPointer = 0\n    var rightPointer = array.count - 1\n\n    return shiftedBinarySearchHelper(array, target, &leftPointer, &rightPointer)\n  }\n\n  func shiftedBinarySearchHelper(_ array: [Int], _ target: Int, _ leftPointer: inout Int, _ rightPointer: inout Int) -> Int {\n    while leftPointer <= rightPointer {\n      let middle = (leftPointer + rightPointer) / 2\n      let potentialMatch = array[middle]\n      let leftNumber = array[leftPointer]\n      let rightNumber = array[rightPointer]\n\n      if target == potentialMatch {\n        return middle\n      } else if leftNumber < potentialMatch {\n        if target < potentialMatch, target >= leftNumber {\n          rightPointer = middle - 1\n        } else {\n          leftPointer = middle + 1\n        }\n      } else {\n        if target <= rightNumber, target > potentialMatch {\n          leftPointer = middle + 1\n        } else {\n          rightPointer = middle - 1\n        }\n      }\n    }\n\n    return -1\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(8, program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(8, program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function shiftedBinarySearch(array: number[], target: number) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space\nexport function shiftedBinarySearch(array: number[], target: number) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array: number[], target: number, left: number, right: number): number {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  const leftNum = array[left];\n  const rightNum = array[right];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (leftNum <= potentialMatch) {\n    if (target < potentialMatch && target >= leftNum) {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    } else {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    }\n  } else {\n    if (target > potentialMatch && target <= rightNum) {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    } else {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space\nexport function shiftedBinarySearch(array: number[], target: number) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array: number[], target: number, left: number, right: number) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    const leftNum = array[left];\n    const rightNum = array[right];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (leftNum <= potentialMatch) {\n      if (target < potentialMatch && target >= leftNum) {\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    } else {\n      if (target > potentialMatch && target <= rightNum) {\n        left = middle + 1;\n      } else {\n        right = middle - 1;\n      }\n    }\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33)).to.deep.equal(8);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33)).to.deep.equal(8);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
            uniqueItems: true,
          },
        },
        {
          name: "target",
          example: 33,
          schema: {
            type: "integer",
          },
        },
      ],
      tests: [
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 33,
        },
        {
          array: [5, 23, 111, 1],
          target: 111,
        },
        {
          array: [111, 1, 5, 23],
          target: 5,
        },
        {
          array: [23, 111, 1, 5],
          target: 35,
        },
        {
          array: [61, 71, 72, 73, 0, 1, 21, 33, 37, 45],
          target: 33,
        },
        {
          array: [72, 73, 0, 1, 21, 33, 37, 45, 61, 71],
          target: 72,
        },
        {
          array: [71, 72, 73, 0, 1, 21, 33, 37, 45, 61],
          target: 73,
        },
        {
          array: [73, 0, 1, 21, 33, 37, 45, 61, 71, 72],
          target: 70,
        },
        {
          array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21],
          target: 355,
        },
        {
          array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21],
          target: 354,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 45,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 61,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 71,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 72,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 73,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 0,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 1,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 21,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 37,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 38,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 0,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 1,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 21,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 33,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 37,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 45,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 61,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 71,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 72,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 73,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 38,
        },
      ],
      jsonTests: [
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 33,
        },
        {
          array: [5, 23, 111, 1],
          target: 111,
        },
        {
          array: [111, 1, 5, 23],
          target: 5,
        },
        {
          array: [23, 111, 1, 5],
          target: 35,
        },
        {
          array: [61, 71, 72, 73, 0, 1, 21, 33, 37, 45],
          target: 33,
        },
        {
          array: [72, 73, 0, 1, 21, 33, 37, 45, 61, 71],
          target: 72,
        },
        {
          array: [71, 72, 73, 0, 1, 21, 33, 37, 45, 61],
          target: 73,
        },
        {
          array: [73, 0, 1, 21, 33, 37, 45, 61, 71, 72],
          target: 70,
        },
        {
          array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21],
          target: 355,
        },
        {
          array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21],
          target: 354,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 45,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 61,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 71,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 72,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 73,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 0,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 1,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 21,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 37,
        },
        {
          array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
          target: 38,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 0,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 1,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 21,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 33,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 37,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 45,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 61,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 71,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 72,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 73,
        },
        {
          array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73],
          target: 38,
        },
      ],
      changelog: [],
      id: 25,
    },
    {
      uid: "ambiguous-measurements",
      testStrategy: "JSON",
      name: "Ambiguous Measurements",
      version: 0,
      releaseDate: "2021-04-01T00:00:00Z",
      category: "Recursion",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 1850,
        failureCount: 637,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "524804264",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 2117,
      },
      prompt:
        '<div class="html">\n<p>\n  This problem deals with measuring cups that are missing important measuring\n  labels. Specifically, a measuring cup only has two measuring lines, a Low (L)\n  line and a High (H) line. This means that these cups can\'t precisely measure\n  and can only guarantee that the substance poured into them will be between the\n  L and H line. For example, you might have a measuring cup that has a Low line\n  at <span>400ml</span> and a high line at <span>435ml</span>. This means that\n  when you use this measuring cup, you can only be sure that what you\'re\n  measuring is between <span>400ml</span> and <span>435ml</span>.\n</p>\n<p>\n  You\'re given a list of measuring cups containing their low and high lines as\n  well as one <span>low</span> integer and one <span>high</span> integer\n  representing a range for a target measurement. Write a function that returns a\n  boolean representing whether you can use the cups to accurately measure a\n  volume in the specified <span>[low, high]</span> range (the range is\n  inclusive).\n</p>\n<p>Note that:</p>\n<ul>\n  <li>\n    Each measuring cup will be represented by a pair of positive integers\n    <span>[L, H]</span>, where <span>0 &lt;= L &lt;= H</span>.\n  </li>\n  <li>\n    You\'ll always be given at least one measuring cup, and the\n    <span>low</span> and <span>high</span> input parameters will always satisfy\n    the following constraint: <span>0 &lt;= low &lt;= high</span>.\n  </li>\n  <li>\n    Once you\'ve measured some liquid, it will immediately be transferred to a\n    larger bowl that will eventually (possibly) contain the target measurement.\n  </li>\n  <li>You can\'t pour the contents of one measuring cup into another cup.</li>\n</ul>\n<p></p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">measuringCups</span> = [\n  [200, 210],\n  [450, 465],\n  [800, 850],\n] \n<span class="CodeEditor-promptParameter">low</span> = 2100\n<span class="CodeEditor-promptParameter">high</span> = 2300\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n<span class="CodeEditor-promptComment">// We use cup [450, 465] to measure four volumes:</span>\n<span class="CodeEditor-promptComment">// First measurement: Low = 450, High = 465</span>\n<span class="CodeEditor-promptComment">// Second measurement: Low = 450 + 450 = 900, High = 465 + 465 = 930</span>\n<span class="CodeEditor-promptComment">// Third measurement: Low = 900 + 450 = 1350, High = 930 + 465 = 1395</span>\n<span class="CodeEditor-promptComment">// Fourth measurement: Low = 1350 + 450 = 1800, High = 1395 + 465 = 1860</span>\n\n<span class="CodeEditor-promptComment">// Then we use cup [200, 210] to measure two volumes:</span>\n<span class="CodeEditor-promptComment">// Fifth measurement: Low = 1800 + 200 = 2000, High = 1860 + 210 = 2070</span>\n<span class="CodeEditor-promptComment">// Sixth measurement: Low = 2000 + 200 = 2200, High = 2070 + 210 = 2280</span>\n\n<span class="CodeEditor-promptComment">// We\'ve measured a volume in the range [2200, 2280].</span>\n<span class="CodeEditor-promptComment">// This is within our target range, so we return `true`.</span>\n\n<span class="CodeEditor-promptComment">// Note: there are other ways to measure a volume in the target range.</span>\n</pre>\n</div>',
      hints: [
        "<p>\n  Start by considering the last cup that you'll use in your sequence of\n  measurements. If it isn't possible to use any of the cups as the last cup,\n  then you can't measure the desired volume.\n</p>\n",
        "\n<p>\n  If the cup that you're going to use last has a measuring range of\n  <span>[100, 110]</span> and you want to measure in the range of\n  <span>[500, 550]</span>, then after you pick this cup as the last cup, you\n  need to measure a range of <span>[400, 440]</span>. Now, you can simply pick\n  the last cup you'll use to measure this new range. If you continue these\n  steps, you'll eventually know if you're able to measure the entire range or\n  not.\n</p>\n",
        "\n<p>\n  Hint #2 should give you an idea of how to solve this problem recursively. Try\n  every cup as the last cup for the starting range, then recursively try to\n  measure the new ranges created after using the selected last cups. If you ever\n  reach a point where one cup can measure the entire range, then you're finished\n  and you can measure the target range. Try to think of a way to optimize this\n  recursive approach, since it might involve a lot of repeated calculations.\n</p>",
      ],
      spaceTime:
        "O(low * high * n) time | O(low * high) space - where n is the number of measuring cups",
      notes:
        '<div class="html">\n<p>\n  As we recursively call our <span>canMeasureInRange</span> function, we might\n  realize that if the input <span>low</span> is ever less than or equal to\n  <span>0</span>, the outcome for that <span>low</span> is always the same.\n</p>\n<p>\n  In other words, checking if we can measure in the range\n  <span>[-10, 10]</span> is equivalent to checking if we can measure in the\n  range <span>[-5, 10]</span>, which itself is equivalent to checking if we can\n  measure in the range <span>[0, 10]</span>.\n</p>\n<p>The same logic applies to the <span>high</span> value.</p>\n<p>\n  Thus, we can optimize the solution described in the video explanation by\n  capping the <span>low</span> and <span>high</span> values that we pass to our\n  <span>canMeasureInRange</span> function to <span>0</span>. This reduces the\n  number of keys in our cache and maximizes cache hits, thereby optimizing our\n  solution in practice (though not from a time-complexity point of view).\n</p>\n<p>\n  The two comments in the code snippet below highlight the changes that we\'ve\n  made to the code covered in the video explanation.\n</p>\n<pre>\n<span class="CodeEditor-promptComment">// Change `<` to `<=`.</span>\nif low <= 0 and high <= 0:\n    return False\n\ncanMeasure = False\nfor cup in measuringCups:\n    cupLow, cupHigh = cup\n    if low <= cupLow and cupHigh <= high:\n        canMeasure = True\n        break\n\n    <span class="CodeEditor-promptComment">// Cap the `newLow` and `newHigh` to 0.</span>\n    newLow = max(0, low - cupLow)\n    newHigh = max(0, high - cupHigh)\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n    if canMeasure:\n        break\n</pre>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nbool ambiguousMeasurements(vector<vector<int>> measuringCups, int low,\n                           int high) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool canMeasureInRange(vector<vector<int>> &measuringCups, int low, int high,\n                       unordered_map<string, bool> &memoization);\nstring createHashableKey(int low, int high);\n\n// O(low * high * n) time | O(low * high) space - where n is the number of\n// measuring cups\nbool ambiguousMeasurements(vector<vector<int>> measuringCups, int low,\n                           int high) {\n  unordered_map<string, bool> memoization;\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nbool canMeasureInRange(vector<vector<int>> &measuringCups, int low, int high,\n                       unordered_map<string, bool> &memoization) {\n  string memoizeKey = createHashableKey(low, high);\n  if (memoization.find(memoizeKey) != memoization.end()) {\n    return memoization[memoizeKey];\n  }\n\n  if (low <= 0 && high <= 0) {\n    return false;\n  }\n\n  bool canMeasure = false;\n  for (auto cup : measuringCups) {\n    int cupLow = cup[0];\n    int cupHigh = cup[1];\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    int newLow = max(0, low - cupLow);\n    int newHigh = max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure)\n      break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nstring createHashableKey(int low, int high) {\n  return to_string(low) + ":" + to_string(high);\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> cups = {{200, 210}, {450, 465}, {800, 850}};\n      int low = 2100;\n      int high = 2300;\n      auto expected = true;\n      auto actual = ambiguousMeasurements(cups, low, high);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<vector<int>> cups = {{200, 210}, {450, 465}, {800, 850}};\n      int low = 2100;\n      int high = 2300;\n      auto expected = true;\n      auto actual = ambiguousMeasurements(cups, low, high);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic bool AmbiguousMeasurements(int[][] measuringCups, int low, int high) {\n\t\t// Write your code here.\n\t\treturn false;\n\t}\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\n\tpublic bool AmbiguousMeasurements(int[][] measuringCups, int low, int high) {\n\t\tDictionary<string, bool> memoization = new Dictionary<string, bool>();\n\t\treturn canMeasureInRange(measuringCups, low, high, memoization);\n\t}\n\n\tpublic bool canMeasureInRange(int[][] measuringCups, int low, int high, Dictionary<string,\n\t  bool> memoization) {\n\t\tstring memoizeKey = createHashableKey(low, high);\n\t\tif (memoization.ContainsKey(memoizeKey)) {\n\t\t\treturn memoization[memoizeKey];\n\t\t}\n\n\t\tif (low <= 0 && high <= 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tbool canMeasure = false;\n\t\tforeach (var cup in measuringCups) {\n\t\t\tint cupLow = cup[0];\n\t\t\tint cupHigh = cup[1];\n\t\t\tif (low <= cupLow && cupHigh <= high) {\n\t\t\t\tcanMeasure = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint newLow = Math.Max(0, low - cupLow);\n\t\t\tint newHigh = Math.Max(0, high - cupHigh);\n\t\t\tcanMeasure = canMeasureInRange(measuringCups, newLow, newHigh,\n\t\t\t    memoization);\n\t\t\tif (canMeasure) break;\n\t\t}\n\n\t\tmemoization[memoizeKey] = canMeasure;\n\t\treturn canMeasure;\n\t}\n\n\tpublic string createHashableKey(int low, int high) {\n\t\treturn low.ToString() + ":" + high.ToString();\n\t}\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] cups = new int[][] {\n\t\t\tnew int[] { 200, 210 }, new int[] { 450, 465 }, new int[] { 800, 850 }\n\t\t};\n\t\tint low = 2100;\n\t\tint high = 2300;\n\t\tbool expected = true;\n\t\tvar actual = new Program().AmbiguousMeasurements(cups, low, high);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[][] cups = new int[][] {\n\t\t\tnew int[] { 200, 210 }, new int[] { 450, 465 }, new int[] { 800, 850 }\n\t\t};\n\t\tint low = 2100;\n\t\tint high = 2300;\n\t\tbool expected = true;\n\t\tvar actual = new Program().AmbiguousMeasurements(cups, low, high);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc AmbiguousMeasurements(measuringCups [][]int, low int, high int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"fmt"\n)\n\n// O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\nfunc AmbiguousMeasurements(measuringCups [][]int, low int, high int) bool {\n\tmemoization := map[string]bool{}\n\treturn canMeasureInRange(measuringCups, low, high, memoization)\n}\n\nfunc canMeasureInRange(measuringCups [][]int, low, high int, memoization map[string]bool) bool {\n\tmemoizeKey := createHashtableKey(low, high)\n\tif val, found := memoization[memoizeKey]; found {\n\t\treturn val\n\t}\n\n\tif low <= 0 && high <= 0 {\n\t\treturn false\n\t}\n\n\tcanMeasure := false\n\tfor _, cup := range measuringCups {\n\t\tcupLow, cupHigh := cup[0], cup[1]\n\t\tif low <= cupLow && cupHigh <= high {\n\t\t\tcanMeasure = true\n\t\t\tbreak\n\t\t}\n\n\t\tnewLow := max(0, low-cupLow)\n\t\tnewHigh := max(0, high-cupHigh)\n\t\tcanMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n\t\tif canMeasure {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tmemoization[memoizeKey] = canMeasure\n\treturn canMeasure\n}\n\nfunc createHashtableKey(low, high int) string {\n\treturn fmt.Sprintf("%d:%d", low, high)\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tcups := [][]int{\n\t\t{200, 210},\n\t\t{450, 465},\n\t\t{800, 850},\n\t}\n\tlow := 2100\n\thigh := 2300\n\texpected := true\n\tactual := AmbiguousMeasurements(cups, low, high)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tcups := [][]int{\n\t\t{200, 210},\n\t\t{450, 465},\n\t\t{800, 850},\n\t}\n\tlow := 2100\n\thigh := 2300\n\texpected := true\n\tactual := AmbiguousMeasurements(cups, low, high)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public boolean ambiguousMeasurements(int[][] measuringCups, int low, int high) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\n  public boolean ambiguousMeasurements(int[][] measuringCups, int low, int high) {\n    HashMap<String, Boolean> memoization = new HashMap<String, Boolean>();\n    return canMeasureInRange(measuringCups, low, high, memoization);\n  }\n\n  public boolean canMeasureInRange(\n      int[][] measuringCups, int low, int high, HashMap<String, Boolean> memoization) {\n    String memoizeKey = createHashableKey(low, high);\n    if (memoization.containsKey(memoizeKey)) {\n      return memoization.get(memoizeKey);\n    }\n\n    if (low <= 0 && high <= 0) {\n      return false;\n    }\n\n    boolean canMeasure = false;\n    for (int[] cup : measuringCups) {\n      int cupLow = cup[0];\n      int cupHigh = cup[1];\n      if (low <= cupLow && cupHigh <= high) {\n        canMeasure = true;\n        break;\n      }\n\n      int newLow = Math.max(0, low - cupLow);\n      int newHigh = Math.max(0, high - cupHigh);\n      canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n      if (canMeasure) break;\n    }\n\n    memoization.put(memoizeKey, canMeasure);\n    return canMeasure;\n  }\n\n  public String createHashableKey(int low, int high) {\n    return String.valueOf(low) + ":" + String.valueOf(high);\n  }\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] cups = new int[][] {{200, 210}, {450, 465}, {800, 850}};\n    int low = 2100;\n    int high = 2300;\n    boolean expected = true;\n    var actual = new Program().ambiguousMeasurements(cups, low, high);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[][] cups = new int[][] {{200, 210}, {450, 465}, {800, 850}};\n    int low = 2100;\n    int high = 2300;\n    boolean expected = true;\n    var actual = new Program().ambiguousMeasurements(cups, low, high);\n    Utils.assertTrue(expected == actual);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function ambiguousMeasurements(measuringCups, low, high) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(low * high * n) time | O(low * high) space - where n is\n// the number of measuring cups\nfunction ambiguousMeasurements(measuringCups, low, high) {\n  const memoization = {};\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nfunction canMeasureInRange(measuringCups, low, high, memoization) {\n  const memoizeKey = createHashableKey(low, high);\n  if (memoizeKey in memoization) return memoization[memoizeKey];\n\n  if (low <= 0 && high <= 0) return false;\n\n  let canMeasure = false;\n  for (const cup of measuringCups) {\n    const [cupLow, cupHigh] = cup;\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    const newLow = Math.max(0, low - cupLow);\n    const newHigh = Math.max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nfunction createHashableKey(low, high) {\n  return low.toString() + ':' + high.toString();\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun ambiguousMeasurements(measuringCups: List<List<Int>>, low: Int, high: Int): Boolean {\n    // Write your code here.\n    return false\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\nfun ambiguousMeasurements(measuringCups: List<List<Int>>, low: Int, high: Int): Boolean {\n    val memoization = mutableMapOf<String, Boolean>()\n    return canMeasureInRange(measuringCups, low, high, memoization)\n}\n\nfun canMeasureInRange(measuringCups: List<List<Int>>, low: Int, high: Int, memoization: MutableMap<String, Boolean>): Boolean {\n    val memoizeKey = createHashableKey(low, high)\n    if (memoizeKey in memoization) return memoization[memoizeKey]!!\n\n    if (low <= 0 && high <= 0) return false\n\n    var canMeasure = false\n    for (cup in measuringCups) {\n        val (cupLow, cupHigh) = cup\n        if (low <= cupLow && cupHigh <= high) {\n            canMeasure = true\n            break\n        }\n\n        val newLow = Math.max(0, low - cupLow)\n        val newHigh = Math.max(0, high - cupHigh)\n        canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n        if (canMeasure) break\n    }\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n}\n\nfun createHashableKey(low: Int, high: Int): String {\n    return low.toString() + ":" + high.toString()\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.ambiguousMeasurements\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val cups = listOf(\n            listOf(200, 210),\n            listOf(450, 465),\n            listOf(800, 850)\n        )\n        val low = 2100\n        val high = 2300\n        val expected = true\n        val output = ambiguousMeasurements(cups, low, high)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.ambiguousMeasurements\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val cups = listOf(\n            listOf(200, 210),\n            listOf(450, 465),\n            listOf(800, 850)\n        )\n        val low = 2100\n        val high = 2300\n        val expected = true\n        val output = ambiguousMeasurements(cups, low, high)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def ambiguousMeasurements(measuringCups, low, high):\n    # Write your code here.\n    return False\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\ndef ambiguousMeasurements(measuringCups, low, high):\n    memoization = {}\n    return canMeasureInRange(measuringCups, low, high, memoization)\n\n\ndef canMeasureInRange(measuringCups, low, high, memoization):\n    memoizeKey = createHashableKey(low, high)\n    if memoizeKey in memoization:\n        return memoization[memoizeKey]\n\n    if low <= 0 and high <= 0:\n        return False\n\n    canMeasure = False\n    for cup in measuringCups:\n        cupLow, cupHigh = cup\n        if low <= cupLow and cupHigh <= high:\n            canMeasure = True\n            break\n\n        newLow = max(0, low - cupLow)\n        newHigh = max(0, high - cupHigh)\n        canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization)\n        if canMeasure:\n            break\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n\n\ndef createHashableKey(low, high):\n    return str(low) + ":" + str(high)\n',
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        cups = [[200, 210], [450, 465], [800, 850]]\n        low = 2100\n        high = 2300\n        expected = True\n        actual = program.ambiguousMeasurements(cups, low, high)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        cups = [[200, 210], [450, 465], [800, 850]]\n        low = 2100\n        high = 2300\n        expected = True\n        actual = program.ambiguousMeasurements(cups, low, high)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: false,
          startingCode:
            "class Program\n  def ambiguousMeasurements(measuringCups, low, high)\n    # Write your code here.\n    return false\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def ambiguousMeasurements(measuringCups, low, high)\n    # Write your code here.\n    return false\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.ambiguousMeasurements\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.ambiguousMeasurements\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func ambiguousMeasurements(_ measuringCups: [[Int]], _ low: Int, _ high: Int) -> Bool {\n    // Write your code here.\n    return false\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(low * high * n) time | O(low * high) space - where n is the number of measuring cups\n  func ambiguousMeasurements(_ measuringCups: [[Int]], _ low: Int, _ high: Int) -> Bool {\n    var memoization = [String: Bool]()\n    return canMeasureInRange(measuringCups, low, high, &memoization)\n  }\n\n  func canMeasureInRange(_ measuringCups: [[Int]], _ low: Int, _ high: Int, _ memoization: inout [String: Bool]) -> Bool {\n    let memoizeKey = createHashtableKey(low, high)\n    if memoization[memoizeKey] != nil {\n      return memoization[memoizeKey]!\n    }\n\n    if low <= 0, high <= 0 {\n      return false\n    }\n\n    var canMeasure = false\n    for cup in measuringCups {\n      let (cupLow, cupHigh) = (cup[0], cup[1])\n      if low <= cupLow, cupHigh <= high {\n        canMeasure = true\n        break\n      }\n\n      let newLow = max(0, low - cupLow)\n      let newHigh = max(0, high - cupHigh)\n      canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, &memoization)\n      if canMeasure {\n        break\n      }\n    }\n\n    memoization[memoizeKey] = canMeasure\n    return canMeasure\n  }\n\n  func createHashtableKey(_ low: Int, _ high: Int) -> String {\n    return String(low) + ":" + String(high)\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let cups = [\n        [200, 210],\n        [450, 465],\n        [800, 850],\n      ]\n      let low = 2100\n      let high = 2300\n      let expected = true\n      var actual = Program().ambiguousMeasurements(cups, low, high)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let cups = [\n        [200, 210],\n        [450, 465],\n        [800, 850],\n      ]\n      let low = 2100\n      let high = 2300\n      let expected = true\n      var actual = Program().ambiguousMeasurements(cups, low, high)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function ambiguousMeasurements(measuringCups: number[][], low: number, high: number) {\n  // Write your code here.\n  return false;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(low * high * n) time | O(low * high) space - where n is\n// the number of measuring cups\nexport function ambiguousMeasurements(measuringCups: number[][], low: number, high: number) {\n  const memoization: {[key: string]: boolean} = {};\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nfunction canMeasureInRange(\n  measuringCups: number[][],\n  low: number,\n  high: number,\n  memoization: {[key: string]: boolean},\n): boolean {\n  const memoizeKey = createHashableKey(low, high);\n  if (memoizeKey in memoization) return memoization[memoizeKey];\n\n  if (low <= 0 && high <= 0) return false;\n\n  let canMeasure = false;\n  for (const cup of measuringCups) {\n    const [cupLow, cupHigh] = cup;\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    const newLow = Math.max(0, low - cupLow);\n    const newHigh = Math.max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nfunction createHashableKey(low: number, high: number) {\n  return low.toString() + ':' + high.toString();\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "measuringCups",
          example: [
            [200, 210],
            [450, 465],
            [800, 850],
          ],
          schema: {
            items: {
              items: {
                minimum: 0,
                type: "integer",
              },
              maxItems: 2,
              minItems: 2,
              type: "array",
            },
            type: "array",
          },
        },
        {
          name: "low",
          example: 2100,
          schema: {
            minimum: 0,
            type: "integer",
          },
        },
        {
          name: "high",
          example: 2300,
          schema: {
            minimum: 0,
            type: "integer",
          },
        },
      ],
      tests: [
        {
          high: 2300,
          low: 2100,
          measuringCups: [
            [200, 210],
            [450, 465],
            [800, 850],
          ],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[200, 210]],
        },
        {
          high: 2300,
          low: 2100,
          measuringCups: [
            [230, 240],
            [290, 310],
            [500, 515],
          ],
        },
        {
          high: 101,
          low: 100,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
          ],
        },
        {
          high: 120,
          low: 100,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
          ],
        },
        {
          high: 12,
          low: 10,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
            [10, 20],
          ],
        },
        {
          high: 12,
          low: 10,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 7],
            [10, 20],
          ],
        },
        {
          high: 1050,
          low: 1000,
          measuringCups: [
            [50, 60],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
          ],
        },
        {
          high: 1200,
          low: 1000,
          measuringCups: [
            [50, 65],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
          ],
        },
        {
          high: 3300,
          low: 3000,
          measuringCups: [
            [50, 65],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
            [300, 350],
            [10, 25],
          ],
        },
        {
          high: 1050,
          low: 1000,
          measuringCups: [
            [50, 60],
            [100, 120],
            [20, 40],
            [400, 500],
          ],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [[50, 65]],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [[50, 50]],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [
            [50, 50],
            [50, 51],
          ],
        },
        {
          high: 1000,
          low: 0,
          measuringCups: [
            [100, 150],
            [1000, 2000],
          ],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[10, 20]],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[15, 18]],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[15, 22]],
        },
      ],
      jsonTests: [
        {
          high: 2300,
          low: 2100,
          measuringCups: [
            [200, 210],
            [450, 465],
            [800, 850],
          ],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[200, 210]],
        },
        {
          high: 2300,
          low: 2100,
          measuringCups: [
            [230, 240],
            [290, 310],
            [500, 515],
          ],
        },
        {
          high: 101,
          low: 100,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
          ],
        },
        {
          high: 120,
          low: 100,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
          ],
        },
        {
          high: 12,
          low: 10,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 6],
            [10, 20],
          ],
        },
        {
          high: 12,
          low: 10,
          measuringCups: [
            [1, 3],
            [2, 4],
            [5, 7],
            [10, 20],
          ],
        },
        {
          high: 1050,
          low: 1000,
          measuringCups: [
            [50, 60],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
          ],
        },
        {
          high: 1200,
          low: 1000,
          measuringCups: [
            [50, 65],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
          ],
        },
        {
          high: 3300,
          low: 3000,
          measuringCups: [
            [50, 65],
            [100, 120],
            [20, 40],
            [10, 15],
            [400, 500],
            [300, 350],
            [10, 25],
          ],
        },
        {
          high: 1050,
          low: 1000,
          measuringCups: [
            [50, 60],
            [100, 120],
            [20, 40],
            [400, 500],
          ],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [[50, 65]],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [[50, 50]],
        },
        {
          high: 200,
          low: 200,
          measuringCups: [
            [50, 50],
            [50, 51],
          ],
        },
        {
          high: 1000,
          low: 0,
          measuringCups: [
            [100, 150],
            [1000, 2000],
          ],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[10, 20]],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[15, 18]],
        },
        {
          high: 20,
          low: 10,
          measuringCups: [[15, 22]],
        },
      ],
      changelog: [],
      id: 26,
    },
    {
      uid: "binary-search",
      testStrategy: "JSON",
      name: "Binary Search",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Searching",
      difficulty: 1,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 49958,
        failureCount: 20226,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "226676043",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1209,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a sorted array of integers as well as a target\n  integer. The function should use the Binary Search algorithm to determine if\n  the target integer is contained in the array and should return its index if it\n  is, otherwise <span>-1</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Binary Search, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [0, 1, 21, 33, 45, 45, 61, 71, 72, 73]\n<span class="CodeEditor-promptParameter">target</span> = 33\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>',
      hints: [
        "<p>\nThe Binary Search algorithm works by finding the number in the middle of the input array and comparing it to the target number. Given that the array is sorted, if this middle number is smaller than the target number, then the entire left part of the array is no longer worth exploring since the target number can no longer be in it; similarly, if the middle number is greater than the target number, then the entire right part of the array is no longer worth exploring. Applying this logic recursively eliminates half of the array until the number is found or until the array runs out of numbers.\n</p>\n",
        "\n<p>\nWrite a helper function that takes in two additional arguments: a left pointer and a right pointer representing the indices at the extremities of the array (or subarray) that you are applying Binary Search on. The first time this helper function is called, the left pointer should be zero and the right pointer should be the final index of the input array. To find the index of the middle number mentioned in Hint #1, simply round down the number obtained from: (left + right) / 2. Apply this logic recursively until you find the target number or until the left pointer becomes greater than the right pointer.\n</p>\n",
        "\n<p>\nCan you implement this algorithm iteratively? Are there any advantages to doing so?\n</p>",
      ],
      spaceTime:
        "O(log(n)) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint binarySearch(vector<int> array, int target) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint binarySearch(vector<int> array, int target);\nint binarySearchHelper(vector<int> array, int target, int left, int right);\n\n// O(log(n)) time | O(log(n)) space\nint binarySearch(vector<int> array, int target) {\n  return binarySearchHelper(array, target, 0, array.size() - 1);\n}\n\nint binarySearchHelper(vector<int> array, int target, int left, int right) {\n  if (left > right) {\n    return -1;\n  }\n  int middle = (left + right) / 2;\n  int potentialMatch = array[middle];\n  if (target == potentialMatch) {\n    return middle;\n  } else if (target < potentialMatch) {\n    return binarySearchHelper(array, target, left, middle - 1);\n  } else {\n    return binarySearchHelper(array, target, middle + 1, right);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint binarySearch(vector<int> array, int target);\nint binarySearchHelper(vector<int> array, int target, int left, int right);\n\n// O(log(n)) time | O(1) space\nint binarySearch(vector<int> array, int target) {\n  return binarySearchHelper(array, target, 0, array.size() - 1);\n}\n\nint binarySearchHelper(vector<int> array, int target, int left, int right) {\n  while (left <= right) {\n    int middle = (left + right) / 2;\n    int potentialMatch = array[middle];\n    if (target == potentialMatch) {\n      return middle;\n    } else if (target < potentialMatch) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(binarySearch({0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33) == 3);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(binarySearch({0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33) == 3);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int BinarySearch(int[] array, int target) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(log(n)) time | O(log(n)) space\n\tpublic static int BinarySearch(int[] array, int target) {\n\t\treturn BinarySearch(array, target, 0, array.Length - 1);\n\t}\n\n\tpublic static int BinarySearch(int[] array, int target, int left, int right) {\n\t\tif (left > right) {\n\t\t\treturn -1;\n\t\t}\n\t\tint middle = (left + right) / 2;\n\t\tint potentialMatch = array[middle];\n\t\tif (target == potentialMatch) {\n\t\t\treturn middle;\n\t\t} else if (target < potentialMatch) {\n\t\t\treturn BinarySearch(array, target, left, middle - 1);\n\t\t} else {\n\t\t\treturn BinarySearch(array, target, middle + 1, right);\n\t\t}\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// O(log(n)) time | O(1) space\n\tpublic static int BinarySearch(int[] array, int target) {\n\t\treturn BinarySearch(array, target, 0, array.Length - 1);\n\t}\n\n\tpublic static int BinarySearch(int[] array, int target, int left, int right) {\n\t\twhile (left <= right) {\n\t\t\tint middle = (left + right) / 2;\n\t\t\tint potentialMatch = array[middle];\n\t\t\tif (target == potentialMatch) {\n\t\t\t\treturn middle;\n\t\t\t} else if (target < potentialMatch) {\n\t\t\t\tright = middle - 1;\n\t\t\t} else {\n\t\t\t\tleft = middle + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.BinarySearch(new int[] {0, 1, 21, 33, 45, 45, 61, 71, 72,\n\t\t                                                 73}, 33) == 3);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.BinarySearch(new int[] {0, 1, 21, 33, 45, 45, 61, 71, 72,\n\t\t                                                 73}, 33) == 3);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc BinarySearch(array []int, target int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(log(n)) space\nfunc BinarySearch(array []int, target int) int {\n\treturn helper(array, target, 0, len(array)-1)\n}\n\nfunc helper(array []int, target, left, right int) int {\n\tif left > right {\n\t\treturn -1\n\t}\n\tmiddle := (left + right) / 2\n\tpotentialMatch := array[middle]\n\tif target == potentialMatch {\n\t\treturn middle\n\t} else if target < potentialMatch {\n\t\treturn helper(array, target, left, middle-1)\n\t}\n\treturn helper(array, target, middle+1, right)\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(log(n)) time | O(1) space\nfunc BinarySearch(array []int, target int) int {\n\treturn helper(array, target, 0, len(array)-1)\n}\n\nfunc helper(array []int, target, left, right int) int {\n\tfor left <= right {\n\t\tmiddle := (left + right) / 2\n\t\tpotentialMatch := array[middle]\n\t\tif target == potentialMatch {\n\t\t\treturn middle\n\t\t} else if target < potentialMatch {\n\t\t\tright = middle - 1\n\t\t} else {\n\t\t\tleft = middle + 1\n\t\t}\n\t}\n\treturn -1\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 3\n\toutput := BinarySearch([]int{0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 3\n\toutput := BinarySearch([]int{0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int binarySearch(int[] array, int target) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(log(n)) space\n  public static int binarySearch(int[] array, int target) {\n    return binarySearch(array, target, 0, array.length - 1);\n  }\n\n  public static int binarySearch(int[] array, int target, int left, int right) {\n    if (left > right) {\n      return -1;\n    }\n    int middle = (left + right) / 2;\n    int potentialMatch = array[middle];\n    if (target == potentialMatch) {\n      return middle;\n    } else if (target < potentialMatch) {\n      return binarySearch(array, target, left, middle - 1);\n    } else {\n      return binarySearch(array, target, middle + 1, right);\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(log(n)) time | O(1) space\n  public static int binarySearch(int[] array, int target) {\n    return binarySearch(array, target, 0, array.length - 1);\n  }\n\n  public static int binarySearch(int[] array, int target, int left, int right) {\n    while (left <= right) {\n      int middle = (left + right) / 2;\n      int potentialMatch = array[middle];\n      if (target == potentialMatch) {\n        return middle;\n      } else if (target < potentialMatch) {\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    }\n    return -1;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.binarySearch(new int[] {0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33) == 3);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(\n        Program.binarySearch(new int[] {0, 1, 21, 33, 45, 45, 61, 71, 72, 73}, 33) == 3);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function binarySearch(array, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.binarySearch = binarySearch;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space\nfunction binarySearch(array, target) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array, target, left, right) {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (target < potentialMatch) {\n    return binarySearchHelper(array, target, left, middle - 1);\n  } else {\n    return binarySearchHelper(array, target, middle + 1, right);\n  }\n}\n\nexports.binarySearch = binarySearch;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space\nfunction binarySearch(array, target) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array, target, left, right) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (target < potentialMatch) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return -1;\n}\n\nexports.binarySearch = binarySearch;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun binarySearch(array: List<Int>, target: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(log(n)) space\nfun binarySearch(array: List<Int>, target: Int): Int {\n    return binarySearch(array, target, 0, array.size - 1)\n}\n\nfun binarySearch(array: List<Int>, target: Int, left: Int, right: Int): Int {\n    if (left > right) {\n        return -1\n    }\n    val middle = (left + right) / 2\n    val potentialMatch = array[middle]\n    if (target == potentialMatch) {\n        return middle\n    } else if (target < potentialMatch) {\n        return binarySearch(array, target, left, middle - 1)\n    } else {\n        return binarySearch(array, target, middle + 1, right)\n    }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(log(n)) time | O(1) space\nfun binarySearch(array: List<Int>, target: Int): Int {\n    return binarySearch(array, target, 0, array.size - 1)\n}\n\nfun binarySearch(array: List<Int>, target: Int, leftIdx: Int, rightIdx: Int): Int {\n    var left = leftIdx\n    var right = rightIdx\n    while (left <= right) {\n        val middle = (left + right) / 2\n        val potentialMatch = array[middle]\n        if (target == potentialMatch) {\n            return middle\n        } else if (target < potentialMatch) {\n            right = middle - 1\n        } else {\n            left = middle + 1\n        }\n    }\n    return -1\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.binarySearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(0, 1, 21, 33, 45, 45, 61, 71, 72, 73)\n        val target = 33\n        val expected = 3\n        val output = binarySearch(array, target)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.binarySearch\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(0, 1, 21, 33, 45, 45, 61, 71, 72, 73)\n        val target = 33\n        val expected = 3\n        val output = binarySearch(array, target)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def binarySearch(array, target):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(log(n)) space\ndef binarySearch(array, target):\n    return binarySearchHelper(array, target, 0, len(array) - 1)\n\n\ndef binarySearchHelper(array, target, left, right):\n    if left > right:\n        return -1\n    middle = (left + right) // 2\n    potentialMatch = array[middle]\n    if target == potentialMatch:\n        return middle\n    elif target < potentialMatch:\n        return binarySearchHelper(array, target, left, middle - 1)\n    else:\n        return binarySearchHelper(array, target, middle + 1, right)\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(log(n)) time | O(1) space\ndef binarySearch(array, target):\n    return binarySearchHelper(array, target, 0, len(array) - 1)\n\n\ndef binarySearchHelper(array, target, left, right):\n    while left <= right:\n        middle = (left + right) // 2\n        potentialMatch = array[middle]\n        if target == potentialMatch:\n            return middle\n        elif target < potentialMatch:\n            right = middle - 1\n        else:\n            left = middle + 1\n    return -1\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33), 3)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33), 3)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def binarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def binarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def binarySearch(array, target)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binarySearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binarySearch\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func binarySearch(array: [Int], target: Int) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(Log(n)) time | O(Log(n)) space\n  func binarySearch(array: [Int], target: Int) -> Int {\n    return binarySearchHelper(array: array, target: target, leftPointer: 0, rightPointer: array.count - 1)\n  }\n\n  func binarySearchHelper(array: [Int], target: Int, leftPointer: Int, rightPointer: Int) -> Int {\n    if leftPointer > rightPointer {\n      return -1\n    }\n    let middle = (leftPointer + rightPointer) / 2\n    let potentialMatch = array[middle]\n    if target == potentialMatch {\n      return middle\n    } else if target < potentialMatch {\n      return binarySearchHelper(array: array, target: target, leftPointer: leftPointer, rightPointer: middle - 1)\n    } else {\n      return binarySearchHelper(array: array, target: target, leftPointer: middle + 1, rightPointer: rightPointer)\n    }\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(Log(n)) time | O(1) space\n  func binarySearch(array: [Int], target: Int) -> Int {\n    var leftPointer = 0\n    var rightPointer = array.count - 1\n    return binarySearchHelper(array: array, target: target, leftPointer: &leftPointer, rightPointer: &rightPointer)\n  }\n\n  func binarySearchHelper(array: [Int], target: Int, leftPointer: inout Int, rightPointer: inout Int) -> Int {\n    while leftPointer <= rightPointer {\n      let middle = (leftPointer + rightPointer) / 2\n      let potentialMatch = array[middle]\n      if target == potentialMatch {\n        return middle\n      } else if target < potentialMatch {\n        rightPointer = middle - 1\n      } else {\n        leftPointer = middle + 1\n      }\n    }\n\n    return -1\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 4") { () throws -> Void in\n      try assertEqual(3, program.binarySearch(array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 33))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 4") { () throws -> Void in\n      try assertEqual(3, program.binarySearch(array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 33))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function binarySearch(array: number[], target: number): number {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(log(n)) space\nexport function binarySearch(array: number[], target: number) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array: number[], target: number, left: number, right: number): number {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (target < potentialMatch) {\n    return binarySearchHelper(array, target, left, middle - 1);\n  } else {\n    return binarySearchHelper(array, target, middle + 1, right);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(log(n)) time | O(1) space\nexport function binarySearch(array: number[], target: number) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array: number[], target: number, left: number, right: number) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (target < potentialMatch) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return -1;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
        {
          name: "target",
          example: 33,
          schema: {
            type: "integer",
          },
        },
      ],
      tests: [
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 33,
        },
        {
          array: [1, 5, 23, 111],
          target: 111,
        },
        {
          array: [1, 5, 23, 111],
          target: 5,
        },
        {
          array: [1, 5, 23, 111],
          target: 35,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 0,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 1,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 21,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 45,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 61,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 71,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 72,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 73,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 70,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355],
          target: 355,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355],
          target: 354,
        },
        {
          array: [1, 5, 23, 111],
          target: 120,
        },
        {
          array: [5, 23, 111],
          target: 3,
        },
      ],
      jsonTests: [
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 33,
        },
        {
          array: [1, 5, 23, 111],
          target: 111,
        },
        {
          array: [1, 5, 23, 111],
          target: 5,
        },
        {
          array: [1, 5, 23, 111],
          target: 35,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 0,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 1,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 21,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 45,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 61,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 71,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 72,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 73,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
          target: 70,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355],
          target: 355,
        },
        {
          array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355],
          target: 354,
        },
        {
          array: [1, 5, 23, 111],
          target: 120,
        },
        {
          array: [5, 23, 111],
          target: 3,
        },
      ],
      changelog: [],
      id: 27,
    },
    {
      uid: "subarray-sort",
      testStrategy: "JSON",
      name: "Subarray Sort",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Arrays",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 15904,
        failureCount: 6822,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "241820009",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 958,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of at least two integers and that\n  returns an array of the starting and ending indices of the smallest subarray\n  in the input array that needs to be sorted in place in order for the entire\n  input array to be sorted (in ascending order).\n</p>\n<p>\n  If the input array is already sorted, the function should return\n  <span>[-1, -1]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[3, 9]\n</pre>\n</div>',
      hints: [
        "<p>\nRealize that even a single out-of-order number in the input array can call for a large subarray to have to be sorted. This is because, depending on how out-of-place the number is, it might need to be moved very far away from its original position in order to be in its sorted position.\n</p>\n",
        "\n<p>\nFind the smallest and largest numbers that are out of order in the input array. You should be able to do this in a single pass through the array.\n</p>\n",
        "\n<p>\nOnce you've found the smallest and largest out-of-order numbers mentioned in Hint #2, find their final sorted positions in the array. This should give you the extremities of the smallest subarray that needs to be sorted.\n</p>",
      ],
      spaceTime:
        "O(n) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> subarraySort(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nbool isOutOfOrder(int i, int num, vector<int> array);\n\n// O(n) time | O(1) space\nvector<int> subarraySort(vector<int> array) {\n  int minOutOfOrder = INT_MAX;\n  int maxOutOfOrder = INT_MIN;\n  for (int i = 0; i < array.size(); i++) {\n    int num = array[i];\n    if (isOutOfOrder(i, num, array)) {\n      minOutOfOrder = min(minOutOfOrder, num);\n      maxOutOfOrder = max(maxOutOfOrder, num);\n    }\n  }\n  if (minOutOfOrder == INT_MAX) {\n    return vector<int>{-1, -1};\n  }\n  int subarrayLeftIdx = 0;\n  while (minOutOfOrder >= array[subarrayLeftIdx]) {\n    subarrayLeftIdx++;\n  }\n  int subarrayRightIdx = array.size() - 1;\n  while (maxOutOfOrder <= array[subarrayRightIdx]) {\n    subarrayRightIdx--;\n  }\n  return vector<int>{subarrayLeftIdx, subarrayRightIdx};\n}\n\nbool isOutOfOrder(int i, int num, vector<int> array) {\n  if (i == 0) {\n    return num > array[i + 1];\n  }\n  if (i == array.size() - 1) {\n    return num < array[i - 1];\n  }\n  return num > array[i + 1] || num < array[i - 1];\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{3, 9};\n      assert(subarraySort({1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19}) ==\n             expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{3, 9};\n      assert(subarraySort({1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19}) ==\n             expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] SubarraySort(int[] array) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n) time | O(1) space\n\tpublic static int[] SubarraySort(int[] array) {\n\t\tint minOutOfOrder = Int32.MaxValue;\n\t\tint maxOutOfOrder = Int32.MinValue;\n\t\tfor (int i = 0; i < array.Length; i++) {\n\t\t\tint num = array[i];\n\t\t\tif (isOutOfOrder(i, num, array)) {\n\t\t\t\tminOutOfOrder = Math.Min(minOutOfOrder, num);\n\t\t\t\tmaxOutOfOrder = Math.Max(maxOutOfOrder, num);\n\t\t\t}\n\t\t}\n\t\tif (minOutOfOrder == Int32.MaxValue) {\n\t\t\treturn new int[] {-1, -1};\n\t\t}\n\t\tint subarrayLeftIdx = 0;\n\t\twhile (minOutOfOrder >= array[subarrayLeftIdx]) {\n\t\t\tsubarrayLeftIdx++;\n\t\t}\n\t\tint subarrayRightIdx = array.Length - 1;\n\t\twhile (maxOutOfOrder <= array[subarrayRightIdx]) {\n\t\t\tsubarrayRightIdx--;\n\t\t}\n\t\treturn new int[] {subarrayLeftIdx, subarrayRightIdx};\n\t}\n\n\tpublic static bool isOutOfOrder(int i, int num, int[] array) {\n\t\tif (i == 0) {\n\t\t\treturn num > array[i + 1];\n\t\t}\n\t\tif (i == array.Length - 1) {\n\t\t\treturn num < array[i - 1];\n\t\t}\n\t\treturn num > array[i + 1] || num < array[i - 1];\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {3, 9};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.SubarraySort(new int[] {1, 2, 4,\n\t\t                                                                          7, 10, 11,\n\t\t                                                                          7, 12, 6,\n\t\t                                                                          7, 16, 18,\n\t\t                                                                          19}),\n\t\t  expected));\n\t}\n}\n",
          unitTests:
            "using System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] expected = {3, 9};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.SubarraySort(new int[] {1, 2, 4,\n\t\t                                                                          7, 10, 11,\n\t\t                                                                          7, 12, 6,\n\t\t                                                                          7, 16, 18,\n\t\t                                                                          19}),\n\t\t  expected));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc SubarraySort(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport "math"\n\n// O(n) time | O(1) space\nfunc SubarraySort(array []int) []int {\n\tminOutOfOrder, maxOutOfOrder := math.MaxInt32, math.MinInt32\n\tfor i, num := range array {\n\t\tif isOutOfOrder(i, num, array) {\n\t\t\tminOutOfOrder = min(minOutOfOrder, num)\n\t\t\tmaxOutOfOrder = max(maxOutOfOrder, num)\n\t\t}\n\t}\n\tif minOutOfOrder == math.MaxInt32 {\n\t\treturn []int{-1, -1}\n\t}\n\tsubarrayLeft := 0\n\tfor minOutOfOrder >= array[subarrayLeft] {\n\t\tsubarrayLeft += 1\n\t}\n\tsubarrayRight := len(array) - 1\n\tfor maxOutOfOrder <= array[subarrayRight] {\n\t\tsubarrayRight -= 1\n\t}\n\treturn []int{subarrayLeft, subarrayRight}\n}\n\nfunc isOutOfOrder(i int, num int, array []int) bool {\n\tif i == 0 {\n\t\treturn num > array[i+1]\n\t}\n\tif i == len(array)-1 {\n\t\treturn num < array[i-1]\n\t}\n\treturn num > array[i+1] || num < array[i-1]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{3, 9}\n\toutput := SubarraySort([]int{1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{3, 9}\n\toutput := SubarraySort([]int{1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] subarraySort(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  public static int[] subarraySort(int[] array) {\n    int minOutOfOrder = Integer.MAX_VALUE;\n    int maxOutOfOrder = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n      int num = array[i];\n      if (isOutOfOrder(i, num, array)) {\n        minOutOfOrder = Math.min(minOutOfOrder, num);\n        maxOutOfOrder = Math.max(maxOutOfOrder, num);\n      }\n    }\n    if (minOutOfOrder == Integer.MAX_VALUE) {\n      return new int[] {-1, -1};\n    }\n    int subarrayLeftIdx = 0;\n    while (minOutOfOrder >= array[subarrayLeftIdx]) {\n      subarrayLeftIdx++;\n    }\n    int subarrayRightIdx = array.length - 1;\n    while (maxOutOfOrder <= array[subarrayRightIdx]) {\n      subarrayRightIdx--;\n    }\n    return new int[] {subarrayLeftIdx, subarrayRightIdx};\n  }\n\n  public static boolean isOutOfOrder(int i, int num, int[] array) {\n    if (i == 0) {\n      return num > array[i + 1];\n    }\n    if (i == array.length - 1) {\n      return num < array[i - 1];\n    }\n    return num > array[i + 1] || num < array[i - 1];\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {3, 9};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.subarraySort(new int[] {1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19}),\n            expected));\n  }\n}\n",
          unitTests:
            "import java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {3, 9};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.subarraySort(new int[] {1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19}),\n            expected));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function subarraySort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.subarraySort = subarraySort;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(1) space\nfunction subarraySort(array) {\n  let minOutOfOrder = Infinity;\n  let maxOutOfOrder = -Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    if (isOutOfOrder(i, num, array)) {\n      minOutOfOrder = Math.min(minOutOfOrder, num);\n      maxOutOfOrder = Math.max(maxOutOfOrder, num);\n    }\n  }\n  if (minOutOfOrder === Infinity) {\n    return [-1, -1];\n  }\n  let subarrayLeftIdx = 0;\n  while (minOutOfOrder >= array[subarrayLeftIdx]) {\n    subarrayLeftIdx++;\n  }\n  let subarrayRightIdx = array.length - 1;\n  while (maxOutOfOrder <= array[subarrayRightIdx]) {\n    subarrayRightIdx--;\n  }\n  return [subarrayLeftIdx, subarrayRightIdx];\n}\n\nfunction isOutOfOrder(i, num, array) {\n  if (i === 0) return num > array[i + 1];\n  if (i === array.length - 1) return num < array[i - 1];\n  return num > array[i + 1] || num < array[i - 1];\n}\n\nexports.subarraySort = subarraySort;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19])).to.deep.equal([3, 9]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19])).to.deep.equal([3, 9]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun subarraySort(array: List<Int>): List<Int> {\n    // Write your code here.\n    return listOf<Int>(-1, -1)\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\nimport kotlin.math.min\n\n// O(n) time | O(1) space\nfun subarraySort(array: List<Int>): List<Int> {\n    var minOutOfOrder = Int.MAX_VALUE\n    var maxOutOfOrder = Int.MIN_VALUE\n    for (i in 0 until array.size) {\n        val num = array[i]\n        if (isOutOfOrder(i, num, array)) {\n            minOutOfOrder = min(minOutOfOrder, num)\n            maxOutOfOrder = max(maxOutOfOrder, num)\n        }\n    }\n    if (minOutOfOrder == Int.MAX_VALUE) {\n        return listOf<Int>(-1, -1)\n    }\n    var subarrayLeftIdx = 0\n    while (minOutOfOrder >= array[subarrayLeftIdx]) {\n        subarrayLeftIdx++\n    }\n    var subarrayRightIdx = array.size - 1\n    while (maxOutOfOrder <= array[subarrayRightIdx]) {\n        subarrayRightIdx--\n    }\n    return listOf<Int>(subarrayLeftIdx, subarrayRightIdx)\n}\n\nfun isOutOfOrder(i: Int, num: Int, array: List<Int>): Boolean {\n    if (i == 0) return num > array[i + 1]\n    if (i == array.size - 1) return num < array[i - 1]\n    return num > array[i + 1] || num < array[i - 1]\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.subarraySort as subarraySort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf<Int>(1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19)\n        val output = subarraySort(array)\n        val expected = listOf<Int>(3, 9)\n        assert(output.equals(expected))\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.subarraySort as subarraySort\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf<Int>(1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19)\n        val output = subarraySort(array)\n        val expected = listOf<Int>(3, 9)\n        assert(output.equals(expected))\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def subarraySort(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(1) space\ndef subarraySort(array):\n    minOutOfOrder = float("inf")\n    maxOutOfOrder = float("-inf")\n    for i in range(len(array)):\n        num = array[i]\n        if isOutOfOrder(i, num, array):\n            minOutOfOrder = min(minOutOfOrder, num)\n            maxOutOfOrder = max(maxOutOfOrder, num)\n    if minOutOfOrder == float("inf"):\n        return [-1, -1]\n    subarrayLeftIdx = 0\n    while minOutOfOrder >= array[subarrayLeftIdx]:\n        subarrayLeftIdx += 1\n    subarrayRightIdx = len(array) - 1\n    while maxOutOfOrder <= array[subarrayRightIdx]:\n        subarrayRightIdx -= 1\n    return [subarrayLeftIdx, subarrayRightIdx]\n\n\ndef isOutOfOrder(i, num, array):\n    if i == 0:\n        return num > array[i + 1]\n    if i == len(array) - 1:\n        return num < array[i - 1]\n    return num > array[i + 1] or num < array[i - 1]\n',
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]), [3, 9])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]), [3, 9])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def subarraySort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def subarraySort(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.subarraySort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.subarraySort\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func subarraySort(array: [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(1) space\n  func subarraySort(array: [Int]) -> [Int] {\n    var minimumOutOfOrder = Int(Int16.max)\n    var maximumOutOfOrder = -Int(Int16.max)\n\n    for i in 0 ..< array.count {\n      let currentNumber = array[i]\n\n      if isOutOfOrder(i, array, currentNumber) {\n        minimumOutOfOrder = min(currentNumber, minimumOutOfOrder)\n        maximumOutOfOrder = max(currentNumber, maximumOutOfOrder)\n      }\n    }\n\n    if minimumOutOfOrder == Int(Int16.max) {\n      return [-1, -1]\n    }\n\n    var subarrayLeftIndex = 0\n    while minimumOutOfOrder >= array[subarrayLeftIndex] {\n      subarrayLeftIndex += 1\n    }\n\n    var subarrayRightIndex = array.count - 1\n    while maximumOutOfOrder <= array[subarrayRightIndex] {\n      subarrayRightIndex -= 1\n    }\n\n    return [subarrayLeftIndex, subarrayRightIndex]\n  }\n\n  func isOutOfOrder(_ i: Int, _ array: [Int], _ currentNumber: Int) -> Bool {\n    if i == 0 {\n      return currentNumber > array[i + 1]\n    } else if i == array.count - 1 {\n      return currentNumber < array[i - 1]\n    } else {\n      return currentNumber > array[i + 1] || currentNumber < array[i - 1]\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual([3, 9], program.subarraySort(array: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual([3, 9], program.subarraySort(array: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "type Range = [number, number];\n\nexport function subarraySort(array: number[]): Range {\n  // Write your code here.\n  return [-1, -1];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ntype Range = [number, number];\n\n// O(n) time | O(1) space\nexport function subarraySort(array: number[]): Range {\n  let minOutOfOrder = Infinity;\n  let maxOutOfOrder = -Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    if (isOutOfOrder(i, num, array)) {\n      minOutOfOrder = Math.min(minOutOfOrder, num);\n      maxOutOfOrder = Math.max(maxOutOfOrder, num);\n    }\n  }\n  if (minOutOfOrder === Infinity) {\n    return [-1, -1];\n  }\n  let subarrayLeftIdx = 0;\n  while (minOutOfOrder >= array[subarrayLeftIdx]) {\n    subarrayLeftIdx++;\n  }\n  let subarrayRightIdx = array.length - 1;\n  while (maxOutOfOrder <= array[subarrayRightIdx]) {\n    subarrayRightIdx--;\n  }\n  return [subarrayLeftIdx, subarrayRightIdx];\n}\n\nfunction isOutOfOrder(i: number, num: number, array: number[]) {\n  if (i === 0) return num > array[i + 1];\n  if (i === array.length - 1) return num < array[i - 1];\n  return num > array[i + 1] || num < array[i - 1];\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19])).to.deep.equal([3, 9]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19])).to.deep.equal([3, 9]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19],
          schema: {
            items: {
              type: "integer",
            },
            minItems: 2,
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 7, 7, 16, 18, 19],
        },
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 13, 14, 16, 18, 19],
        },
        {
          array: [1, 2, 8, 4, 5],
        },
        {
          array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7],
        },
        {
          array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57],
        },
        {
          array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57],
        },
        {
          array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 8, 7, 9, 10, 11],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 18, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 18, 21, 22, 7, 14, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 19, 4, 14, 11, 6, 33, 35, 41, 55,
          ],
        },
        {
          array: [
            1, 2, 20, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
            19,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            2,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            20,
          ],
        },
        {
          array: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
        },
      ],
      jsonTests: [
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19],
        },
        {
          array: [1, 2],
        },
        {
          array: [2, 1],
        },
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 7, 7, 16, 18, 19],
        },
        {
          array: [1, 2, 4, 7, 10, 11, 7, 12, 13, 14, 16, 18, 19],
        },
        {
          array: [1, 2, 8, 4, 5],
        },
        {
          array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7],
        },
        {
          array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57],
        },
        {
          array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57],
        },
        {
          array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7],
        },
        {
          array: [1, 2, 3, 4, 5, 6, 8, 7, 9, 10, 11],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 18, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 18, 21, 22, 7, 14, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 19, 4, 14, 11, 6, 33, 35, 41, 55,
          ],
        },
        {
          array: [
            1, 2, 20, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
            19,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            2,
          ],
        },
        {
          array: [
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
            20,
          ],
        },
        {
          array: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89],
        },
      ],
      changelog: [],
      id: 28,
    },
    {
      uid: "largest-range",
      testStrategy: "JSON",
      name: "Largest Range",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Arrays",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 18933,
        failureCount: 9612,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "241819502",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1107,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns an array of\n  length 2 representing the largest range of integers contained in that array.\n</p>\n<p>\n  The first number in the output array should be the first number in the range,\n  while the second number should be the last number in the range.\n</p>\n<p>\n  A range of numbers is defined as a set of numbers that come right after each\n  other in the set of real integers. For instance, the output array\n  <span>[2, 6]</span> represents the range <span>{2, 3, 4, 5, 6}</span>, which\n  is a range of length 5. Note that numbers don\'t need to be sorted or adjacent\n  in the input array in order to form a range.\n</p>\n<p>You can assume that there will only be one largest range.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 7]\n</pre>\n</div>',
      hints: [
        "<p>\nHow can you use a hash table to solve this problem with an algorithm that runs in linear time?\n</p>\n",
        '\n<p>\nIterate through the input array once, storing every unique number in a hash table and mapping every number to a falsy value. This hash table will not only provide for fast access of the numbers in the input array, but it will also allow you to keep track of "visited" and "unvisited" numbers, so as not to unnecessarily repeat work.\n</p>\n',
        '\n<p>\nIterate through the input array once more, this time stopping at every number to check if the number is marked as "visited" in the hash table. If it is, skip it; if it isn\'t, start expanding outwards from that number with a left number and a right number, continuously checking if those left and right numbers are in the hash table (and thus in the input array), and marking them as "visited" in the hash table if they are. This should allow you to quickly find the largest range in which the current number is contained, all the while setting you up not to perform unnecessary work later.\n</p>',
      ],
      spaceTime:
        "O(n) time | O(n) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<int> largestRange(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// O(n) time | O(n) space\nvector<int> largestRange(vector<int> array) {\n  vector<int> bestRange = {};\n  int longestLength = 0;\n  unordered_map<int, bool> nums = {};\n  for (int num : array) {\n    nums[num] = true;\n  }\n  for (int num : array) {\n    if (!nums[num]) {\n      continue;\n    }\n    nums[num] = false;\n    int currentLength = 1;\n    int left = num - 1;\n    int right = num + 1;\n    while (nums.find(left) != nums.end()) {\n      nums[left] = false;\n      currentLength++;\n      left--;\n    }\n    while (nums.find(right) != nums.end()) {\n      nums[right] = false;\n      currentLength++;\n      right++;\n    }\n    if (currentLength > longestLength) {\n      longestLength = currentLength;\n      bestRange = {left + 1, right - 1};\n    }\n  }\n  return bestRange;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{0, 7};\n      assert(largestRange({1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6}) ==\n             expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> expected{0, 7};\n      assert(largestRange({1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6}) ==\n             expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int[] LargestRange(int[] array) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n) time | O(n) space\n\tpublic static int[] LargestRange(int[] array) {\n\t\tint[] bestRange = new int[2];\n\t\tint longestLength = 0;\n\t\tHashSet<int> nums = new HashSet<int>();\n\t\tforeach (int num in array) {\n\t\t\tnums.Add(num);\n\t\t}\n\t\tforeach (int num in array) {\n\t\t\tif (!nums.Contains(num)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnums.Remove(num);\n\t\t\tint currentLength = 1;\n\t\t\tint left = num - 1;\n\t\t\tint right = num + 1;\n\t\t\twhile (nums.Contains(left)) {\n\t\t\t\tnums.Remove(left);\n\t\t\t\tcurrentLength++;\n\t\t\t\tleft--;\n\t\t\t}\n\t\t\twhile (nums.Contains(right)) {\n\t\t\t\tnums.Remove(right);\n\t\t\t\tcurrentLength++;\n\t\t\t\tright++;\n\t\t\t}\n\t\t\tif (currentLength > longestLength) {\n\t\t\t\tlongestLength = currentLength;\n\t\t\t\tbestRange = new int[] {left + 1, right - 1};\n\t\t\t}\n\t\t}\n\t\treturn bestRange;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase6() {\n\t\tint[] expected = {0, 7};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.LargestRange(new int[] {1, 11, 3,\n\t\t                                                                          0, 15, 5,\n\t\t                                                                          2, 4, 10,\n\t\t                                                                          7, 12,\n\t\t                                                                          6}),\n\t\t  expected));\n\t}\n}\n",
          unitTests:
            "using System.Linq;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase6() {\n\t\tint[] expected = {0, 7};\n\t\tUtils.AssertTrue(Enumerable.SequenceEqual(Program.LargestRange(new int[] {1, 11, 3,\n\t\t                                                                          0, 15, 5,\n\t\t                                                                          2, 4, 10,\n\t\t                                                                          7, 12,\n\t\t                                                                          6}),\n\t\t  expected));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc LargestRange(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space\nfunc LargestRange(array []int) []int {\n\tbest := []int{}\n\tlongestLength := 0\n\tnums := map[int]bool{}\n\tfor _, num := range array {\n\t\tnums[num] = true\n\t}\n\tfor _, num := range array {\n\t\tif !nums[num] {\n\t\t\tcontinue\n\t\t}\n\t\tnums[num] = false\n\t\tcurrentLength, left, right := 1, num-1, num+1\n\t\tfor nums[left] {\n\t\t\tnums[left] = false\n\t\t\tcurrentLength += 1\n\t\t\tleft -= 1\n\t\t}\n\t\tfor nums[right] {\n\t\t\tnums[right] = false\n\t\t\tcurrentLength += 1\n\t\t\tright += 1\n\t\t}\n\t\tif currentLength > longestLength {\n\t\t\tlongestLength = currentLength\n\t\t\tbest = []int{left + 1, right - 1}\n\t\t}\n\t}\n\treturn best\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{0, 7}\n\toutput := LargestRange([]int{1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6})\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []int{0, 7}\n\toutput := LargestRange([]int{1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6})\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int[] largestRange(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space\n  public static int[] largestRange(int[] array) {\n    int[] bestRange = new int[2];\n    int longestLength = 0;\n    Map<Integer, Boolean> nums = new HashMap<Integer, Boolean>();\n    for (int num : array) {\n      nums.put(num, true);\n    }\n    for (int num : array) {\n      if (!nums.get(num)) {\n        continue;\n      }\n      nums.put(num, false);\n      int currentLength = 1;\n      int left = num - 1;\n      int right = num + 1;\n      while (nums.containsKey(left)) {\n        nums.put(left, false);\n        currentLength++;\n        left--;\n      }\n      while (nums.containsKey(right)) {\n        nums.put(right, false);\n        currentLength++;\n        right++;\n      }\n      if (currentLength > longestLength) {\n        longestLength = currentLength;\n        bestRange = new int[] {left + 1, right - 1};\n      }\n    }\n    return bestRange;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {0, 7};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.largestRange(new int[] {1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6}), expected));\n  }\n}\n",
          unitTests:
            "import java.util.Arrays;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] expected = {0, 7};\n    Utils.assertTrue(\n        Arrays.equals(\n            Program.largestRange(new int[] {1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6}), expected));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function largestRange(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.largestRange = largestRange;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nfunction largestRange(array) {\n  let bestRange = [];\n  let longestLength = 0;\n  const nums = {};\n  for (const num of array) {\n    nums[num] = true;\n  }\n  for (const num of array) {\n    if (!nums[num]) continue;\n    nums[num] = false;\n    let currentLength = 1;\n    let left = num - 1;\n    let right = num + 1;\n    while (left in nums) {\n      nums[left] = false;\n      currentLength++;\n      left--;\n    }\n    while (right in nums) {\n      nums[right] = false;\n      currentLength++;\n      right++;\n    }\n    if (currentLength > longestLength) {\n      longestLength = currentLength;\n      bestRange = [left + 1, right - 1];\n    }\n  }\n  return bestRange;\n}\n\nexports.largestRange = largestRange;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun largestRange(array: List<Int>): Pair<Int, Int> {\n    // Write your code here.\n    return Pair(-1, -1)\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space\nfun largestRange(array: List<Int>): Pair<Int, Int> {\n    var bestRange = Pair(array[0], array[0])\n    var longestLength = 0\n    val nums = mutableMapOf<Int, Boolean>()\n    for (num in array) {\n        nums[num] = true\n    }\n    for (num in array) {\n        if (nums[num] == false) continue\n        nums[num] = false\n        var currentLength = 1\n        var left = num - 1\n        var right = num + 1\n        while (nums.containsKey(left)) {\n            nums[left] = false\n            currentLength++\n            left--\n        }\n        while (nums.containsKey(right)) {\n            nums[right] = false\n            currentLength++\n            right++\n        }\n        if (currentLength > longestLength) {\n            longestLength = currentLength\n            bestRange = Pair(left + 1, right - 1)\n        }\n    }\n    return bestRange\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.largestRange as largestRange\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6)\n        val output = largestRange(array)\n        val expected = Pair(0, 7)\n        assert(output == expected)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.largestRange as largestRange\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val array = listOf(1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6)\n        val output = largestRange(array)\n        val expected = Pair(0, 7)\n        assert(output == expected)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def largestRange(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space\ndef largestRange(array):\n    bestRange = []\n    longestLength = 0\n    nums = {}\n    for num in array:\n        nums[num] = True\n    for num in array:\n        if not nums[num]:\n            continue\n        nums[num] = False\n        currentLength = 1\n        left = num - 1\n        right = num + 1\n        while left in nums:\n            nums[left] = False\n            currentLength += 1\n            left -= 1\n        while right in nums:\n            nums[right] = False\n            currentLength += 1\n            right += 1\n        if currentLength > longestLength:\n            longestLength = currentLength\n            bestRange = [left + 1, right - 1]\n    return bestRange\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]), [0, 7])\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]), [0, 7])\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def largestRange(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def largestRange(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.largestRange\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.largestRange\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func largestRange(array: [Int]) -> [Int] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space\n  func largestRange(array: [Int]) -> [Int] {\n    var longestLength = 0\n    var bestRange = [Int]()\n    var hash = [Int: Bool]()\n\n    for number in array {\n      hash[number] = true\n    }\n\n    for number in array {\n      if let hashAtNumber = hash[number], !hashAtNumber {\n        continue\n      }\n\n      var currentLength = 1\n      var left = number - 1\n      var right = number + 1\n\n      while hash.keys.contains(left) {\n        hash[left] = false\n        currentLength += 1\n        left -= 1\n      }\n\n      while hash.keys.contains(right) {\n        hash[right] = false\n        currentLength += 1\n        right += 1\n      }\n\n      if currentLength > longestLength {\n        bestRange = [left + 1, right - 1]\n        longestLength = currentLength\n      }\n    }\n\n    return bestRange\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual([0, 7], program.largestRange(array: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual([0, 7], program.largestRange(array: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function largestRange(array: number[]): [number, number] {\n  // Write your code here.\n  return [-1, -1];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space\nexport function largestRange(array: number[]) {\n  let bestRange: [number, number] = [-1, -1];\n  let longestLength = 0;\n  const nums: {[key: number]: boolean} = {};\n  for (const num of array) {\n    nums[num] = true;\n  }\n  for (const num of array) {\n    if (!nums[num]) continue;\n    nums[num] = false;\n    let currentLength = 1;\n    let left = num - 1;\n    let right = num + 1;\n    while (left in nums) {\n      nums[left] = false;\n      currentLength++;\n      left--;\n    }\n    while (right in nums) {\n      nums[right] = false;\n      currentLength++;\n      right++;\n    }\n    if (currentLength > longestLength) {\n      longestLength = currentLength;\n      bestRange = [left + 1, right - 1];\n    }\n  }\n  return bestRange;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [4, 2, 1, 3],
        },
        {
          array: [4, 2, 1, 3, 6],
        },
        {
          array: [8, 4, 2, 10, 3, 6, 7, 9, 1],
        },
        {
          array: [
            19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12, 12, 2,
            1, 6, 13, 14,
          ],
        },
        {
          array: [
            0, 9, 19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12,
            12, 2, 1, 6, 13, 14,
          ],
        },
        {
          array: [
            0, -5, 9, 19, -1, 18, 17, 2, -4, -3, 10, 3, 12, 5, 16, 4, 11, 7, -6,
            -7, 6, 15, 12, 12, 2, 1, 6, 13, 14, -2,
          ],
        },
        {
          array: [
            -7, -7, -7, -7, 8, -8, 0, 9, 19, -1, -3, 18, 17, 2, 10, 3, 12, 5,
            16, 4, 11, -6, 8, 7, 6, 15, 12, 12, -5, 2, 1, 6, 13, 14, -4, -2,
          ],
        },
        {
          array: [1, 1, 1, 3, 4],
        },
        {
          array: [-1, 0, 1],
        },
        {
          array: [10, 0, 1],
        },
      ],
      jsonTests: [
        {
          array: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6],
        },
        {
          array: [1],
        },
        {
          array: [1, 2],
        },
        {
          array: [4, 2, 1, 3],
        },
        {
          array: [4, 2, 1, 3, 6],
        },
        {
          array: [8, 4, 2, 10, 3, 6, 7, 9, 1],
        },
        {
          array: [
            19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12, 12, 2,
            1, 6, 13, 14,
          ],
        },
        {
          array: [
            0, 9, 19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12,
            12, 2, 1, 6, 13, 14,
          ],
        },
        {
          array: [
            0, -5, 9, 19, -1, 18, 17, 2, -4, -3, 10, 3, 12, 5, 16, 4, 11, 7, -6,
            -7, 6, 15, 12, 12, 2, 1, 6, 13, 14, -2,
          ],
        },
        {
          array: [
            -7, -7, -7, -7, 8, -8, 0, 9, 19, -1, -3, 18, 17, 2, 10, 3, 12, 5,
            16, 4, 11, -6, 8, 7, 6, 15, 12, 12, -5, 2, 1, 6, 13, 14, -4, -2,
          ],
        },
        {
          array: [1, 1, 1, 3, 4],
        },
        {
          array: [-1, 0, 1],
        },
        {
          array: [10, 0, 1],
        },
      ],
      changelog: [],
      id: 29,
    },
    {
      uid: "longest-common-subsequence",
      testStrategy: "JSON",
      name: "Longest Common Subsequence",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Dynamic Programming",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 10164,
        failureCount: 4048,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "224893526",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1894,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in two strings and returns their longest common\n  subsequence.\n</p>\n<p>\n  A subsequence of a string is a set of characters that aren\'t necessarily\n  adjacent in the string but that are in the same order as they appear in the\n  string. For instance, the characters <span>["a", "c", "d"]</span> form a\n  subsequence of the string <span>"abcd"</span>, and so do the characters\n  <span>["b", "d"]</span>. Note that a single character in a string and the\n  string itself are both valid subsequences of the string.\n</p>\n<p>\n  You can assume that there will only be one longest common subsequence.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">str1</span> = "ZXVVYZW"\n<span class="CodeEditor-promptParameter">str2</span> = "XKYKZPW"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["X", "Y", "Z", "W"]\n</pre>\n</div>',
      hints: [
        "<p>\nTry building a two-dimensional array of the longest common subsequences of substring pairs of the input strings. Let the rows of the array represent substrings of the second input string str2. Let the first row represent the empty string. Let each row i thereafter represent the substrings of str2 from 0 to i, with i excluded. Let the columns similarly represent the first input string str1.\n</p>\n",
        "\n<p>\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the longest common subsequences for all the substrings of str1 represented by the columns and the empty string represented by the first row, then for all the substrings of str1 represented by the columns and the first letter of str2 represented by the second row, etc., until you compare both full strings. Find a formula that relates the longest common subsequence at any given point to previous subsequences.\n</p>\n",
        "\n<p>\nDo you really need to build and store subsequences at each point in the two-dimensional array mentioned in Hint #1? Try storing booleans to determine whether or not a letter at a given point in the two-dimensional array is part of the longest common subsequence as well as pointers to determine what should come before this letter in the final subsequence. Use these pointers to backtrack your way through the array and to build up the longest common subsequence at the end of your algorithm.\n</p>",
      ],
      spaceTime:
        "O(nm) time | O(nm) space - where n and m are the lengths of the two input strings",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<char> longestCommonSubsequence(string str1, string str2) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nvector<char> longestCommonSubsequence(string str1, string str2) {\n  vector<vector<vector<char>>> lcs;\n  for (int i = 0; i < str2.length() + 1; i++) {\n    lcs.push_back(vector<vector<char>>());\n    for (int j = 0; j < str1.length() + 1; j++) {\n      lcs[i].push_back(vector<char>());\n    }\n  }\n  for (int i = 1; i < str2.length() + 1; i++) {\n    for (int j = 1; j < str1.length() + 1; j++) {\n      if (str2[i - 1] == str1[j - 1]) {\n        vector<char> copy = lcs[i - 1][j - 1];\n        copy.push_back(str2[i - 1]);\n        lcs[i][j] = copy;\n      } else {\n        lcs[i][j] = lcs[i - 1][j].size() > lcs[i][j - 1].size() ? lcs[i - 1][j]\n                                                                : lcs[i][j - 1];\n      }\n    }\n  }\n  return lcs[str2.length()][str1.length()];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\n// O(nm*min(n, m)) time | O((min(n, m))^2) space\nvector<char> longestCommonSubsequence(string str1, string str2) {\n  string small = str1.length() < str2.length() ? str1 : str2;\n  string big = str1.length() >= str2.length() ? str1 : str2;\n  vector<vector<char>> evenLcs;\n  vector<vector<char>> oddLcs;\n  for (int i = 0; i < small.length() + 1; i++) {\n    evenLcs.push_back(vector<char>());\n  }\n  for (int i = 0; i < small.length() + 1; i++) {\n    oddLcs.push_back(vector<char>());\n  }\n  for (int i = 1; i < big.length() + 1; i++) {\n    vector<vector<char>> *currentLcs;\n    vector<vector<char>> *previousLcs;\n    if (i % 2 == 1) {\n      currentLcs = &oddLcs;\n      previousLcs = &evenLcs;\n    } else {\n      currentLcs = &evenLcs;\n      previousLcs = &oddLcs;\n    }\n    for (int j = 1; j < small.length() + 1; j++) {\n      if (big[i - 1] == small[j - 1]) {\n        vector<char> copy = previousLcs->at(j - 1);\n        copy.push_back(big[i - 1]);\n        currentLcs->at(j) = copy;\n      } else {\n        currentLcs->at(j) =\n            previousLcs->at(j).size() > currentLcs->at(j - 1).size()\n                ? previousLcs->at(j)\n                : currentLcs->at(j - 1);\n      }\n    }\n  }\n  return big.length() % 2 == 0 ? evenLcs[small.length()]\n                               : oddLcs[small.length()];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvector<char> buildSequence(vector<vector<vector<int>>> lcs);\n\n// O(nm) time | O(nm) space\nvector<char> longestCommonSubsequence(string str1, string str2) {\n  vector<vector<vector<int>>> lcs(\n      str2.length() + 1,\n      vector<vector<int>>(str1.length() + 1, vector<int>(4, 0)));\n  for (int i = 1; i < str2.length() + 1; i++) {\n    for (int j = 1; j < str1.length() + 1; j++) {\n      if (str2[i - 1] == str1[j - 1]) {\n        lcs[i][j] = {str2[i - 1], lcs[i - 1][j - 1][1] + 1, i - 1, j - 1};\n      } else {\n        if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n          lcs[i][j] = {-1, lcs[i - 1][j][1], i - 1, j};\n        } else {\n          lcs[i][j] = {-1, lcs[i][j - 1][1], i, j - 1};\n        }\n      }\n    }\n  }\n  return buildSequence(lcs);\n}\n\nvector<char> buildSequence(vector<vector<vector<int>>> lcs) {\n  vector<char> sequence;\n  int i = lcs.size() - 1;\n  int j = lcs[0].size() - 1;\n  while (i != 0 && j != 0) {\n    vector<int> currentEntry = lcs[i][j];\n    if (currentEntry[0] != -1) {\n      sequence.insert(sequence.begin(), currentEntry[0]);\n    }\n    i = currentEntry[2];\n    j = currentEntry[3];\n  }\n  return sequence;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nvector<char> buildSequence(vector<vector<int>> lengths, string str);\n\n// O(nm) time | O(nm) space\nvector<char> longestCommonSubsequence(string str1, string str2) {\n  vector<vector<int>> lengths(str2.length() + 1,\n                              vector<int>(str1.length() + 1, 0));\n  for (int i = 1; i < str2.length() + 1; i++) {\n    for (int j = 1; j < str1.length() + 1; j++) {\n      if (str2[i - 1] == str1[j - 1]) {\n        lengths[i][j] = lengths[i - 1][j - 1] + 1;\n      } else {\n        lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1]);\n      }\n    }\n  }\n  return buildSequence(lengths, str1);\n}\n\nvector<char> buildSequence(vector<vector<int>> lengths, string str) {\n  vector<char> sequence;\n  int i = lengths.size() - 1;\n  int j = lengths[0].size() - 1;\n  while (i != 0 && j != 0) {\n    if (lengths[i][j] == lengths[i - 1][j]) {\n      i--;\n    } else if (lengths[i][j] == lengths[i][j - 1]) {\n      j--;\n    } else {\n      sequence.insert(sequence.begin(), str[j - 1]);\n      i--;\n      j--;\n    }\n  }\n  return sequence;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<char> expected{'X', 'Y', 'Z', 'W'};\n      assert(longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\") == expected);\n    });\n  }\n};\n",
          unitTests:
            "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<char> expected{'X', 'Y', 'Z', 'W'};\n      assert(longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\") == expected);\n    });\n  }\n};\n",
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic static List<char> LongestCommonSubsequence(string str1, string str2) {\n\t\t// Write your code here.\n\t\treturn new List<char>();\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(nm*min(n, m)) time | O(nm*min(n, m)) space\n\tpublic static List<char> LongestCommonSubsequence(string str1, string str2) {\n\t\tList<List<List<char> > > lcs = new List<List<List<char> > >();\n\t\tfor (int i = 0; i < str2.Length + 1; i++) {\n\t\t\tlcs.Add(new List<List<char> >());\n\t\t\tfor (int j = 0; j < str1.Length + 1; j++) {\n\t\t\t\tlcs[i].Add(new List<char>());\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < str2.Length + 1; i++) {\n\t\t\tfor (int j = 1; j < str1.Length + 1; j++) {\n\t\t\t\tif (str2[i - 1] == str1[j - 1]) {\n\t\t\t\t\tList<char> copy = new List<char>(lcs[i - 1][j - 1]);\n\t\t\t\t\tlcs[i][j] =  copy;\n\t\t\t\t\tlcs[i][j].Add(str2[i - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tif (lcs[i - 1][j].Count > lcs[i][j - 1].Count) {\n\t\t\t\t\t\tlcs[i][j] =  lcs[i - 1][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlcs[i][j] =  lcs[i][j - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lcs[str2.Length][str1.Length];\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(nm*min(n, m)) time | O((min(n, m))^2) space\n\tpublic static List<char> LongestCommonSubsequence(string str1, string str2) {\n\t\tstring small = str1.Length < str2.Length ? str1 : str2;\n\t\tstring big = str1.Length >= str2.Length ? str1 : str2;\n\t\tList<List<char> > evenLcs = new List<List<char> >();\n\t\tList<List<char> > oddLcs = new List<List<char> >();\n\t\tfor (int i = 0; i < small.Length + 1; i++) {\n\t\t\tevenLcs.Add(new List<char>());\n\t\t}\n\t\tfor (int i = 0; i < small.Length + 1; i++) {\n\t\t\toddLcs.Add(new List<char>());\n\t\t}\n\t\tfor (int i = 1; i < big.Length + 1; i++) {\n\t\t\tList<List<char> > currentLcs;\n\t\t\tList<List<char> > previousLcs;\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tcurrentLcs = oddLcs;\n\t\t\t\tpreviousLcs = evenLcs;\n\t\t\t} else {\n\t\t\t\tcurrentLcs = evenLcs;\n\t\t\t\tpreviousLcs = oddLcs;\n\t\t\t}\n\t\t\tfor (int j = 1; j < small.Length + 1; j++) {\n\t\t\t\tif (big[i - 1] == small[j - 1]) {\n\t\t\t\t\tList<char> copy = new List<char>(previousLcs[j - 1]);\n\t\t\t\t\tcurrentLcs[j] =  copy;\n\t\t\t\t\tcurrentLcs[j].Add(big[i - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tif (previousLcs[j].Count > currentLcs[j - 1].Count) {\n\t\t\t\t\t\tcurrentLcs[j] =  previousLcs[j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentLcs[j] =  currentLcs[j - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn big.Length % 2 == 0 ? evenLcs[small.Length] : oddLcs[small.Length];\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(nm) time | O(nm) space\n\tpublic static List<char> LongestCommonSubsequence(string str1, string str2) {\n\t\tint[,][] lcs = new int[str2.Length + 1,str1.Length + 1][];\n\t\tfor (int i = 0; i < str2.Length + 1; i++) {\n\t\t\tfor (int j = 0; j < str1.Length + 1; j++) {\n\t\t\t\tlcs[i,j] = new int[] {0, 0, 0, 0};\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < str2.Length + 1; i++) {\n\t\t\tfor (int j = 1; j < str1.Length + 1; j++) {\n\t\t\t\tif (str2[i - 1] == str1[j - 1]) {\n\t\t\t\t\tint[] newEntry =\n\t\t\t\t\t{(int)str2[i - 1], lcs[i - 1,j - 1][1] + 1, i - 1, j - 1};\n\t\t\t\t\tlcs[i,j] = newEntry;\n\t\t\t\t} else {\n\t\t\t\t\tif (lcs[i - 1,j][1] > lcs[i,j - 1][1]) {\n\t\t\t\t\t\tint[] newEntry = {-1, lcs[i - 1,j][1], i - 1, j};\n\t\t\t\t\t\tlcs[i,j] = newEntry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint[] newEntry = {-1, lcs[i,j - 1][1], i, j - 1};\n\t\t\t\t\t\tlcs[i,j] = newEntry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buildSequence(lcs);\n\t}\n\n\tpublic static List<char> buildSequence(int[,][] lcs) {\n\t\tList<char> sequence = new List<char>();\n\t\tint i = lcs.GetLength(0) - 1;\n\t\tint j = lcs.GetLength(1) - 1;\n\t\twhile (i != 0 && j != 0) {\n\t\t\tint[] currentEntry = lcs[i,j];\n\t\t\tif (currentEntry[0] != -1) {\n\t\t\t\tsequence.Insert(0, (char)currentEntry[0]);\n\t\t\t}\n\t\t\ti = currentEntry[2];\n\t\t\tj = currentEntry[3];\n\t\t}\n\t\treturn sequence;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(nm) time | O(nm) space\n\tpublic static List<char> LongestCommonSubsequence(string str1, string str2) {\n\t\tint[,] lengths = new int[str2.Length + 1,str1.Length + 1];\n\t\tfor (int i = 1; i < str2.Length + 1; i++) {\n\t\t\tfor (int j = 1; j < str1.Length + 1; j++) {\n\t\t\t\tif (str2[i - 1] == str1[j - 1]) {\n\t\t\t\t\tlengths[i,j] = lengths[i - 1,j - 1] + 1;\n\t\t\t\t} else {\n\t\t\t\t\tlengths[i,j] = Math.Max(lengths[i - 1,j], lengths[i,j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buildSequence(lengths, str1);\n\t}\n\n\tpublic static List<char> buildSequence(int[,] lengths, string str) {\n\t\tList<char> sequence = new List<char>();\n\t\tint i = lengths.GetLength(0) - 1;\n\t\tint j = lengths.GetLength(1) - 1;\n\t\twhile (i != 0 && j != 0) {\n\t\t\tif (lengths[i,j] == lengths[i - 1,j]) {\n\t\t\t\ti--;\n\t\t\t} else if (lengths[i,j] == lengths[i,j - 1]) {\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tsequence.Insert(0, str[j - 1]);\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn sequence;\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tchar[] expected = {'X', 'Y', 'Z', 'W'};\n\t\tUtils.AssertTrue(compare(Program.LongestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\"),\n\t\t  expected));\n\t}\n\n\tprivate static bool compare(List<char> arr1, char[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
          unitTests:
            "using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tchar[] expected = {'X', 'Y', 'Z', 'W'};\n\t\tUtils.AssertTrue(compare(Program.LongestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\"),\n\t\t  expected));\n\t}\n\n\tprivate static bool compare(List<char> arr1, char[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nfunc LongestCommonSubsequence(s1 string, s2 string) []byte {\n\t// Write your code here.\n\treturn []byte{}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nfunc LongestCommonSubsequence(s1 string, s2 string) []byte {\n\tlcs := make([][][]byte, len(s2)+1)\n\tfor i := range lcs {\n\t\tlcs[i] = make([][]byte, len(s1)+1)\n\t}\n\tfor i := 1; i < len(lcs); i++ {\n\t\tfor j := 1; j < len(lcs[i]); j++ {\n\t\t\tif s2[i-1] == s1[j-1] {\n\t\t\t\ttmp := make([]byte, len(lcs[i-1][j-1]))\n\t\t\t\tcopy(tmp, lcs[i-1][j-1])\n\t\t\t\tlcs[i][j] = append(tmp, s2[i-1])\n\t\t\t} else {\n\t\t\t\tif len(lcs[i-1][j]) < len(lcs[i][j-1]) {\n\t\t\t\t\tlcs[i][j] = lcs[i][j-1]\n\t\t\t\t} else {\n\t\t\t\t\tlcs[i][j] = lcs[i-1][j]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn lcs[len(s2)][len(s1)]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(nm*min(n, m)) time | O((min(n, m))^2) space\nfunc LongestCommonSubsequence(s1 string, s2 string) []byte {\n\tsmall, big := s1, s2\n\tif len(s1) > len(s2) {\n\t\tsmall, big = big, small\n\t}\n\tevenlcs := make([][]byte, len(small)+1)\n\toddlcs := make([][]byte, len(small)+1)\n\tcurrentlcs, previouslcs := evenlcs, oddlcs\n\tfor i := 1; i < len(big)+1; i++ {\n\t\tif i%2 == 1 {\n\t\t\tcurrentlcs, previouslcs = oddlcs, evenlcs\n\t\t} else {\n\t\t\tcurrentlcs, previouslcs = evenlcs, oddlcs\n\t\t}\n\t\tfor j := 1; j < len(small)+1; j++ {\n\t\t\tif big[i-1] == small[j-1] {\n\t\t\t\ttmp := make([]byte, len(previouslcs[j-1]))\n\t\t\t\tcopy(tmp, previouslcs[j-1])\n\t\t\t\tcurrentlcs[j] = append(tmp, big[i-1])\n\t\t\t} else {\n\t\t\t\tif len(previouslcs[j]) > len(currentlcs[j-1]) {\n\t\t\t\t\tcurrentlcs[j] = previouslcs[j]\n\t\t\t\t} else {\n\t\t\t\t\tcurrentlcs[j] = currentlcs[j-1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(big)%2 == 0 {\n\t\treturn evenlcs[len(small)]\n\t} else {\n\t\treturn oddlcs[len(small)]\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype entry struct {\n\tletter byte\n\tlength int\n\tprevi  int\n\tprevj  int\n}\n\n// O(nm) time | O(nm) space\nfunc LongestCommonSubsequence(str1 string, str2 string) []byte {\n\tlcs := make([][]entry, len(str2)+1)\n\tfor i := range lcs {\n\t\tlcs[i] = make([]entry, len(str1)+1)\n\t\tfor j := range lcs[i] {\n\t\t\tlcs[i][j].letter = 0\n\t\t\tlcs[i][j].length = 0\n\t\t\tlcs[i][j].previ = -1\n\t\t\tlcs[i][j].prevj = -1\n\t\t}\n\t}\n\n\tfor i := 1; i < len(str2)+1; i++ {\n\t\tfor j := 1; j < len(str1)+1; j++ {\n\t\t\tif str2[i-1] == str1[j-1] {\n\t\t\t\tlcs[i][j] = entry{str2[i-1], lcs[i-1][j-1].length + 1, i - 1, j - 1}\n\t\t\t} else {\n\t\t\t\tif lcs[i-1][j].length > lcs[i][j-1].length {\n\t\t\t\t\tlcs[i][j] = entry{0, lcs[i-1][j].length, i - 1, j}\n\t\t\t\t} else {\n\t\t\t\t\tlcs[i][j] = entry{0, lcs[i][j-1].length, i, j - 1}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn buildSequence(lcs)\n}\n\nfunc buildSequence(lcs [][]entry) []byte {\n\tsequence := make([]byte, 0)\n\ti := len(lcs) - 1\n\tj := len(lcs[0]) - 1\n\tfor i != 0 && j != 0 {\n\t\tcurrent := lcs[i][j]\n\t\tif current.letter != 0 {\n\t\t\tsequence = append(sequence, current.letter)\n\t\t}\n\t\ti = current.previ\n\t\tj = current.prevj\n\t}\n\treturn reverse(sequence)\n}\n\nfunc reverse(arr []byte) []byte {\n\tfor i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n\treturn arr\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(nm) time | O(nm) space\nfunc LongestCommonSubsequence(str1 string, str2 string) []byte {\n\tlengths := make([][]int, len(str2)+1)\n\tfor i := range lengths {\n\t\tlengths[i] = make([]int, len(str1)+1)\n\t}\n\tfor i := 1; i < len(str2)+1; i++ {\n\t\tfor j := 1; j < len(str1)+1; j++ {\n\t\t\tif str2[i-1] == str1[j-1] {\n\t\t\t\tlengths[i][j] = lengths[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tlengths[i][j] = max(lengths[i-1][j], lengths[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buildSequence(lengths, str1)\n}\n\nfunc buildSequence(lengths [][]int, str1 string) []byte {\n\tsequence := make([]byte, 0)\n\ti := len(lengths) - 1\n\tj := len(lengths[0]) - 1\n\tfor i != 0 && j != 0 {\n\t\tif lengths[i][j] == lengths[i-1][j] {\n\t\t\ti -= 1\n\t\t} else if lengths[i][j] == lengths[i][j-1] {\n\t\t\tj -= 1\n\t\t} else {\n\t\t\tsequence = append(sequence, str1[j-1])\n\t\t\ti -= 1\n\t\t\tj -= 1\n\t\t}\n\t}\n\treturn reverse(sequence)\n}\n\nfunc reverse(arr []byte) []byte {\n\tfor i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n\treturn arr\n}\n\nfunc max(i, j int) int {\n\tif i > j {\n\t\treturn i\n\t}\n\treturn j\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []byte("XYZW")\n\toutput := LongestCommonSubsequence("ZXVVYZW", "XKYKZPW")\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []byte("XYZW")\n\toutput := LongestCommonSubsequence("ZXVVYZW", "XKYKZPW")\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static List<Character> longestCommonSubsequence(String str1, String str2) {\n    // Write your code here.\n    return new ArrayList<Character>();\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nm*min(n, m)) time | O(nm*min(n, m)) space\n  public static List<Character> longestCommonSubsequence(String str1, String str2) {\n    List<List<List<Character>>> lcs = new ArrayList<List<List<Character>>>();\n    for (int i = 0; i < str2.length() + 1; i++) {\n      lcs.add(new ArrayList<List<Character>>());\n      for (int j = 0; j < str1.length() + 1; j++) {\n        lcs.get(i).add(new ArrayList<Character>());\n      }\n    }\n    for (int i = 1; i < str2.length() + 1; i++) {\n      for (int j = 1; j < str1.length() + 1; j++) {\n        if (str2.charAt(i - 1) == str1.charAt(j - 1)) {\n          List<Character> copy = new ArrayList<Character>(lcs.get(i - 1).get(j - 1));\n          lcs.get(i).set(j, copy);\n          lcs.get(i).get(j).add(str2.charAt(i - 1));\n        } else {\n          if (lcs.get(i - 1).get(j).size() > lcs.get(i).get(j - 1).size()) {\n            lcs.get(i).set(j, lcs.get(i - 1).get(j));\n          } else {\n            lcs.get(i).set(j, lcs.get(i).get(j - 1));\n          }\n        }\n      }\n    }\n    return lcs.get(str2.length()).get(str1.length());\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nm*min(n, m)) time | O((min(n, m))^2) space\n  public static List<Character> longestCommonSubsequence(String str1, String str2) {\n    String small = str1.length() < str2.length() ? str1 : str2;\n    String big = str1.length() >= str2.length() ? str1 : str2;\n    List<List<Character>> evenLcs = new ArrayList<List<Character>>();\n    List<List<Character>> oddLcs = new ArrayList<List<Character>>();\n    for (int i = 0; i < small.length() + 1; i++) {\n      evenLcs.add(new ArrayList<Character>());\n    }\n    for (int i = 0; i < small.length() + 1; i++) {\n      oddLcs.add(new ArrayList<Character>());\n    }\n    for (int i = 1; i < big.length() + 1; i++) {\n      List<List<Character>> currentLcs;\n      List<List<Character>> previousLcs;\n      if (i % 2 == 1) {\n        currentLcs = oddLcs;\n        previousLcs = evenLcs;\n      } else {\n        currentLcs = evenLcs;\n        previousLcs = oddLcs;\n      }\n      for (int j = 1; j < small.length() + 1; j++) {\n        if (big.charAt(i - 1) == small.charAt(j - 1)) {\n          List<Character> copy = new ArrayList<Character>(previousLcs.get(j - 1));\n          currentLcs.set(j, copy);\n          currentLcs.get(j).add(big.charAt(i - 1));\n        } else {\n          if (previousLcs.get(j).size() > currentLcs.get(j - 1).size()) {\n            currentLcs.set(j, previousLcs.get(j));\n          } else {\n            currentLcs.set(j, currentLcs.get(j - 1));\n          }\n        }\n      }\n    }\n    return big.length() % 2 == 0 ? evenLcs.get(small.length()) : oddLcs.get(small.length());\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nm) time | O(nm) space\n  public static List<Character> longestCommonSubsequence(String str1, String str2) {\n    int[][][] lcs = new int[str2.length() + 1][str1.length() + 1][];\n    for (int i = 0; i < str2.length() + 1; i++) {\n      for (int j = 0; j < str1.length() + 1; j++) {\n        lcs[i][j] = new int[] {0, 0, 0, 0};\n      }\n    }\n    for (int i = 1; i < str2.length() + 1; i++) {\n      for (int j = 1; j < str1.length() + 1; j++) {\n        if (str2.charAt(i - 1) == str1.charAt(j - 1)) {\n          int[] newEntry = {(int) str2.charAt(i - 1), lcs[i - 1][j - 1][1] + 1, i - 1, j - 1};\n          lcs[i][j] = newEntry;\n        } else {\n          if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n            int[] newEntry = {-1, lcs[i - 1][j][1], i - 1, j};\n            lcs[i][j] = newEntry;\n          } else {\n            int[] newEntry = {-1, lcs[i][j - 1][1], i, j - 1};\n            lcs[i][j] = newEntry;\n          }\n        }\n      }\n    }\n    return buildSequence(lcs);\n  }\n\n  public static List<Character> buildSequence(int[][][] lcs) {\n    List<Character> sequence = new ArrayList<Character>();\n    int i = lcs.length - 1;\n    int j = lcs[0].length - 1;\n    while (i != 0 && j != 0) {\n      int[] currentEntry = lcs[i][j];\n      if (currentEntry[0] != -1) {\n        sequence.add(0, (char) currentEntry[0]);\n      }\n      i = currentEntry[2];\n      j = currentEntry[3];\n    }\n    return sequence;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(nm) time | O(nm) space\n  public static List<Character> longestCommonSubsequence(String str1, String str2) {\n    int[][] lengths = new int[str2.length() + 1][str1.length() + 1];\n    for (int i = 1; i < str2.length() + 1; i++) {\n      for (int j = 1; j < str1.length() + 1; j++) {\n        if (str2.charAt(i - 1) == str1.charAt(j - 1)) {\n          lengths[i][j] = lengths[i - 1][j - 1] + 1;\n        } else {\n          lengths[i][j] = Math.max(lengths[i - 1][j], lengths[i][j - 1]);\n        }\n      }\n    }\n    return buildSequence(lengths, str1);\n  }\n\n  public static List<Character> buildSequence(int[][] lengths, String str) {\n    List<Character> sequence = new ArrayList<Character>();\n    int i = lengths.length - 1;\n    int j = lengths[0].length - 1;\n    while (i != 0 && j != 0) {\n      if (lengths[i][j] == lengths[i - 1][j]) {\n        i--;\n      } else if (lengths[i][j] == lengths[i][j - 1]) {\n        j--;\n      } else {\n        sequence.add(0, str.charAt(j - 1));\n        i--;\n        j--;\n      }\n    }\n    return sequence;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    char[] expected = {'X', 'Y', 'Z', 'W'};\n    Utils.assertTrue(compare(Program.longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\"), expected));\n  }\n\n  private static boolean compare(List<Character> arr1, char[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    char[] expected = {'X', 'Y', 'Z', 'W'};\n    Utils.assertTrue(compare(Program.longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\"), expected));\n  }\n\n  private static boolean compare(List<Character> arr1, char[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function longestCommonSubsequence(str1, str2) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestCommonSubsequence = longestCommonSubsequence;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lcs = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = new Array(str1.length + 1).fill([]);\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = lcs[i - 1][j - 1].concat(str2[i - 1]);\n      } else {\n        lcs[i][j] = lcs[i - 1][j].length > lcs[i][j - 1].length ? lcs[i - 1][j] : lcs[i][j - 1];\n      }\n    }\n  }\n  return lcs[str2.length][str1.length];\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm*min(n, m)) time | O((min(n, m))^2) space\nfunction longestCommonSubsequence(str1, str2) {\n  const small = str1.length < str2.length ? str1 : str2;\n  const big = str1.length >= str2.length ? str1 : str2;\n  const evenLcs = new Array(small.length + 1).fill([]);\n  const oddLcs = new Array(small.length + 1).fill([]);\n  for (let i = 1; i < big.length + 1; i++) {\n    let currentLcs, previousLcs;\n    if (i % 2 === 1) {\n      currentLcs = oddLcs;\n      previousLcs = evenLcs;\n    } else {\n      currentLcs = evenLcs;\n      previousLcs = oddLcs;\n    }\n    for (let j = 1; j < small.length + 1; j++) {\n      if (big[i - 1] === small[j - 1]) {\n        currentLcs[j] = previousLcs[j - 1].concat(big[i - 1]);\n      } else {\n        currentLcs[j] = previousLcs[j].length > currentLcs[j - 1].length ? previousLcs[j] : currentLcs[j - 1];\n      }\n    }\n  }\n  return big.length % 2 === 0 ? evenLcs[small.length] : oddLcs[small.length];\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm) time | O(nm) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lcs = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = [];\n    for (let j = 0; j < str1.length + 1; j++) {\n      const entry = new Array(4);\n      entry[1] = 0;\n      row.push(entry);\n    }\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = [str2[i - 1], lcs[i - 1][j - 1][1] + 1, i - 1, j - 1];\n      } else {\n        if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n          lcs[i][j] = [null, lcs[i - 1][j][1], i - 1, j];\n        } else {\n          lcs[i][j] = [null, lcs[i][j - 1][1], i, j - 1];\n        }\n      }\n    }\n  }\n  return buildSequence(lcs);\n}\n\nfunction buildSequence(lcs) {\n  const sequence = [];\n  let i = lcs.length - 1;\n  let j = lcs[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    let currentEntry = lcs[i][j];\n    if (currentEntry[0]) {\n      sequence.unshift(currentEntry[0]);\n    }\n    i = currentEntry[2];\n    j = currentEntry[3];\n  }\n  return sequence;\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm) time | O(nm) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lengths = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    lengths.push(new Array(str1.length + 1).fill(0));\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lengths[i][j] = lengths[i - 1][j - 1] + 1;\n      } else {\n        lengths[i][j] = Math.max(lengths[i - 1][j], lengths[i][j - 1]);\n      }\n    }\n  }\n  return buildSequence(lengths, str1);\n}\n\nfunction buildSequence(lengths, string) {\n  const sequence = [];\n  let i = lengths.length - 1;\n  let j = lengths[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    if (lengths[i][j] === lengths[i - 1][j]) {\n      i--;\n    } else if (lengths[i][j] === lengths[i][j - 1]) {\n      j--;\n    } else {\n      sequence.unshift(string[j - 1]);\n      i--;\n      j--;\n    }\n  }\n  return sequence;\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW')).to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW')).to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun longestCommonSubsequence(str1: String, str2: String): List<Char> {\n    // Write your code here.\n    return listOf()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nfun longestCommonSubsequence(str1: String, str2: String): List<Char> {\n    val lcs = List(str2.length + 1) { MutableList(str1.length + 1) { mutableListOf<Char>() } }\n    for (i in 1 until str2.length + 1) {\n        for (j in 1 until str1.length + 1) {\n            if (str2[i - 1] == str1[j - 1]) {\n                lcs[i][j] = lcs[i - 1][j - 1].toMutableList()\n                lcs[i][j].add(str2[i - 1])\n            } else {\n                if (lcs[i - 1][j].size > lcs[i][j - 1].size) {\n                    lcs[i][j] = lcs[i - 1][j]\n                } else {\n                    lcs[i][j] = lcs[i][j - 1]\n                }\n            }\n        }\n    }\n    return lcs[str2.length][str1.length]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nm*min(n, m)) time | O((min(n, m))^2) space\nfun longestCommonSubsequence(str1: String, str2: String): List<Char> {\n    val small = if (str1.length < str2.length) str1 else str2\n    val big = if (str1.length >= str2.length) str1 else str2\n\n    val evenLcs = MutableList(small.length + 1) { mutableListOf<Char>() }\n    val oddLcs = MutableList(small.length + 1) { mutableListOf<Char>() }\n\n    for (i in 1 until big.length + 1) {\n        val currentLcs = if (i % 2 == 1) oddLcs else evenLcs\n        val previousLcs = if (i % 2 == 0) oddLcs else evenLcs\n        for (j in 1 until small.length + 1) {\n            if (big[i - 1] == small[j - 1]) {\n                currentLcs[j] = previousLcs[j - 1].toMutableList()\n                currentLcs[j].add(big[i - 1])\n            } else {\n                if (previousLcs[j].size > currentLcs[j - 1].size) {\n                    currentLcs[j] = previousLcs[j]\n                } else {\n                    currentLcs[j] = currentLcs[j - 1]\n                }\n            }\n        }\n    }\n    return if (big.length % 2 == 0) evenLcs[small.length] else oddLcs[small.length]\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nm) time | O(nm) space\nfun longestCommonSubsequence(str1: String, str2: String): List<Char> {\n    val lcs = List(str2.length + 1) { MutableList(str1.length + 1) { mutableListOf(0, 0, 0, 0) } }\n\n    for (i in 1 until str2.length + 1) {\n        for (j in 1 until str1.length + 1) {\n            if (str2[i - 1] == str1[j - 1]) {\n                lcs[i][j] = mutableListOf(str2[i - 1].toInt(), lcs[i - 1][j - 1][1] + 1, i - 1, j - 1)\n            } else {\n                if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n                    lcs[i][j] = mutableListOf(-1, lcs[i - 1][j][1], i - 1, j)\n                } else {\n                    lcs[i][j] = mutableListOf(-1, lcs[i][j - 1][1], i, j - 1)\n                }\n            }\n        }\n    }\n    return buildSequence(lcs)\n}\n\nfun buildSequence(lcs: List<List<List<Int>>>): List<Char> {\n    val sequence = mutableListOf<Char>()\n    var i = lcs.size - 1\n    var j = lcs[0].size - 1\n    while (i != 0 && j != 0) {\n        val currentEntry = lcs[i][j]\n        if (currentEntry[0] != -1) {\n            sequence.add(0, currentEntry[0].toChar())\n        }\n        i = currentEntry[2]\n        j = currentEntry[3]\n    }\n    return sequence\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(nm) time | O(nm) space\nfun longestCommonSubsequence(str1: String, str2: String): List<Char> {\n    val lengths = List(str2.length + 1) { MutableList(str1.length + 1) { 0 } }\n\n    for (i in 1 until str2.length + 1) {\n        for (j in 1 until str1.length + 1) {\n            if (str2[i - 1] == str1[j - 1]) {\n                lengths[i][j] = lengths[i - 1][j - 1] + 1\n            } else {\n                lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1])\n            }\n        }\n    }\n    return buildSequence(lengths, str1)\n}\n\nfun buildSequence(lengths: List<MutableList<Int>>, str: String): List<Char> {\n    val sequence = mutableListOf<Char>()\n    var i = lengths.size - 1\n    var j = lengths[0].size - 1\n    while (i != 0 && j != 0) {\n        if (lengths[i][j] == lengths[i - 1][j]) {\n            i--\n        } else if (lengths[i][j] == lengths[i][j - 1]) {\n            j--\n        } else {\n            sequence.add(0, str[j - 1])\n            i--\n            j--\n        }\n    }\n    return sequence\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestCommonSubsequence\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = listOf('X', 'Y', 'Z', 'W')\n        val output = longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\")\n        assert(output == expected)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.longestCommonSubsequence\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val expected = listOf('X', 'Y', 'Z', 'W')\n        val output = longestCommonSubsequence(\"ZXVVYZW\", \"XKYKZPW\")\n        assert(output == expected)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def longestCommonSubsequence(str1, str2):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nm*min(n, m)) time | O(nm*min(n, m)) space\ndef longestCommonSubsequence(str1, str2):\n    lcs = [[[] for x in range(len(str1) + 1)] for y in range(len(str2) + 1)]\n    for i in range(1, len(str2) + 1):\n        for j in range(1, len(str1) + 1):\n            if str2[i - 1] == str1[j - 1]:\n                lcs[i][j] = lcs[i - 1][j - 1] + [str2[i - 1]]\n            else:\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1], key=len)\n    return lcs[-1][-1]\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nm*min(n, m)) time | O((min(n, m))^2) space\ndef longestCommonSubsequence(str1, str2):\n    small = str1 if len(str1) < len(str2) else str2\n    big = str1 if len(str1) >= len(str2) else str2\n    evenLcs = [[] for x in range(len(small) + 1)]\n    oddLcs = [[] for x in range(len(small) + 1)]\n    for i in range(1, len(big) + 1):\n        if i % 2 == 1:\n            currentLcs = oddLcs\n            previousLcs = evenLcs\n        else:\n            currentLcs = evenLcs\n            previousLcs = oddLcs\n        for j in range(1, len(small) + 1):\n            if big[i - 1] == small[j - 1]:\n                currentLcs[j] = previousLcs[j - 1] + [big[i - 1]]\n            else:\n                currentLcs[j] = max(previousLcs[j], currentLcs[j - 1], key=len)\n    return evenLcs[-1] if len(big) % 2 == 0 else oddLcs[-1]\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nm) time | O(nm) space\ndef longestCommonSubsequence(str1, str2):\n    lcs = [[[None, 0, None, None] for x in range(len(str1) + 1)] for y in range(len(str2) + 1)]\n    for i in range(1, len(str2) + 1):\n        for j in range(1, len(str1) + 1):\n            if str2[i - 1] == str1[j - 1]:\n                lcs[i][j] = [str2[i - 1], lcs[i - 1][j - 1][1] + 1, i - 1, j - 1]\n            else:\n                if lcs[i - 1][j][1] > lcs[i][j - 1][1]:\n                    lcs[i][j] = [None, lcs[i - 1][j][1], i - 1, j]\n                else:\n                    lcs[i][j] = [None, lcs[i][j - 1][1], i, j - 1]\n    return buildSequence(lcs)\n\n\ndef buildSequence(lcs):\n    sequence = []\n    i = len(lcs) - 1\n    j = len(lcs[0]) - 1\n    while i != 0 and j != 0:\n        currentEntry = lcs[i][j]\n        if currentEntry[0] is not None:\n            sequence.append(currentEntry[0])\n        i = currentEntry[2]\n        j = currentEntry[3]\n    return list(reversed(sequence))\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nm) time | O(nm) space\ndef longestCommonSubsequence(str1, str2):\n    lengths = [[0 for x in range(len(str1) + 1)] for y in range(len(str2) + 1)]\n    for i in range(1, len(str2) + 1):\n        for j in range(1, len(str1) + 1):\n            if str2[i - 1] == str1[j - 1]:\n                lengths[i][j] = lengths[i - 1][j - 1] + 1\n            else:\n                lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1])\n    return buildSequence(lengths, str1)\n\n\ndef buildSequence(lengths, string):\n    sequence = []\n    i = len(lengths) - 1\n    j = len(lengths[0]) - 1\n    while i != 0 and j != 0:\n        if lengths[i][j] == lengths[i - 1][j]:\n            i -= 1\n        elif lengths[i][j] == lengths[i][j - 1]:\n            j -= 1\n        else:\n            sequence.append(string[j - 1])\n            i -= 1\n            j -= 1\n    return list(reversed(sequence))\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        output = program.longestCommonSubsequence("ZXVVYZW", "XKYKZPW")\n        self.assertEqual(output, ["X", "Y", "Z", "W"])\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        output = program.longestCommonSubsequence("ZXVVYZW", "XKYKZPW")\n        self.assertEqual(output, ["X", "Y", "Z", "W"])\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            'class Program\n  def longestCommonSubsequence(str1, str2)\n    # Write your code here.\n    return ""\n  end\nend\n',
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestCommonSubsequence(str1, str2)\n    # Write your code here.\n    return ""\n  end\nend\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestCommonSubsequence(str1, str2)\n    # Write your code here.\n    return ""\n  end\nend\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestCommonSubsequence(str1, str2)\n    # Write your code here.\n    return ""\n  end\nend\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestCommonSubsequence(str1, str2)\n    # Write your code here.\n    return ""\n  end\nend\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestCommonSubsequence\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestCommonSubsequence\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func longestCommonSubsequence(firstString: String, secondString: String) -> [String] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nm * min(n, m)) time | O(nm * min(n, m)) space\n  func longestCommonSubsequence(firstString: String, secondString: String) -> [String] {\n    var lcs = [[[String]]]()\n\n    for _ in 0 ..< firstString.count + 1 {\n      let row = Array(repeating: [String](), count: secondString.count + 1)\n      lcs.append(row)\n    }\n\n    for i in stride(from: 1, to: firstString.count + 1, by: 1) {\n      for j in stride(from: 1, to: secondString.count + 1, by: 1) {\n        let firstIndex = firstString.index(firstString.startIndex, offsetBy: i - 1)\n        let secondIndex = secondString.index(secondString.startIndex, offsetBy: j - 1)\n\n        if firstString[firstIndex] == secondString[secondIndex] {\n          var diagonal = lcs[i - 1][j - 1]\n          let char = String(firstString[firstIndex])\n          diagonal.append(char)\n\n          lcs[i][j] = diagonal\n        } else {\n          let left = lcs[i][j - 1]\n          let top = lcs[i - 1][j]\n\n          lcs[i][j] = left.count > top.count ? left : top\n        }\n      }\n    }\n\n    return lcs[firstString.count][secondString.count]\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nm * min(n, m)) time | O(min(n, m)^2) space\n  func longestCommonSubsequence(firstString: String, secondString: String) -> [String] {\n    let smallestString = firstString.count < secondString.count ? firstString : secondString\n    let biggestString = firstString.count >= secondString.count ? firstString : secondString\n\n    var evenLCS = Array(repeating: [String](), count: smallestString.count + 1)\n    var oddLCS = Array(repeating: [String](), count: smallestString.count + 1)\n\n    for i in stride(from: 1, to: biggestString.count + 1, by: 1) {\n      if i % 2 == 0 {\n        secondSolutionHelper(i, biggestString, smallestString, currentLCS: &evenLCS, previousLCS: &oddLCS)\n      } else {\n        secondSolutionHelper(i, biggestString, smallestString, currentLCS: &oddLCS, previousLCS: &evenLCS)\n      }\n    }\n\n    return biggestString.count % 2 == 0 ? evenLCS[smallestString.count] : oddLCS[smallestString.count]\n  }\n\n  func secondSolutionHelper(_ i: Int, _ biggestString: String, _ smallestString: String, currentLCS: inout [[String]], previousLCS: inout [[String]]) {\n    for j in stride(from: 1, to: smallestString.count + 1, by: 1) {\n      let firstIndex = biggestString.index(biggestString.startIndex, offsetBy: i - 1)\n      let secondIndex = smallestString.index(smallestString.startIndex, offsetBy: j - 1)\n\n      if biggestString[firstIndex] == smallestString[secondIndex] {\n        var diagonal = previousLCS[j - 1]\n        let char = String(smallestString[secondIndex])\n        diagonal.append(char)\n\n        currentLCS[j] = diagonal\n      } else {\n        let top = previousLCS[j]\n        let left = currentLCS[j - 1]\n\n        if top.count > left.count {\n          currentLCS[j] = top\n        } else {\n          currentLCS[j] = left\n        }\n      }\n    }\n  }\n}\n",
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nm) time | O(nm) space\n  func longestCommonSubsequence(firstString: String, secondString: String) -> [String] {\n    var lcs = [[(String, Int, Int, Int)]]()\n\n    for _ in stride(from: 0, to: firstString.count + 1, by: 1) {\n      var row = [(String, Int, Int, Int)]()\n\n      for _ in stride(from: 0, to: secondString.count + 1, by: 1) {\n        let tuple = ("", 0, 0, 0)\n        row.append(tuple)\n      }\n\n      lcs.append(row)\n    }\n\n    for i in stride(from: 1, to: firstString.count + 1, by: 1) {\n      for j in stride(from: 1, to: secondString.count + 1, by: 1) {\n        let firstIndex = firstString.index(firstString.startIndex, offsetBy: i - 1)\n        let secondIndex = secondString.index(secondString.startIndex, offsetBy: j - 1)\n\n        if firstString[firstIndex] == secondString[secondIndex] {\n          let char = String(firstString[firstIndex])\n          lcs[i][j] = (char, lcs[i - 1][j - 1].1 + 1, i - 1, j - 1)\n        } else {\n          if lcs[i - 1][j].1 > lcs[i][j - 1].1 {\n            lcs[i][j] = ("", lcs[i - 1][j].1, i - 1, j)\n          } else {\n            lcs[i][j] = ("", lcs[i][j - 1].1, i, j - 1)\n          }\n        }\n      }\n    }\n\n    return buildSequence(lcs: lcs)\n  }\n\n  func buildSequence(lcs: [[(String, Int, Int, Int)]]) -> [String] {\n    var sequence = [String]()\n\n    var i = lcs.count - 1\n    var j = lcs[0].count - 1\n\n    while i != 0, j != 0 {\n      let currentEntry = lcs[i][j]\n\n      if currentEntry.0 != "" {\n        sequence.insert(currentEntry.0, at: 0)\n      }\n\n      i = currentEntry.2\n      j = currentEntry.3\n    }\n\n    return sequence\n  }\n}\n',
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nm) time | O(nm) space\n  func longestCommonSubsequence(firstString: String, secondString: String) -> [String] {\n    var lengths = [[Int]]()\n\n    for _ in stride(from: 0, to: firstString.count + 1, by: 1) {\n      let row = Array(repeating: 0, count: secondString.count + 1)\n      lengths.append(row)\n    }\n\n    for i in stride(from: 1, to: firstString.count + 1, by: 1) {\n      for j in stride(from: 1, to: secondString.count + 1, by: 1) {\n        let firstIndex = firstString.index(firstString.startIndex, offsetBy: i - 1)\n        let secondIndex = secondString.index(secondString.startIndex, offsetBy: j - 1)\n\n        if firstString[firstIndex] == secondString[secondIndex] {\n          lengths[i][j] = lengths[i - 1][j - 1] + 1\n        } else {\n          lengths[i][j] = max(lengths[i - 1][j], lengths[i][j - 1])\n        }\n      }\n    }\n\n    return buildSequence(lengths: lengths, string: secondString)\n  }\n\n  // Build lcs from lengths array and initial string\n  func buildSequence(lengths: [[Int]], string: String) -> [String] {\n    var sequence = [String]()\n\n    var i = lengths.count - 1\n    var j = lengths[0].count - 1\n\n    while i != 0, j != 0 {\n      if lengths[i][j] == lengths[i - 1][j] {\n        i -= 1\n      } else if lengths[i][j] == lengths[i][j - 1] {\n        j -= 1\n      } else {\n        let index = string.index(string.startIndex, offsetBy: j - 1)\n        let char = String(string[index])\n\n        sequence.insert(char, at: 0)\n        i -= 1\n        j -= 1\n      }\n    }\n\n    return sequence\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let output = program.longestCommonSubsequence(firstString: "ZXVVYZW", secondString: "XKYKZPW")\n      try assertEqual(["X", "Y", "Z", "W"], output)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let output = program.longestCommonSubsequence(firstString: "ZXVVYZW", secondString: "XKYKZPW")\n      try assertEqual(["X", "Y", "Z", "W"], output)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function longestCommonSubsequence(str1: string, str2: string) {\n  // Write your code here.\n  return [''];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nexport function longestCommonSubsequence(str1: string, str2: string) {\n  const lcs: string[][][] = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = new Array(str1.length + 1).fill([]);\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = lcs[i - 1][j - 1].concat(str2[i - 1]);\n      } else {\n        lcs[i][j] = lcs[i - 1][j].length > lcs[i][j - 1].length ? lcs[i - 1][j] : lcs[i][j - 1];\n      }\n    }\n  }\n  return lcs[str2.length][str1.length];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm*min(n, m)) time | O((min(n, m))^2) space\nexport function longestCommonSubsequence(str1: string, str2: string) {\n  const small = str1.length < str2.length ? str1 : str2;\n  const big = str1.length >= str2.length ? str1 : str2;\n  const evenLcs: string[][] = new Array(small.length + 1).fill([]);\n  const oddLcs: string[][] = new Array(small.length + 1).fill([]);\n  for (let i = 1; i < big.length + 1; i++) {\n    let currentLcs, previousLcs;\n    if (i % 2 === 1) {\n      currentLcs = oddLcs;\n      previousLcs = evenLcs;\n    } else {\n      currentLcs = evenLcs;\n      previousLcs = oddLcs;\n    }\n    for (let j = 1; j < small.length + 1; j++) {\n      if (big[i - 1] === small[j - 1]) {\n        currentLcs[j] = previousLcs[j - 1].concat(big[i - 1]);\n      } else {\n        currentLcs[j] = previousLcs[j].length > currentLcs[j - 1].length ? previousLcs[j] : currentLcs[j - 1];\n      }\n    }\n  }\n  return big.length % 2 === 0 ? evenLcs[small.length] : oddLcs[small.length];\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm) time | O(nm) space\nexport function longestCommonSubsequence(str1: string, str2: string) {\n  const lcs: any[][][] = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = [];\n    for (let j = 0; j < str1.length + 1; j++) {\n      const entry = new Array(4);\n      entry[1] = 0;\n      row.push(entry);\n    }\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = [str2[i - 1], lcs[i - 1][j - 1][1] + 1, i - 1, j - 1];\n      } else {\n        if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n          lcs[i][j] = [null, lcs[i - 1][j][1], i - 1, j];\n        } else {\n          lcs[i][j] = [null, lcs[i][j - 1][1], i, j - 1];\n        }\n      }\n    }\n  }\n  return buildSequence(lcs);\n}\n\nfunction buildSequence(lcs: any[][][]) {\n  const sequence: string[] = [];\n  let i = lcs.length - 1;\n  let j = lcs[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    let currentEntry = lcs[i][j];\n    if (currentEntry[0]) {\n      sequence.unshift(currentEntry[0]);\n    }\n    i = currentEntry[2];\n    j = currentEntry[3];\n  }\n  return sequence;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nm) time | O(nm) space\nexport function longestCommonSubsequence(str1: string, str2: string) {\n  const lengths: number[][] = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    lengths.push(new Array(str1.length + 1).fill(0));\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lengths[i][j] = lengths[i - 1][j - 1] + 1;\n      } else {\n        lengths[i][j] = Math.max(lengths[i - 1][j], lengths[i][j - 1]);\n      }\n    }\n  }\n  return buildSequence(lengths, str1);\n}\n\nfunction buildSequence(lengths: number[][], string: string) {\n  const sequence: string[] = [];\n  let i = lengths.length - 1;\n  let j = lengths[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    if (lengths[i][j] === lengths[i - 1][j]) {\n      i--;\n    } else if (lengths[i][j] === lengths[i][j - 1]) {\n      j--;\n    } else {\n      sequence.unshift(string[j - 1]);\n      i--;\n      j--;\n    }\n  }\n  return sequence;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW')).to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW')).to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "str1",
          example: "ZXVVYZW",
          schema: {
            type: "string",
          },
        },
        {
          name: "str2",
          example: "XKYKZPW",
          schema: {
            type: "string",
          },
        },
      ],
      tests: [
        {
          str1: "ZXVVYZW",
          str2: "XKYKZPW",
        },
        {
          str1: "",
          str2: "",
        },
        {
          str1: "",
          str2: "ABCDEFG",
        },
        {
          str1: "ABCDEFG",
          str2: "",
        },
        {
          str1: "ABCDEFG",
          str2: "ABCDEFG",
        },
        {
          str1: "ABCDEFG",
          str2: "APPLES",
        },
        {
          str1: "clement",
          str2: "antoine",
        },
        {
          str1: "8111111111111111142",
          str2: "222222222822222222222222222222433333333332",
        },
        {
          str1: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          str2: "CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAG",
        },
        {
          str1: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          str2: "CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAGTUV",
        },
      ],
      jsonTests: [
        {
          str1: "ZXVVYZW",
          str2: "XKYKZPW",
        },
        {
          str1: "",
          str2: "",
        },
        {
          str1: "",
          str2: "ABCDEFG",
        },
        {
          str1: "ABCDEFG",
          str2: "",
        },
        {
          str1: "ABCDEFG",
          str2: "ABCDEFG",
        },
        {
          str1: "ABCDEFG",
          str2: "APPLES",
        },
        {
          str1: "clement",
          str2: "antoine",
        },
        {
          str1: "8111111111111111142",
          str2: "222222222822222222222222222222433333333332",
        },
        {
          str1: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          str2: "CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAG",
        },
        {
          str1: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
          str2: "CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAGTUV",
        },
      ],
      changelog: [],
      id: 30,
    },
    {
      uid: "apartment-hunting",
      testStrategy: "JSON",
      name: "Apartment Hunting",
      version: 0,
      releaseDate: "2019-09-01T00:00:00Z",
      category: "Arrays",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 6876,
        failureCount: 2984,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "354828587",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1568,
      },
      prompt:
        '<div class="html">\n<p>\n  You\'re looking to move into a new apartment on specific street, and you\'re\n  given a list of contiguous blocks on that street where each block contains an\n  apartment that you could move into.\n</p>\n<p>\n  You also have a list of requirements: a list of buildings that are important\n  to you. For instance, you might value having a school and a gym near your\n  apartment. The list of blocks that you have contains information at every\n  block about all of the buildings that are present and absent at the block in\n  question. For instance, for every block, you might know whether a school, a\n  pool, an office, and a gym are present.\n</p>\n<p>\n  In order to optimize your life, you want to pick an apartment block such that\n  you minimize the farthest distance you\'d have to walk from your apartment to\n  reach any of your required buildings.\n</p>\n<p>\n  Write a function that takes in a list of contiguous blocks on a specific\n  street and a list of your required buildings and that returns the location\n  (the index) of the block that\'s most optimal for you.\n</p>\n<p>\n  If there are multiple most optimal blocks, your function can return the index\n  of any one of them.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">blocks</span> = [\n  {\n    "gym": false,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": true,\n    "school": false,\n    "store": false,\n  },\n  {\n    "gym": true,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": false,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": false,\n    "school": true,\n    "store": true,\n  },\n]\n<span class="CodeEditor-promptParameter">reqs</span> = ["gym", "school", "store"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// at index 3, the farthest you\'d have to walk to reach a gym, a school, or a store is 1 block; at any other index, you\'d have to walk farther</span>\n</pre>\n</div>',
      hints: [
        '<p>\nFor every block, you want to go through every requirement, and for every requirement, you want to find the closest other block with that requirement (or rather, the smallest distance to another block with that requirement). Once you\'ve done that for every requirement and for every block, you want to pick, for every block, the distance of the farthest requirement. You can do this with three nested "for" loops.\n</p>\n',
        '\n<p>\nIs there a way to optimize on the solution mentioned in Hint #1 (that uses three nested "for" loops) by precomputing the smallest distances of every requirement from every block?\n</p>\n',
        "\n<p>\nFor every requirement, you should be able to precompute its smallest distances from every block by doing two simple passes though the array of blocks: one pass from left to right and one pass from right to left. Once you have these precomputed values, you can iterate through all of the blocks and pick the biggest of all the precomputed distances at that block.\n</p>",
      ],
      spaceTime:
        "O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint apartmentHunting(vector<unordered_map<string, bool>> blocks,\n                     vector<string> reqs) {\n  // Write your code here;\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\n#include <climits>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint getIdxAtMinValue(vector<int> array);\nint distanceBetween(int a, int b);\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the\n// number of requirements\nint apartmentHunting(vector<unordered_map<string, bool>> blocks,\n                     vector<string> reqs) {\n  vector<int> maxDistancesAtBlocks(blocks.size(), INT_MIN);\n  for (int i = 0; i < blocks.size(); i++) {\n    for (string req : reqs) {\n      int closestReqDistance = INT_MAX;\n      for (int j = 0; j < blocks.size(); j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] =\n          max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nint getIdxAtMinValue(vector<int> array) {\n  int idxAtMinValue = 0;\n  int minValue = INT_MAX;\n  for (int i = 0; i < array.size(); i++) {\n    int currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nint distanceBetween(int a, int b) { return abs(a - b); }\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n\n#include <vector>\n#include <unordered_map>\n#include <climits>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nvector<int> getMinDistances(vector<unordered_map<string, bool>> blocks,\n                            string req);\nvector<int> getMaxDistancesAtBlocks(vector<unordered_map<string, bool>> blocks,\n                                    vector<vector<int>> minDistancesFromBlocks);\nint getIdxAtMinValue(vector<int> array);\nint distanceBetween(int a, int b);\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the\n// number of requirements\nint apartmentHunting(vector<unordered_map<string, bool>> blocks,\n                     vector<string> reqs) {\n  vector<vector<int>> minDistancesFromBlocks;\n  for (string req : reqs) {\n    minDistancesFromBlocks.push_back(getMinDistances(blocks, req));\n  }\n  vector<int> maxDistancesAtBlocks =\n      getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nvector<int> getMinDistances(vector<unordered_map<string, bool>> blocks,\n                            string req) {\n  vector<int> minDistances(blocks.size());\n  int closestReqIdx = INT_MAX;\n  for (int i = 0; i < blocks.size(); i++) {\n    if (blocks[i][req])\n      closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (int i = blocks.size() - 1; i >= 0; i--) {\n    if (blocks[i][req])\n      closestReqIdx = i;\n    minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nvector<int>\ngetMaxDistancesAtBlocks(vector<unordered_map<string, bool>> blocks,\n                        vector<vector<int>> minDistancesFromBlocks) {\n  vector<int> maxDistancesAtBlocks(blocks.size());\n  for (int i = 0; i < blocks.size(); i++) {\n    vector<int> minDistancesAtBlock;\n    for (vector<int> distances : minDistancesFromBlocks) {\n      minDistancesAtBlock.push_back(distances[i]);\n    }\n    maxDistancesAtBlocks[i] =\n        *max_element(minDistancesAtBlock.begin(), minDistancesAtBlock.end());\n  }\n  return maxDistancesAtBlocks;\n}\n\nint getIdxAtMinValue(vector<int> array) {\n  int idxAtMinValue = 0;\n  int minValue = INT_MAX;\n  for (int i = 0; i < array.size(); i++) {\n    int currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nint distanceBetween(int a, int b) { return abs(a - b); }\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <algorithm>\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest("Test Case 1", []() {\n      vector<unordered_map<string, bool>> blocks(5);\n\n      blocks[0].insert({"gym", false});\n      blocks[0].insert({"school", true});\n      blocks[0].insert({"store", false});\n\n      blocks[1].insert({"gym", true});\n      blocks[1].insert({"school", false});\n      blocks[1].insert({"store", false});\n\n      blocks[2].insert({"gym", true});\n      blocks[2].insert({"school", true});\n      blocks[2].insert({"store", false});\n\n      blocks[3].insert({"gym", false});\n      blocks[3].insert({"school", true});\n      blocks[3].insert({"store", false});\n\n      blocks[4].insert({"gym", false});\n      blocks[4].insert({"school", true});\n      blocks[4].insert({"store", true});\n\n      vector<string> reqs = {"gym", "school", "store"};\n      assert(apartmentHunting(blocks, reqs) == 3);\n    });\n  }\n};\n',
          unitTests:
            '#include <algorithm>\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest("Test Case 1", []() {\n      vector<unordered_map<string, bool>> blocks(5);\n\n      blocks[0].insert({"gym", false});\n      blocks[0].insert({"school", true});\n      blocks[0].insert({"store", false});\n\n      blocks[1].insert({"gym", true});\n      blocks[1].insert({"school", false});\n      blocks[1].insert({"store", false});\n\n      blocks[2].insert({"gym", true});\n      blocks[2].insert({"school", true});\n      blocks[2].insert({"store", false});\n\n      blocks[3].insert({"gym", false});\n      blocks[3].insert({"school", true});\n      blocks[3].insert({"store", false});\n\n      blocks[4].insert({"gym", false});\n      blocks[4].insert({"school", true});\n      blocks[4].insert({"store", true});\n\n      vector<string> reqs = {"gym", "school", "store"};\n      assert(apartmentHunting(blocks, reqs) == 3);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic static int ApartmentHunting(List<Dictionary<string, bool> > blocks, string[] reqs) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\n\tpublic static int ApartmentHunting(List<Dictionary<string, bool> > blocks, string[] reqs) {\n\t\tint[] maxDistancesAtBlocks = new int[blocks.Count];\n\t\tArray.Fill(maxDistancesAtBlocks, Int32.MinValue);\n\n\t\tfor (int i = 0; i < blocks.Count; i++) {\n\t\t\tforeach (string req in reqs) {\n\t\t\t\tint closestReqDistance = Int32.MaxValue;\n\t\t\t\tfor (int j = 0; j < blocks.Count; j++) {\n\t\t\t\t\tif (blocks[j][req]) {\n\t\t\t\t\t\tclosestReqDistance = Math.Min(closestReqDistance, distanceBetween(\n\t\t\t\t\t\t\t    i,\n\t\t\t\t\t\t\t    j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxDistancesAtBlocks[i] = Math.Max(maxDistancesAtBlocks[i],\n\t\t\t\t    closestReqDistance);\n\t\t\t}\n\t\t}\n\t\treturn getIdxAtMinValue(maxDistancesAtBlocks);\n\t}\n\n\tpublic static int getIdxAtMinValue(int[] array) {\n\t\tint idxAtMinValue = 0;\n\t\tint minValue = Int32.MaxValue;\n\t\tfor (int i = 0; i < array.Length; i++) {\n\t\t\tint currentValue = array[i];\n\t\t\tif (currentValue < minValue) {\n\t\t\t\tminValue = currentValue;\n\t\t\t\tidxAtMinValue = i;\n\t\t\t}\n\t\t}\n\t\treturn idxAtMinValue;\n\t}\n\n\tpublic static int distanceBetween(int a, int b) {\n\t\treturn Math.Abs(a - b);\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\n\npublic class Program {\n\t// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\n\tpublic static int ApartmentHunting(List<Dictionary<string, bool> > blocks, string[] reqs) {\n\t\tint[][] minDistancesFromBlocks = new int[reqs.Length][];\n\t\tfor (int i = 0; i < reqs.Length; i++) {\n\t\t\tminDistancesFromBlocks[i] = getMinDistances(blocks, reqs[i]);\n\t\t}\n\t\tint[] maxDistancesAtBlocks =\n\t\t  getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n\t\treturn getIdxAtMinValue(maxDistancesAtBlocks);\n\t}\n\n\tpublic static int[] getMinDistances(List<Dictionary<string, bool> > blocks, string req) {\n\t\tint[] minDistances = new int[blocks.Count];\n\t\tint closestReqIdx = Int32.MaxValue;\n\t\tfor (int i = 0; i < blocks.Count; i++) {\n\t\t\tif (blocks[i][req]) closestReqIdx = i;\n\t\t\tminDistances[i] = distanceBetween(i, closestReqIdx);\n\t\t}\n\t\tfor (int i = blocks.Count - 1; i >= 0; i--) {\n\t\t\tif (blocks[i][req]) closestReqIdx = i;\n\t\t\tminDistances[i] = Math.Min(minDistances[i], distanceBetween(i,\n\t\t\t    closestReqIdx));\n\t\t}\n\t\treturn minDistances;\n\t}\n\n\tpublic static int[] getMaxDistancesAtBlocks(List<Dictionary<string, bool> > blocks,\n\t  int[][] minDistancesFromBlocks) {\n\t\tint[] maxDistancesAtBlocks = new int[blocks.Count];\n\t\tfor (int i = 0; i < blocks.Count; i++) {\n\t\t\tint[] minDistancesAtBlock = new int[minDistancesFromBlocks.Length];\n\t\t\tfor (int j = 0; j < minDistancesFromBlocks.Length; j++) {\n\t\t\t\tminDistancesAtBlock[j] = minDistancesFromBlocks[j][i];\n\t\t\t}\n\t\t\tmaxDistancesAtBlocks[i] = arrayMax(minDistancesAtBlock);\n\t\t}\n\t\treturn maxDistancesAtBlocks;\n\t}\n\n\tpublic static int getIdxAtMinValue(int[] array) {\n\t\tint idxAtMinValue = 0;\n\t\tint minValue = Int32.MaxValue;\n\t\tfor (int i = 0; i < array.Length; i++) {\n\t\t\tint currentValue = array[i];\n\t\t\tif (currentValue < minValue) {\n\t\t\t\tminValue = currentValue;\n\t\t\t\tidxAtMinValue = i;\n\t\t\t}\n\t\t}\n\t\treturn idxAtMinValue;\n\t}\n\n\tpublic static int distanceBetween(int a, int b) {\n\t\treturn Math.Abs(a - b);\n\t}\n\n\tpublic static int arrayMax(int[] array) {\n\t\tint max = array[0];\n\t\tforeach (int a in array) {\n\t\t\tif (a > max) {\n\t\t\t\tmax = a;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<Dictionary<string, bool> > blocks = new List<Dictionary<string, bool> >();\n\n\t\tblocks.Insert(0, new Dictionary<string, bool>());\n\t\tblocks[0]["gym"] = false;\n\t\tblocks[0]["school"] = true;\n\t\tblocks[0]["store"] = false;\n\n\t\tblocks.Insert(1, new Dictionary<string, bool>());\n\t\tblocks[1]["gym"] = true;\n\t\tblocks[1]["school"] = false;\n\t\tblocks[1]["store"] = false;\n\n\t\tblocks.Insert(2, new Dictionary<string, bool>());\n\t\tblocks[2]["gym"] = true;\n\t\tblocks[2]["school"] = true;\n\t\tblocks[2]["store"] = false;\n\n\t\tblocks.Insert(3, new Dictionary<string, bool>());\n\t\tblocks[3]["gym"] = false;\n\t\tblocks[3]["school"] = true;\n\t\tblocks[3]["store"] = false;\n\n\t\tblocks.Insert(4, new Dictionary<string, bool>());\n\t\tblocks[4]["gym"] = false;\n\t\tblocks[4]["school"] = true;\n\t\tblocks[4]["store"] = true;\n\n\t\tstring[] reqs = new string[] {"gym", "school", "store"};\n\t\tUtils.AssertTrue(Program.ApartmentHunting(blocks, reqs) == 3);\n\t}\n}\n',
          unitTests:
            'using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<Dictionary<string, bool> > blocks = new List<Dictionary<string, bool> >();\n\n\t\tblocks.Insert(0, new Dictionary<string, bool>());\n\t\tblocks[0]["gym"] = false;\n\t\tblocks[0]["school"] = true;\n\t\tblocks[0]["store"] = false;\n\n\t\tblocks.Insert(1, new Dictionary<string, bool>());\n\t\tblocks[1]["gym"] = true;\n\t\tblocks[1]["school"] = false;\n\t\tblocks[1]["store"] = false;\n\n\t\tblocks.Insert(2, new Dictionary<string, bool>());\n\t\tblocks[2]["gym"] = true;\n\t\tblocks[2]["school"] = true;\n\t\tblocks[2]["store"] = false;\n\n\t\tblocks.Insert(3, new Dictionary<string, bool>());\n\t\tblocks[3]["gym"] = false;\n\t\tblocks[3]["school"] = true;\n\t\tblocks[3]["store"] = false;\n\n\t\tblocks.Insert(4, new Dictionary<string, bool>());\n\t\tblocks[4]["gym"] = false;\n\t\tblocks[4]["school"] = true;\n\t\tblocks[4]["store"] = true;\n\n\t\tstring[] reqs = new string[] {"gym", "school", "store"};\n\t\tUtils.AssertTrue(Program.ApartmentHunting(blocks, reqs) == 3);\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\ntype Block map[string]bool\n\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport "math"\n\ntype Block map[string]bool\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks\n// and r is the number of requirements.\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\tmaxDistancesAtBlocks := make([]int, len(blocks))\n\tfor i := range blocks {\n\t\tmaxDistancesAtBlocks[i] = -1\n\t\tfor _, req := range reqs {\n\t\t\tclosestReqDistance := math.MaxInt32\n\t\t\tfor j := range blocks {\n\t\t\t\tif blocks[j][req] {\n\t\t\t\t\tclosestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n\t\t}\n\t}\n\n\tvar optimalBlockIdx int\n\tsmallestMaxDistance := math.MaxInt32\n\tfor i, currentDistance := range maxDistancesAtBlocks {\n\t\tif currentDistance < smallestMaxDistance {\n\t\t\tsmallestMaxDistance = currentDistance\n\t\t\toptimalBlockIdx = i\n\t\t}\n\t}\n\treturn optimalBlockIdx\n}\n\nfunc distanceBetween(a, b int) int {\n\tif a > b {\n\t\treturn a - b\n\t}\n\treturn b - a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport "math"\n\ntype Block map[string]bool\n\n// O(br) time | O(br) space - where b is the number of blocks\n// and r is the number of requirements.\nfunc ApartmentHunting(blocks []Block, reqs []string) int {\n\tminDistancesFromBlocks := [][]int{}\n\tfor _, req := range reqs {\n\t\tminDistancesFromBlocks = append(minDistancesFromBlocks,\n\t\t\tgetMinDistances(blocks, req))\n\t}\n\tmaxDistancesAtBlocks := getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n\n\tvar optimalBlockIdx int\n\tsmallestMaxDistance := math.MaxInt32\n\tfor i, currentDistance := range maxDistancesAtBlocks {\n\t\tif currentDistance < smallestMaxDistance {\n\t\t\tsmallestMaxDistance = currentDistance\n\t\t\toptimalBlockIdx = i\n\t\t}\n\t}\n\treturn optimalBlockIdx\n}\n\nfunc getMinDistances(blocks []Block, req string) []int {\n\tminDistances := make([]int, len(blocks))\n\tclosestReq := math.MaxInt32\n\tfor i := range blocks {\n\t\tif val, found := blocks[i][req]; found && val {\n\t\t\tclosestReq = i\n\t\t}\n\t\tminDistances[i] = distanceBetween(i, closestReq)\n\t}\n\n\tfor i := len(blocks) - 1; i >= 0; i-- {\n\t\tif val, found := blocks[i][req]; found && val {\n\t\t\tclosestReq = i\n\t\t}\n\t\tminDistances[i] = min(minDistances[i], distanceBetween(i, closestReq))\n\t}\n\treturn minDistances\n}\n\nfunc getMaxDistancesAtBlocks(blocks []Block, minDistancesFromBlocks [][]int) []int {\n\tmaxDistancesAtBlocks := make([]int, len(blocks))\n\tfor i := range blocks {\n\t\tminDistancesAtBlock := []int{}\n\t\tfor _, distances := range minDistancesFromBlocks {\n\t\t\tminDistancesAtBlock = append(minDistancesAtBlock, distances[i])\n\t\t}\n\t\tmaxDistancesAtBlocks[i] = max(minDistancesAtBlock)\n\t}\n\treturn maxDistancesAtBlocks\n}\n\nfunc distanceBetween(a, b int) int {\n\tif a > b {\n\t\treturn a - b\n\t}\n\treturn b - a\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(array []int) int {\n\tif len(array) == 0 {\n\t\treturn 0\n\t}\n\n\tmax := array[0]\n\tfor i := 1; i < len(array); i++ {\n\t\tif array[i] > max {\n\t\t\tmax = array[i]\n\t\t}\n\t}\n\treturn max\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tblocks := []Block{\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    true,\n\t\t\t"school": false,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    true,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  true,\n\t\t},\n\t}\n\treqs := []string{"gym", "school", "store"}\n\toutput := ApartmentHunting(blocks, reqs)\n\trequire.Equal(t, output, 3)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tblocks := []Block{\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    true,\n\t\t\t"school": false,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    true,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  false,\n\t\t},\n\t\t{\n\t\t\t"gym":    false,\n\t\t\t"school": true,\n\t\t\t"store":  true,\n\t\t},\n\t}\n\treqs := []string{"gym", "school", "store"}\n\toutput := ApartmentHunting(blocks, reqs)\n\trequire.Equal(t, output, 3)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int apartmentHunting(List<Map<String, Boolean>> blocks, String[] reqs) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of\n  // requirements\n  public static int apartmentHunting(List<Map<String, Boolean>> blocks, String[] reqs) {\n    int[] maxDistancesAtBlocks = new int[blocks.size()];\n    Arrays.fill(maxDistancesAtBlocks, Integer.MIN_VALUE);\n\n    for (int i = 0; i < blocks.size(); i++) {\n      for (String req : reqs) {\n        int closestReqDistance = Integer.MAX_VALUE;\n        for (int j = 0; j < blocks.size(); j++) {\n          if (blocks.get(j).get(req)) {\n            closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n          }\n        }\n        maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n      }\n    }\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Integer.MAX_VALUE;\n    for (int i = 0; i < array.length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.abs(a - b);\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(br) time | O(br) space - where b is the number of blocks and r is the number of\n  // requirements\n  public static int apartmentHunting(List<Map<String, Boolean>> blocks, String[] reqs) {\n    int[][] minDistancesFromBlocks = new int[reqs.length][];\n    for (int i = 0; i < reqs.length; i++) {\n      minDistancesFromBlocks[i] = getMinDistances(blocks, reqs[i]);\n    }\n    int[] maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n    return getIdxAtMinValue(maxDistancesAtBlocks);\n  }\n\n  public static int[] getMinDistances(List<Map<String, Boolean>> blocks, String req) {\n    int[] minDistances = new int[blocks.size()];\n    int closestReqIdx = Integer.MAX_VALUE;\n    for (int i = 0; i < blocks.size(); i++) {\n      if (blocks.get(i).get(req)) closestReqIdx = i;\n      minDistances[i] = distanceBetween(i, closestReqIdx);\n    }\n    for (int i = blocks.size() - 1; i >= 0; i--) {\n      if (blocks.get(i).get(req)) closestReqIdx = i;\n      minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n    }\n    return minDistances;\n  }\n\n  public static int[] getMaxDistancesAtBlocks(\n      List<Map<String, Boolean>> blocks, int[][] minDistancesFromBlocks) {\n    int[] maxDistancesAtBlocks = new int[blocks.size()];\n    for (int i = 0; i < blocks.size(); i++) {\n      int[] minDistancesAtBlock = new int[minDistancesFromBlocks.length];\n      for (int j = 0; j < minDistancesFromBlocks.length; j++) {\n        minDistancesAtBlock[j] = minDistancesFromBlocks[j][i];\n      }\n      maxDistancesAtBlocks[i] = arrayMax(minDistancesAtBlock);\n    }\n    return maxDistancesAtBlocks;\n  }\n\n  public static int getIdxAtMinValue(int[] array) {\n    int idxAtMinValue = 0;\n    int minValue = Integer.MAX_VALUE;\n    for (int i = 0; i < array.length; i++) {\n      int currentValue = array[i];\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        idxAtMinValue = i;\n      }\n    }\n    return idxAtMinValue;\n  }\n\n  public static int distanceBetween(int a, int b) {\n    return Math.abs(a - b);\n  }\n\n  public static int arrayMax(int[] array) {\n    int max = array[0];\n    for (int a : array) {\n      if (a > max) {\n        max = a;\n      }\n    }\n    return max;\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Map<String, Boolean>> blocks = new ArrayList<Map<String, Boolean>>();\n\n    blocks.add(0, new HashMap<String, Boolean>());\n    blocks.get(0).put("gym", false);\n    blocks.get(0).put("school", true);\n    blocks.get(0).put("store", false);\n\n    blocks.add(1, new HashMap<String, Boolean>());\n    blocks.get(1).put("gym", true);\n    blocks.get(1).put("school", false);\n    blocks.get(1).put("store", false);\n\n    blocks.add(2, new HashMap<String, Boolean>());\n    blocks.get(2).put("gym", true);\n    blocks.get(2).put("school", true);\n    blocks.get(2).put("store", false);\n\n    blocks.add(3, new HashMap<String, Boolean>());\n    blocks.get(3).put("gym", false);\n    blocks.get(3).put("school", true);\n    blocks.get(3).put("store", false);\n\n    blocks.add(4, new HashMap<String, Boolean>());\n    blocks.get(4).put("gym", false);\n    blocks.get(4).put("school", true);\n    blocks.get(4).put("store", true);\n\n    String[] reqs = new String[] {"gym", "school", "store"};\n    Utils.assertTrue(Program.apartmentHunting(blocks, reqs) == 3);\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<Map<String, Boolean>> blocks = new ArrayList<Map<String, Boolean>>();\n\n    blocks.add(0, new HashMap<String, Boolean>());\n    blocks.get(0).put("gym", false);\n    blocks.get(0).put("school", true);\n    blocks.get(0).put("store", false);\n\n    blocks.add(1, new HashMap<String, Boolean>());\n    blocks.get(1).put("gym", true);\n    blocks.get(1).put("school", false);\n    blocks.get(1).put("store", false);\n\n    blocks.add(2, new HashMap<String, Boolean>());\n    blocks.get(2).put("gym", true);\n    blocks.get(2).put("school", true);\n    blocks.get(2).put("store", false);\n\n    blocks.add(3, new HashMap<String, Boolean>());\n    blocks.get(3).put("gym", false);\n    blocks.get(3).put("school", true);\n    blocks.get(3).put("store", false);\n\n    blocks.add(4, new HashMap<String, Boolean>());\n    blocks.get(4).put("gym", false);\n    blocks.get(4).put("school", true);\n    blocks.get(4).put("store", true);\n\n    String[] reqs = new String[] {"gym", "school", "store"};\n    Utils.assertTrue(Program.apartmentHunting(blocks, reqs) == 3);\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function apartmentHunting(blocks, reqs) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.apartmentHunting = apartmentHunting;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const maxDistancesAtBlocks = new Array(blocks.length).fill(-Infinity);\n  for (let i = 0; i < blocks.length; i++) {\n    for (const req of reqs) {\n      let closestReqDistance = Infinity;\n      for (let j = 0; j < blocks.length; j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const minDistancesFromBlocks = reqs.map(req => getMinDistances(blocks, req));\n  const maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getMinDistances(blocks, req) {\n  const minDistances = new Array(blocks.length);\n  let closestReqIdx = Infinity;\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (let i = blocks.length - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nfunction getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks) {\n  const maxDistancesAtBlocks = new Array(blocks.length);\n  for (let i = 0; i < blocks.length; i++) {\n    const minDistancesAtBlock = minDistancesFromBlocks.map(distances => distances[i]);\n    maxDistancesAtBlocks[i] = Math.max(...minDistancesAtBlock);\n  }\n  return maxDistancesAtBlocks;\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    val maxDistancesAtBlocks = MutableList(blocks.size) { Int.MIN_VALUE }\n    for (i in 0 until blocks.size) {\n        for (req in reqs) {\n            var closestReqDistance = Int.MAX_VALUE\n            for (j in 0 until blocks.size) {\n                if (blocks[j].containsKey(req) && blocks[j][req]!!) {\n                    closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n                }\n            }\n            maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n        }\n    }\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n}\n\nfun getIdxAtMinValue(array: MutableList<Int>): Int {\n    var idxAtMinValue = 0\n    var minValue = Int.MAX_VALUE\n    for (i in 0 until array.size) {\n        val currentValue = array[i]\n        if (currentValue < minValue) {\n            minValue = currentValue\n            idxAtMinValue = i\n        }\n    }\n    return idxAtMinValue\n}\n\nfun distanceBetween(a: Int, b: Int): Int {\n    return abs(a - b)\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.abs\nimport kotlin.math.min\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nfun apartmentHunting(blocks: List<Map<String, Boolean>>, reqs: List<String>): Int {\n    val minDistancesFromBlocks = reqs.map { req -> getMinDistances(blocks, req) }\n    val maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n}\n\nfun getMinDistances(blocks: List<Map<String, Boolean>>, req: String): List<Int> {\n    val minDistances = MutableList<Int>(blocks.size) { 0 }\n    var closestReqIdx = Int.MAX_VALUE\n    for (i in 0 until blocks.size) {\n        if (blocks[i].containsKey(req) && blocks[i][req]!!) closestReqIdx = i\n        minDistances[i] = distanceBetween(i, closestReqIdx)\n    }\n    for (i in blocks.size - 1 downTo 0) {\n        if (blocks[i].containsKey(req) && blocks[i][req]!!) closestReqIdx = i\n        minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx))\n    }\n    return minDistances\n}\n\nfun getMaxDistancesAtBlocks(blocks: List<Map<String, Boolean>>, minDistancesFromBlocks: List<List<Int>>): List<Int> {\n    val maxDistancesAtBlocks = MutableList<Int>(blocks.size) { 0 }\n    for (i in 0 until blocks.size) {\n        val minDistancesAtBlock = minDistancesFromBlocks.map { distances -> distances[i] }\n        maxDistancesAtBlocks[i] = minDistancesAtBlock.max()!!\n    }\n    return maxDistancesAtBlocks\n}\n\nfun getIdxAtMinValue(array: List<Int>): Int {\n    var idxAtMinValue = 0\n    var minValue = Int.MAX_VALUE\n    for (i in 0 until array.size) {\n        val currentValue = array[i]\n        if (currentValue < minValue) {\n            minValue = currentValue\n            idxAtMinValue = i\n        }\n    }\n    return idxAtMinValue\n}\n\nfun distanceBetween(a: Int, b: Int): Int {\n    return abs(a - b)\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.apartmentHunting as apartmentHunting\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val blocks = listOf<Map<String, Boolean>>(\n            mapOf("gym" to false, "school" to true, "store" to false),\n            mapOf("gym" to true, "school" to false, "store" to false),\n            mapOf("gym" to true, "school" to true, "store" to false),\n            mapOf("gym" to false, "school" to true, "store" to false),\n            mapOf("gym" to false, "school" to true, "store" to true)\n        )\n        val reqs = listOf("gym", "school", "store")\n        println(apartmentHunting(blocks, reqs))\n        assert(apartmentHunting(blocks, reqs) == 3)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.apartmentHunting as apartmentHunting\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val blocks = listOf<Map<String, Boolean>>(\n            mapOf("gym" to false, "school" to true, "store" to false),\n            mapOf("gym" to true, "school" to false, "store" to false),\n            mapOf("gym" to true, "school" to true, "store" to false),\n            mapOf("gym" to false, "school" to true, "store" to false),\n            mapOf("gym" to false, "school" to true, "store" to true)\n        )\n        val reqs = listOf("gym", "school", "store")\n        println(apartmentHunting(blocks, reqs))\n        assert(apartmentHunting(blocks, reqs) == 3)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def apartmentHunting(blocks, reqs):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\ndef apartmentHunting(blocks, reqs):\n    maxDistancesAtBlocks = [float("-inf") for block in blocks]\n    for i in range(len(blocks)):\n        for req in reqs:\n            closestReqDistance = float("inf")\n            for j in range(len(blocks)):\n                if blocks[j][req]:\n                    closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n            maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n\n\ndef getIdxAtMinValue(array):\n    idxAtMinValue = 0\n    minValue = float("inf")\n    for i in range(len(array)):\n        currentValue = array[i]\n        if currentValue < minValue:\n            minValue = currentValue\n            idxAtMinValue = i\n    return idxAtMinValue\n\n\ndef distanceBetween(a, b):\n    return abs(a - b)\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\ndef apartmentHunting(blocks, reqs):\n    minDistancesFromBlocks = list(map(lambda req: getMinDistances(blocks, req), reqs))\n    maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n    return getIdxAtMinValue(maxDistancesAtBlocks)\n\n\ndef getMinDistances(blocks, req):\n    minDistances = [0 for block in blocks]\n    closestReqIdx = float("inf")\n    for i in range(len(blocks)):\n        if blocks[i][req]:\n            closestReqIdx = i\n        minDistances[i] = distanceBetween(i, closestReqIdx)\n    for i in reversed(range(len(blocks))):\n        if blocks[i][req]:\n            closestReqIdx = i\n        minDistances[i] = min(minDistances[i], distanceBetween(i, closestReqIdx))\n    return minDistances\n\n\ndef getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks):\n    maxDistancesAtBlocks = [0 for block in blocks]\n    for i in range(len(blocks)):\n        minDistancesAtBlock = list(map(lambda distances: distances[i], minDistancesFromBlocks))\n        maxDistancesAtBlocks[i] = max(minDistancesAtBlock)\n    return maxDistancesAtBlocks\n\n\ndef getIdxAtMinValue(array):\n    idxAtMinValue = 0\n    minValue = float("inf")\n    for i in range(len(array)):\n        currentValue = array[i]\n        if currentValue < minValue:\n            minValue = currentValue\n            idxAtMinValue = i\n    return idxAtMinValue\n\n\ndef distanceBetween(a, b):\n    return abs(a - b)\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        blocks = [\n            {"gym": False, "school": True, "store": False},\n            {"gym": True, "school": False, "store": False},\n            {"gym": True, "school": True, "store": False},\n            {"gym": False, "school": True, "store": False},\n            {"gym": False, "school": True, "store": True},\n        ]\n        reqs = ["gym", "school", "store"]\n        self.assertEqual(program.apartmentHunting(blocks, reqs), 3)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        blocks = [\n            {"gym": False, "school": True, "store": False},\n            {"gym": True, "school": False, "store": False},\n            {"gym": True, "school": True, "store": False},\n            {"gym": False, "school": True, "store": False},\n            {"gym": False, "school": True, "store": True},\n        ]\n        reqs = ["gym", "school", "store"]\n        self.assertEqual(program.apartmentHunting(blocks, reqs), 3)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(b^2 * r) time | O(b) space\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    var maxDistancesAtBlocks = Array(repeating: -Int.max, count: blocks.count)\n    for i in 0 ..< blocks.count {\n      for requirement in requirements {\n        var closestReqDistance = Int.max\n\n        for j in 0 ..< blocks.count {\n          if let requirementAvailable = blocks[j][requirement], requirementAvailable {\n            closestReqDistance = min(closestReqDistance, distanceBetween(i, j))\n          }\n        }\n\n        maxDistancesAtBlocks[i] = max(maxDistancesAtBlocks[i], closestReqDistance)\n      }\n    }\n\n    return getIndexAtMinValue(maxDistancesAtBlocks)\n  }\n\n  func getIndexAtMinValue(_ array: [Int]) -> Int {\n    var indexAtMinValue = 0\n    var minValue = Int.max\n\n    for i in 0 ..< array.count {\n      let currentValue = array[i]\n\n      if currentValue < minValue {\n        minValue = currentValue\n        indexAtMinValue = i\n      }\n    }\n\n    return indexAtMinValue\n  }\n\n  func distanceBetween(_ a: Int, _ b: Int) -> Int {\n    return abs(a - b)\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\n  func apartmentHunting(_ blocks: [[String: Bool]], _ requirements: [String]) -> Int {\n    let minDistancesFromBlocks = requirements.map { getMinDistances(blocks, $0) }\n    let maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks)\n\n    return getIndexAtMinValue(maxDistancesAtBlocks)\n  }\n\n  func getMinDistances(_ blocks: [[String: Bool]], _ requirement: String) -> [Int] {\n    var minDistances = Array(repeating: -1, count: blocks.count)\n    var closestRequirementIndex = Int.max\n\n    for i in 0 ..< blocks.count {\n      if let requirementAvailable = blocks[i][requirement], requirementAvailable {\n        closestRequirementIndex = i\n      }\n\n      minDistances[i] = distanceBetween(i, closestRequirementIndex)\n    }\n\n    for i in (0 ..< blocks.count).reversed() {\n      if let requirementAvailable = blocks[i][requirement], requirementAvailable {\n        closestRequirementIndex = i\n      }\n\n      minDistances[i] = min(minDistances[i], distanceBetween(i, closestRequirementIndex))\n    }\n\n    return minDistances\n  }\n\n  func getMaxDistancesAtBlocks(_ blocks: [[String: Bool]], _ minDistancesFromBlocks: [[Int]]) -> [Int] {\n    var maxDistancesAtBlocks = Array(repeating: -1, count: blocks.count)\n\n    for i in 0 ..< blocks.count {\n      let minDistancesAtBlock = minDistancesFromBlocks.map { $0[i] }\n\n      if let max = minDistancesAtBlock.max() {\n        maxDistancesAtBlocks[i] = max\n      }\n    }\n\n    return maxDistancesAtBlocks\n  }\n\n  func getIndexAtMinValue(_ array: [Int]) -> Int {\n    var indexAtMinValue = 0\n    var minValue = Int.max\n\n    for i in 0 ..< array.count {\n      let currentValue = array[i]\n\n      if currentValue < minValue {\n        minValue = currentValue\n        indexAtMinValue = i\n      }\n    }\n\n    return indexAtMinValue\n  }\n\n  func distanceBetween(_ a: Int, _ b: Int) -> Int {\n    return abs(a - b)\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let requirements = ["gym", "school", "store"]\n      let blocks = [\n        [\n          "gym": false,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": true,\n          "school": false,\n          "store": false,\n        ],\n        [\n          "gym": true,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": false,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": false,\n          "school": true,\n          "store": true,\n        ],\n      ]\n\n      try assertEqual(3, program.apartmentHunting(blocks, requirements))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let requirements = ["gym", "school", "store"]\n      let blocks = [\n        [\n          "gym": false,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": true,\n          "school": false,\n          "store": false,\n        ],\n        [\n          "gym": true,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": false,\n          "school": true,\n          "store": false,\n        ],\n        [\n          "gym": false,\n          "school": true,\n          "store": true,\n        ],\n      ]\n\n      try assertEqual(3, program.apartmentHunting(blocks, requirements))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "interface Block {\n  [key: string]: boolean;\n}\n\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface Block {\n  [key: string]: boolean;\n}\n\n// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  const maxDistancesAtBlocks = new Array(blocks.length).fill(-Infinity);\n  for (let i = 0; i < blocks.length; i++) {\n    for (const req of reqs) {\n      let closestReqDistance = Infinity;\n      for (let j = 0; j < blocks.length; j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getIdxAtMinValue(array: number[]) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a: number, b: number) {\n  return Math.abs(a - b);\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface Block {\n  [key: string]: boolean;\n}\n\n// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nexport function apartmentHunting(blocks: Block[], reqs: string[]) {\n  const minDistancesFromBlocks = reqs.map(req => getMinDistances(blocks, req));\n  const maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getMinDistances(blocks: Block[], req: string) {\n  const minDistances: number[] = new Array(blocks.length);\n  let closestReqIdx = Infinity;\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (let i = blocks.length - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nfunction getMaxDistancesAtBlocks(blocks: Block[], minDistancesFromBlocks: number[][]) {\n  const maxDistancesAtBlocks: number[] = new Array(blocks.length);\n  for (let i = 0; i < blocks.length; i++) {\n    const minDistancesAtBlock = minDistancesFromBlocks.map(distances => distances[i]);\n    maxDistancesAtBlocks[i] = Math.max(...minDistancesAtBlock);\n  }\n  return maxDistancesAtBlocks;\n}\n\nfunction getIdxAtMinValue(array: number[]) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a: number, b: number) {\n  return Math.abs(a - b);\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "blocks",
          example: [
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: true,
              school: false,
              store: false,
            },
            {
              gym: true,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: true,
            },
          ],
          schema: {
            items: {
              additionalProperties: {
                type: "boolean",
              },
              type: "object",
            },
            type: "array",
          },
        },
        {
          name: "reqs",
          example: ["gym", "school", "store"],
          schema: {
            items: {
              type: "string",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          blocks: [
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: true,
              school: false,
              store: false,
            },
            {
              gym: true,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: false,
              office: true,
              school: true,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: false,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "office", "school", "store"],
        },
        {
          blocks: [
            {
              gym: false,
              office: true,
              school: true,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: false,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "office", "school", "store"],
        },
        {
          blocks: [
            {
              foo: true,
              gym: false,
              kappa: false,
              office: true,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: false,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: false,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: false,
              kappa: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: true,
              school: false,
              store: false,
            },
          ],
          reqs: ["gym", "pool", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              office: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: true,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              office: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: true,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: true,
              school: false,
              store: false,
            },
          ],
          reqs: ["gym", "pool", "school", "store"],
        },
      ],
      jsonTests: [
        {
          blocks: [
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: true,
              school: false,
              store: false,
            },
            {
              gym: true,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: false,
              office: true,
              school: true,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: false,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "office", "school", "store"],
        },
        {
          blocks: [
            {
              gym: false,
              office: true,
              school: true,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: false,
              store: false,
            },
            {
              gym: true,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "office", "school", "store"],
        },
        {
          blocks: [
            {
              foo: true,
              gym: false,
              kappa: false,
              office: true,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: false,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: false,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: true,
              kappa: false,
              office: false,
              school: true,
              store: false,
            },
            {
              foo: true,
              gym: false,
              kappa: false,
              office: false,
              school: true,
              store: true,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              school: true,
              store: false,
            },
          ],
          reqs: ["gym", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              pool: true,
              school: false,
              store: false,
            },
          ],
          reqs: ["gym", "pool", "school", "store"],
        },
        {
          blocks: [
            {
              gym: true,
              office: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: true,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: true,
            },
            {
              gym: true,
              office: true,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: true,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: false,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: false,
              school: true,
              store: false,
            },
            {
              gym: false,
              office: false,
              pool: true,
              school: false,
              store: false,
            },
          ],
          reqs: ["gym", "pool", "school", "store"],
        },
      ],
      changelog: [],
      id: 31,
    },
    {
      uid: "palindrome-partitioning-min-cuts",
      testStrategy: "JSON",
      name: "Palindrome Partitioning Min Cuts",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Dynamic Programming",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 3954,
        failureCount: 1338,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "225713438",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 2290,
      },
      prompt:
        '<div class="html">\n<p>\n  Given a non-empty string, write a function that returns the minimum number of\n  cuts needed to perform on the string such that each remaining substring is a\n  palindrome.\n</p>\n<p>\n  A palindrome is defined as a string that\'s written the same forward as\n  backward. Note that single-character strings are palindromes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "noonabbad"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// noon | abba | d"</span>\n</pre>\n</div>',
      hints: [
        "<p>\nTry building a two-dimensional array of the palindromicities of all substrings of the input string. Let the value stored at row i and at column j represent the palindromicity of the substring starting at index i and ending at index j.\n</p>\n",
        "\n<p>\nChecking for palindromicity is typically an O(n) time operation. Can you eliminate this step and build the same two-dimensional array mentioned in Hint #1 a different way? Realize that the substring whose starting and ending indices are (i, j) is only a palindrome if string[i] is equal to string[j] and if the substring denoted by (i + 1, j - 1) is also a palindrome.\n</p>\n",
        "\n<p>\nBuild a one-dimensional array of the same length as the input string. At each index i in this array compute and store the minimum number of cuts needed for the substring whose starting and ending indices are (0, i). Use previously calculated values as well as the two-dimensional array mentioned in Hint #1 to find each value in this array.\n</p>",
      ],
      spaceTime:
        "O(n^2) time | O(n^2) space - where n is the length of the input string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint palindromePartitioningMinCuts(string string) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <climits>\nusing namespace std;\n\nbool isPalindrome(string s);\n\n// O(n^3) time | O(n^2) space\nint palindromePartitioningMinCuts(string s) {\n  vector<vector<bool>> palindromes(s.length(), vector<bool>(s.length(), false));\n  for (int i = 0; i < s.length(); i++) {\n    for (int j = i; j < s.length(); j++) {\n      palindromes[i][j] = isPalindrome(s.substr(i, j + 1 - i));\n    }\n  }\n  vector<int> cuts(s.length(), INT_MAX);\n  for (int i = 0; i < s.length(); i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (int j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[s.length() - 1];\n}\n\nbool isPalindrome(string s) {\n  int leftIdx = 0;\n  int rightIdx = s.length() - 1;\n  while (leftIdx < rightIdx) {\n    if (s[leftIdx] != s[rightIdx]) {\n      return false;\n    }\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// O(n^2) time | O(n^2) space\nint palindromePartitioningMinCuts(string s) {\n  vector<vector<bool>> palindromes(s.length(), vector<bool>(s.length(), false));\n  for (int i = 0; i < s.length(); i++) {\n    palindromes[i][i] = true;\n  }\n  for (int length = 2; length < s.length() + 1; length++) {\n    for (int i = 0; i < s.length() - length + 1; i++) {\n      int j = i + length - 1;\n      if (length == 2) {\n        palindromes[i][j] = (s[i] == s[j]);\n      } else {\n        palindromes[i][j] = (s[i] == s[j] && palindromes[i + 1][j - 1]);\n      }\n    }\n  }\n  vector<int> cuts(s.length(), INT_MAX);\n  for (int i = 0; i < s.length(); i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (int j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[s.length() - 1];\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(palindromePartitioningMinCuts("noonabbad") == 2); });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(palindromePartitioningMinCuts("noonabbad") == 2); });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int PalindromePartitioningMinCuts(string str) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n^3) time | O(n^2) space\n\tpublic static int PalindromePartitioningMinCuts(string str) {\n\t\tbool[,] palindromes = new bool[str.Length,str.Length];\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tfor (int j = i; j < str.Length; j++) {\n\t\t\t\tpalindromes[i,j] = IsPalindrome(str.Substring(i, j + 1 - i));\n\t\t\t}\n\t\t}\n\t\tint[] cuts = new int[str.Length];\n\t\tArray.Fill(cuts, Int32.MaxValue);\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tif (palindromes[0,i]) {\n\t\t\t\tcuts[i] = 0;\n\t\t\t} else {\n\t\t\t\tcuts[i] = cuts[i - 1] + 1;\n\t\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\t\tif (palindromes[j,i] && cuts[j - 1] + 1 < cuts[i]) {\n\t\t\t\t\t\tcuts[i] = cuts[j - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cuts[str.Length - 1];\n\t}\n\n\tpublic static bool IsPalindrome(string str) {\n\t\tint leftIdx = 0;\n\t\tint rightIdx = str.Length - 1;\n\t\twhile (leftIdx < rightIdx) {\n\t\t\tif (str[leftIdx] != str[rightIdx]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tleftIdx++;\n\t\t\trightIdx--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// O(n^2) time | O(n^2) space\n\tpublic static int PalindromePartitioningMinCuts(string str) {\n\t\tbool[,] palindromes = new bool[str.Length,str.Length];\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tfor (int j = 0; j < str.Length; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tpalindromes[i,j] = true;\n\t\t\t\t} else {\n\t\t\t\t\tpalindromes[i,j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int length = 2; length < str.Length + 1; length++) {\n\t\t\tfor (int i = 0; i < str.Length - length + 1; i++) {\n\t\t\t\tint j = i + length - 1;\n\t\t\t\tif (length == 2) {\n\t\t\t\t\tpalindromes[i,j] = (str[i] == str[j]);\n\t\t\t\t} else {\n\t\t\t\t\tpalindromes[i,\n\t\t\t\t\t  j] =\n\t\t\t\t\t  (str[i] == str[j] && palindromes[i + 1,j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] cuts = new int[str.Length];\n\t\tArray.Fill(cuts, Int32.MaxValue);\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tif (palindromes[0,i]) {\n\t\t\t\tcuts[i] = 0;\n\t\t\t} else {\n\t\t\t\tcuts[i] = cuts[i - 1] + 1;\n\t\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\t\tif (palindromes[j,i] && cuts[j - 1] + 1 < cuts[i]) {\n\t\t\t\t\t\tcuts[i] = cuts[j - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cuts[str.Length - 1];\n\t}\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.PalindromePartitioningMinCuts("noonabbad") == 2);\n\t}\n}\n',
          unitTests:
            'public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.PalindromePartitioningMinCuts("noonabbad") == 2);\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc PalindromePartitioningMinCuts(str string) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport "math"\n\nfunc PalindromePartitioningMinCuts(s string) int {\n\tpalindromes := make([][]bool, len(s))\n\tfor i := range palindromes {\n\t\tpalindromes[i] = make([]bool, len(s))\n\t}\n\tfor i := range s {\n\t\tfor j := i; j < len(s); j++ {\n\t\t\tpalindromes[i][j] = isPalindrome(s[i : j+1])\n\t\t}\n\t}\n\tcuts := make([]int, len(s))\n\tfor i := range cuts {\n\t\tcuts[i] = math.MinInt32\n\t}\n\tfor i := range s {\n\t\tif palindromes[0][i] {\n\t\t\tcuts[i] = 0\n\t\t} else {\n\t\t\tcuts[i] = cuts[i-1] + 1\n\t\t\tfor j := 1; j < i; j++ {\n\t\t\t\tif palindromes[j][i] && cuts[j-1]+1 < cuts[i] {\n\t\t\t\t\tcuts[i] = cuts[j-1] + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cuts[len(s)-1]\n}\n\nfunc isPalindrome(s string) bool {\n\tfor i := 0; i < len(s)/2; i++ {\n\t\tif s[i] != s[len(s)-i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n',
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport "math"\n\n// O(n^2) time | O(n^2) space\nfunc PalindromePartitioningMinCuts(str string) int {\n\tpalindromes := make([][]bool, len(str))\n\tfor i := range palindromes {\n\t\tpalindromes[i] = make([]bool, len(str))\n\t}\n\tfor i := range str {\n\t\tpalindromes[i][i] = true\n\t}\n\tfor length := 2; length < len(str)+1; length++ {\n\t\tfor i := 0; i < len(str)-length+1; i++ {\n\t\t\tj := i + length - 1\n\t\t\tif length == 2 {\n\t\t\t\tpalindromes[i][j] = (str[i] == str[j])\n\t\t\t} else {\n\t\t\t\tpalindromes[i][j] = (str[i] == str[j] && palindromes[i+1][j-1])\n\t\t\t}\n\t\t}\n\t}\n\tcuts := make([]int, len(str))\n\tfor i := range cuts {\n\t\tcuts[i] = math.MaxInt32\n\t}\n\tfor i := range str {\n\t\tif palindromes[0][i] {\n\t\t\tcuts[i] = 0\n\t\t} else {\n\t\t\tcuts[i] = cuts[i-1] + 1\n\t\t\tfor j := 1; j < i; j++ {\n\t\t\t\tif palindromes[j][i] && cuts[j-1]+1 < cuts[i] {\n\t\t\t\t\tcuts[i] = cuts[j-1] + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cuts[len(cuts)-1]\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport "github.com/stretchr/testify/require"\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\toutput := PalindromePartitioningMinCuts("noonabbad")\n\trequire.Equal(t, 2, output)\n}\n',
          unitTests:
            'package main\n\nimport "github.com/stretchr/testify/require"\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\toutput := PalindromePartitioningMinCuts("noonabbad")\n\trequire.Equal(t, 2, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int palindromePartitioningMinCuts(String str) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.Arrays;\n\nclass Program {\n  // O(n^3) time | O(n^2) space\n  public static int palindromePartitioningMinCuts(String str) {\n    boolean[][] palindromes = new boolean[str.length()][str.length()];\n    for (int i = 0; i < str.length(); i++) {\n      for (int j = i; j < str.length(); j++) {\n        palindromes[i][j] = isPalindrome(str.substring(i, j + 1));\n      }\n    }\n    int[] cuts = new int[str.length()];\n    Arrays.fill(cuts, Integer.MAX_VALUE);\n    for (int i = 0; i < str.length(); i++) {\n      if (palindromes[0][i]) {\n        cuts[i] = 0;\n      } else {\n        cuts[i] = cuts[i - 1] + 1;\n        for (int j = 1; j < i; j++) {\n          if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n            cuts[i] = cuts[j - 1] + 1;\n          }\n        }\n      }\n    }\n    return cuts[str.length() - 1];\n  }\n\n  public static boolean isPalindrome(String str) {\n    int leftIdx = 0;\n    int rightIdx = str.length() - 1;\n    while (leftIdx < rightIdx) {\n      if (str.charAt(leftIdx) != str.charAt(rightIdx)) {\n        return false;\n      }\n      leftIdx++;\n      rightIdx--;\n    }\n    return true;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.Arrays;\n\nclass Program {\n  // O(n^2) time | O(n^2) space\n  public static int palindromePartitioningMinCuts(String str) {\n    boolean[][] palindromes = new boolean[str.length()][str.length()];\n    for (int i = 0; i < str.length(); i++) {\n      for (int j = 0; j < str.length(); j++) {\n        if (i == j) {\n          palindromes[i][j] = true;\n        } else {\n          palindromes[i][j] = false;\n        }\n      }\n    }\n    for (int length = 2; length < str.length() + 1; length++) {\n      for (int i = 0; i < str.length() - length + 1; i++) {\n        int j = i + length - 1;\n        if (length == 2) {\n          palindromes[i][j] = (str.charAt(i) == str.charAt(j));\n        } else {\n          palindromes[i][j] = (str.charAt(i) == str.charAt(j) && palindromes[i + 1][j - 1]);\n        }\n      }\n    }\n    int[] cuts = new int[str.length()];\n    Arrays.fill(cuts, Integer.MAX_VALUE);\n    for (int i = 0; i < str.length(); i++) {\n      if (palindromes[0][i]) {\n        cuts[i] = 0;\n      } else {\n        cuts[i] = cuts[i - 1] + 1;\n        for (int j = 1; j < i; j++) {\n          if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n            cuts[i] = cuts[j - 1] + 1;\n          }\n        }\n      }\n    }\n    return cuts[str.length() - 1];\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.palindromePartitioningMinCuts("noonabbad") == 2);\n  }\n}\n',
          unitTests:
            'class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.palindromePartitioningMinCuts("noonabbad") == 2);\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function palindromePartitioningMinCuts(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^3) time | O(n^2) space\nfunction palindromePartitioningMinCuts(string) {\n  const palindromes = new Array(string.length).fill(1).map(row => []);\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i; j < string.length; j++) {\n      palindromes[i][j] = isPalindrome(string.slice(i, j + 1));\n    }\n  }\n  const cuts = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n\nfunction isPalindrome(string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n^2) space\nfunction palindromePartitioningMinCuts(string) {\n  const palindromes = [];\n  for (let i = 0; i < string.length; i++) {\n    const row = [];\n    for (let j = 0; j < string.length; j++) {\n      if (i === j) {\n        row.push(true);\n      } else {\n        row.push(false);\n      }\n    }\n    palindromes.push(row);\n  }\n  for (let length = 2; length < string.length + 1; length++) {\n    for (let i = 0; i < string.length - length + 1; i++) {\n      const j = i + length - 1;\n      if (length === 2) {\n        palindromes[i][j] = string[i] === string[j];\n      } else {\n        palindromes[i][j] = string[i] === string[j] && palindromes[i + 1][j - 1];\n      }\n    }\n  }\n  const cuts = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun palindromePartitioningMinCuts(str: String): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^3) time | O(n^2) space\nfun palindromePartitioningMinCuts(str: String): Int {\n    val palindromes = Array(str.length) { Array(str.length) { false } }\n    for (i in 0 until str.length) {\n        for (j in i until str.length) {\n            palindromes[i][j] = isPalindrome(str.substring(i, j + 1))\n        }\n    }\n\n    val cuts = Array(str.length) { Int.MAX_VALUE }\n    for (i in 0 until str.length) {\n        if (palindromes[0][i]) {\n            cuts[i] = 0\n        } else {\n            cuts[i] = cuts[i - 1] + 1\n            for (j in 1 until i) {\n                if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n                    cuts[i] = cuts[j - 1] + 1\n                }\n            }\n        }\n    }\n    return cuts[str.length - 1]\n}\n\nfun isPalindrome(str: String): Boolean {\n    var leftIdx = 0\n    var rightIdx = str.length - 1\n    while (leftIdx < rightIdx) {\n        if (str[leftIdx] != str[rightIdx]) {\n            return false\n        }\n        leftIdx++\n        rightIdx--\n    }\n    return true\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n^2) space\nfun palindromePartitioningMinCuts(str: String): Int {\n    val palindromes = Array(str.length) { Array(str.length) { false } }\n    for (i in 0 until str.length) {\n        for (j in i until str.length) {\n            if (i == j) {\n                palindromes[i][j] = true\n            } else {\n                palindromes[i][j] = false\n            }\n        }\n    }\n\n    for (length in 2 until str.length + 1) {\n        for (i in 0 until str.length - length + 1) {\n            val j = i + length - 1\n            if (length == 2) {\n                palindromes[i][j] = (str[i] == str[j])\n            } else {\n                palindromes[i][j] = (str[i] == str[j] && palindromes[i + 1][j - 1])\n            }\n        }\n    }\n\n    val cuts = Array(str.length) { Int.MAX_VALUE }\n    for (i in 0 until str.length) {\n        if (palindromes[0][i]) {\n            cuts[i] = 0\n        } else {\n            cuts[i] = cuts[i - 1] + 1\n            for (j in 1 until i) {\n                if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n                    cuts[i] = cuts[j - 1] + 1\n                }\n            }\n        }\n    }\n    return cuts[str.length - 1]\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.palindromePartitioningMinCuts\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(palindromePartitioningMinCuts("noonabbad") == 2)\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.palindromePartitioningMinCuts\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(palindromePartitioningMinCuts("noonabbad") == 2)\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def palindromePartitioningMinCuts(string):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^3) time | O(n^2) space\ndef palindromePartitioningMinCuts(string):\n    palindromes = [[False for i in string] for j in string]\n    for i in range(len(string)):\n        for j in range(i, len(string)):\n            palindromes[i][j] = isPalindrome(string[i : j + 1])\n    cuts = [float("inf") for i in string]\n    for i in range(len(string)):\n        if palindromes[0][i]:\n            cuts[i] = 0\n        else:\n            cuts[i] = cuts[i - 1] + 1\n            for j in range(1, i):\n                if palindromes[j][i] and cuts[j - 1] + 1 < cuts[i]:\n                    cuts[i] = cuts[j - 1] + 1\n    return cuts[-1]\n\n\ndef isPalindrome(string):\n    leftIdx = 0\n    rightIdx = len(string) - 1\n    while leftIdx < rightIdx:\n        if string[leftIdx] != string[rightIdx]:\n            return False\n        leftIdx += 1\n        rightIdx -= 1\n    return True\n',
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n^2) space\ndef palindromePartitioningMinCuts(string):\n    palindromes = [[False for i in string] for j in string]\n    for i in range(len(string)):\n        palindromes[i][i] = True\n    for length in range(2, len(string) + 1):\n        for i in range(0, len(string) - length + 1):\n            j = i + length - 1\n            if length == 2:\n                palindromes[i][j] = string[i] == string[j]\n            else:\n                palindromes[i][j] = string[i] == string[j] and palindromes[i + 1][j - 1]\n    cuts = [float("inf") for i in string]\n    for i in range(len(string)):\n        if palindromes[0][i]:\n            cuts[i] = 0\n        else:\n            cuts[i] = cuts[i - 1] + 1\n            for j in range(1, i):\n                if palindromes[j][i] and cuts[j - 1] + 1 < cuts[i]:\n                    cuts[i] = cuts[j - 1] + 1\n    return cuts[-1]\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.palindromePartitioningMinCuts("noonabbad"), 2)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.palindromePartitioningMinCuts("noonabbad"), 2)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def palindromePartitioningMinCuts(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def palindromePartitioningMinCuts(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def palindromePartitioningMinCuts(string)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.palindromePartitioningMinCuts\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.palindromePartitioningMinCuts\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func palindromePartitioningMinCuts(_ string: String) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^3) time | O(n^2) space\n  func palindromePartitioningMinCuts(_ string: String) -> Int {\n    var palindromes = string.map { _ in Array(repeating: false, count: string.count) }\n\n    for i in 0 ..< string.count {\n      for j in i ..< string.count {\n        let leftIndex = string.index(string.startIndex, offsetBy: i)\n        let rightIndex = string.index(string.startIndex, offsetBy: j)\n        let subString = String(string[leftIndex ... rightIndex])\n\n        palindromes[i][j] = isPalindrome(subString)\n      }\n    }\n\n    var cuts = Array(repeating: Int.max, count: string.count)\n\n    for i in 0 ..< string.count {\n      if palindromes[0][i] {\n        cuts[i] = 0\n      } else {\n        cuts[i] = cuts[i - 1] + 1\n\n        for j in 1 ..< i {\n          if palindromes[j][i], cuts[j - 1] + 1 < cuts[i] {\n            cuts[i] = cuts[j - 1] + 1\n          }\n        }\n      }\n    }\n\n    return cuts[string.count - 1]\n  }\n\n  func isPalindrome(_ string: String) -> Bool {\n    var leftIndex = 0\n    var rightIndex = string.count - 1\n\n    while leftIndex < rightIndex {\n      let leftStringIndex = string.index(string.startIndex, offsetBy: leftIndex)\n      let rightStringIndex = string.index(string.startIndex, offsetBy: rightIndex)\n\n      if string[leftStringIndex] != string[rightStringIndex] {\n        return false\n      }\n\n      leftIndex += 1\n      rightIndex -= 1\n    }\n\n    return true\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n^2) space\n  func palindromePartitioningMinCuts(_ string: String) -> Int {\n    var palindromes = string.map { _ in Array(repeating: false, count: string.count) }\n\n    for i in 0 ..< string.count {\n      palindromes[i][i] = true\n    }\n\n    for length in stride(from: 2, through: string.count, by: 1) {\n      for i in stride(from: 0, through: string.count - length, by: 1) {\n        let j = i + length - 1\n\n        let iStringIndex = string.index(string.startIndex, offsetBy: i)\n        let jStringIndex = string.index(string.startIndex, offsetBy: j)\n\n        if length == 2, string[iStringIndex] == string[jStringIndex] {\n          palindromes[i][j] = true\n        } else if palindromes[i + 1][j - 1], string[iStringIndex] == string[jStringIndex] {\n          palindromes[i][j] = true\n        }\n      }\n    }\n\n    var cuts = Array(repeating: Int.max, count: string.count)\n\n    for i in 0 ..< string.count {\n      if palindromes[0][i] {\n        cuts[i] = 0\n      } else {\n        cuts[i] = cuts[i - 1] + 1\n\n        for j in 1 ..< i {\n          if palindromes[j][i], cuts[j - 1] + 1 < cuts[i] {\n            cuts[i] = cuts[j - 1] + 1\n          }\n        }\n      }\n    }\n\n    return cuts[string.count - 1]\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(2, program.palindromePartitioningMinCuts("noonabbad"))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(2, program.palindromePartitioningMinCuts("noonabbad"))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function palindromePartitioningMinCuts(string: string) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^3) time | O(n^2) space\nexport function palindromePartitioningMinCuts(string: string) {\n  const palindromes: boolean[][] = new Array(string.length).fill(1).map(row => []);\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i; j < string.length; j++) {\n      palindromes[i][j] = isPalindrome(string.slice(i, j + 1));\n    }\n  }\n  const cuts: number[] = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n\nfunction isPalindrome(string: string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n^2) space\nexport function palindromePartitioningMinCuts(string: string) {\n  const palindromes: boolean[][] = [];\n  for (let i = 0; i < string.length; i++) {\n    const row: boolean[] = [];\n    for (let j = 0; j < string.length; j++) {\n      if (i === j) {\n        row.push(true);\n      } else {\n        row.push(false);\n      }\n    }\n    palindromes.push(row);\n  }\n  for (let length = 2; length < string.length + 1; length++) {\n    for (let i = 0; i < string.length - length + 1; i++) {\n      const j = i + length - 1;\n      if (length === 2) {\n        palindromes[i][j] = string[i] === string[j];\n      } else {\n        palindromes[i][j] = string[i] === string[j] && palindromes[i + 1][j - 1];\n      }\n    }\n  }\n  const cuts: number[] = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "string",
          example: "noonabbad",
          schema: {
            minLength: 1,
            type: "string",
          },
        },
      ],
      tests: [
        {
          string: "noonabbad",
        },
        {
          string: "a",
        },
        {
          string: "abba",
        },
        {
          string: "abbba",
        },
        {
          string: "abb",
        },
        {
          string: "abbb",
        },
        {
          string: "abcbm",
        },
        {
          string: "ababbbabbababa",
        },
        {
          string: "abbbacecffgbgffab",
        },
        {
          string: "abcdefghijklmonpqrstuvwxyz",
        },
        {
          string: "abcdefghijklmracecaronpqrstuvwxyz",
        },
      ],
      jsonTests: [
        {
          string: "noonabbad",
        },
        {
          string: "a",
        },
        {
          string: "abba",
        },
        {
          string: "abbba",
        },
        {
          string: "abb",
        },
        {
          string: "abbb",
        },
        {
          string: "abcbm",
        },
        {
          string: "ababbbabbababa",
        },
        {
          string: "abbbacecffgbgffab",
        },
        {
          string: "abcdefghijklmonpqrstuvwxyz",
        },
        {
          string: "abcdefghijklmracecaronpqrstuvwxyz",
        },
      ],
      changelog: [],
      id: 32,
    },
    {
      uid: "quickselect",
      testStrategy: "JSON",
      name: "Quickselect",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Searching",
      difficulty: 3,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 7496,
        failureCount: 2496,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "249381541",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1638,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of distinct integers as well as an\n  integer <span>k</span> and that returns the kth smallest integer in that array.\n</p>\n<p>The function should do this in linear time, on average.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 7, 6, 3]\n<span class="CodeEditor-promptParameter">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n</pre>\n</div>',
      hints: [
        "<p>\nThe Quick Sort sorting algorithm works by picking a \"pivot\" number from an array, positioning every other number in the array in sorted order with respect to the pivot (all smaller numbers to the pivot's left; all bigger numbers to the pivot's right), and then repeating the same two steps on both sides of the pivot until the entire array is sorted. Apply the technique used in Quick Sort until the pivot element gets positioned in the kth place in the array, at which point you'll have found the answer to the problem.\n</p>\n",
        "\n<p>\nPick a random number from the input array (the first number, for instance) and let that number be the pivot. Iterate through the rest of the array using two pointers, one starting at the left extremity of the array and progressively moving to the right, and the other one starting at the right extremity of the array and progressively moving to the left. As you iterate through the array, compare the left and right pointer numbers to the pivot. If the left number is greater than the pivot and the right number is less than the pivot, swap them; this will effectively sort these numbers with respect to the pivot at the end of the iteration. If the left number is ever less than or equal to the pivot, increment the left pointer; similarly, if the right number is ever greater than or equal to the pivot, decrement the right pointer. Do this until the pointers pass each other, at which point swapping the pivot with the right number should position the pivot in its final, sorted position, where every number to its left is smaller and every number to its right is greater. If the pivot is in the kth position, you're done; if it isn't, figure out if the kth smallest number is located to the left or to the right of the pivot.\n</p>\n",
        "\n<p>\nRepeat the process mentioned in Hint #2 on the side of the kth smallest number, and keep on repeating the process thereafter until you find the answer. What is the time complexity of this algorithm?\n</p>",
      ],
      spaceTime:
        "Best: O(n) time | O(1) space - where n is the length of the input array\nAverage: O(n) time | O(1) space - where n is the length of the input array\nWorst: O(n^2) time | O(1) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nint quickselect(vector<int> array, int k) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nint quickselectHelper(vector<int> array, int startIdx, int endIdx,\n                      int position);\n\n// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nint quickselect(vector<int> array, int k) {\n  int position = k - 1;\n  return quickselectHelper(array, 0, array.size() - 1, position);\n}\n\nint quickselectHelper(vector<int> array, int startIdx, int endIdx,\n                      int position) {\n  while (true) {\n    if (startIdx > endIdx) {\n      perror("Your Algorithm should never arrive here!");\n      exit(1);\n    }\n    int pivotIdx = startIdx;\n    int leftIdx = startIdx + 1;\n    int rightIdx = endIdx;\n    while (leftIdx <= rightIdx) {\n      if (array[leftIdx] > array[pivotIdx] &&\n          array[rightIdx] < array[pivotIdx]) {\n        swap(array[leftIdx], array[rightIdx]);\n      }\n      if (array[leftIdx] <= array[pivotIdx]) {\n        leftIdx++;\n      }\n      if (array[rightIdx] >= array[pivotIdx]) {\n        rightIdx--;\n      }\n    }\n    swap(array[pivotIdx], array[rightIdx]);\n    if (rightIdx == position) {\n      return array[rightIdx];\n    } else if (rightIdx < position) {\n      startIdx = rightIdx + 1;\n    } else {\n      endIdx = rightIdx - 1;\n    }\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(quickselect({8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      assert(quickselect({8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int Quickselect(int[] array, int k) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\npublic class Program {\n\t// Best: O(n) time | O(1) space\n\t// Average: O(n) time | O(1) space\n\t// Worst: O(n^2) time | O(1) space\n\tpublic static int Quickselect(int[] array, int k) {\n\t\tint position = k - 1;\n\t\treturn Quickselect(array, 0, array.Length - 1, position);\n\t}\n\n\tpublic static int Quickselect(int[] array, int startIdx, int endIdx, int position) {\n\t\twhile (true) {\n\t\t\tif (startIdx > endIdx) {\n\t\t\t\tthrow new Exception("Your Algorithm should never arrive here!");\n\t\t\t}\n\t\t\tint pivotIdx = startIdx;\n\t\t\tint leftIdx = startIdx + 1;\n\t\t\tint rightIdx = endIdx;\n\t\t\twhile (leftIdx <= rightIdx) {\n\t\t\t\tif (array[leftIdx] > array[pivotIdx] &&\n\t\t\t\t  array[rightIdx] < array[pivotIdx]) {\n\t\t\t\t\tswap(leftIdx, rightIdx, array);\n\t\t\t\t}\n\t\t\t\tif (array[leftIdx] <= array[pivotIdx]) {\n\t\t\t\t\tleftIdx++;\n\t\t\t\t}\n\t\t\t\tif (array[rightIdx] >= array[pivotIdx]) {\n\t\t\t\t\trightIdx--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(pivotIdx, rightIdx, array);\n\t\t\tif (rightIdx == position) {\n\t\t\t\treturn array[rightIdx];\n\t\t\t} else if (rightIdx < position) {\n\t\t\t\tstartIdx = rightIdx + 1;\n\t\t\t} else {\n\t\t\t\tendIdx = rightIdx - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void swap(int i, int j, int[] array) {\n\t\tint temp = array[j];\n\t\tarray[j] = array[i];\n\t\tarray[i] = temp;\n\t}\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.Quickselect(new int[] {8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.Quickselect(new int[] {8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc Quickselect(array []int, k int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunc Quickselect(array []int, k int) int {\n\treturn helper(array, 0, len(array)-1, k-1)\n}\n\nfunc helper(array []int, start, end int, position int) int {\n\tfor {\n\t\tif start > end {\n\t\t\tpanic("This should never happen!")\n\t\t}\n\t\tpivot, left, right := start, start+1, end\n\t\tfor left <= right {\n\t\t\tif array[left] > array[right] && array[right] < array[pivot] {\n\t\t\t\tswap(left, right, array)\n\t\t\t}\n\t\t\tif array[left] <= array[pivot] {\n\t\t\t\tleft += 1\n\t\t\t}\n\t\t\tif array[right] >= array[pivot] {\n\t\t\t\tright -= 1\n\t\t\t}\n\t\t}\n\t\tswap(pivot, right, array)\n\t\tif right == position {\n\t\t\treturn array[right]\n\t\t} else if right < position {\n\t\t\tstart = right + 1\n\t\t} else {\n\t\t\tend = right - 1\n\t\t}\n\t}\n}\n\nfunc swap(one, two int, array []int) {\n\tarray[one], array[two] = array[two], array[one]\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 5\n\toutput := Quickselect([]int{8, 5, 2, 9, 7, 6, 3}, 3)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 5\n\toutput := Quickselect([]int{8, 5, 2, 9, 7, 6, 3}, 3)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int quickselect(int[] array, int k) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(n) time | O(1) space\n  // Average: O(n) time | O(1) space\n  // Worst: O(n^2) time | O(1) space\n  public static int quickselect(int[] array, int k) {\n    int position = k - 1;\n    return quickselect(array, 0, array.length - 1, position);\n  }\n\n  public static int quickselect(int[] array, int startIdx, int endIdx, int position) {\n    while (true) {\n      if (startIdx > endIdx) {\n        throw new RuntimeException("Your Algorithm should never arrive here!");\n      }\n      int pivotIdx = startIdx;\n      int leftIdx = startIdx + 1;\n      int rightIdx = endIdx;\n      while (leftIdx <= rightIdx) {\n        if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n          swap(leftIdx, rightIdx, array);\n        }\n        if (array[leftIdx] <= array[pivotIdx]) {\n          leftIdx++;\n        }\n        if (array[rightIdx] >= array[pivotIdx]) {\n          rightIdx--;\n        }\n      }\n      swap(pivotIdx, rightIdx, array);\n      if (rightIdx == position) {\n        return array[rightIdx];\n      } else if (rightIdx < position) {\n        startIdx = rightIdx + 1;\n      } else {\n        endIdx = rightIdx - 1;\n      }\n    }\n  }\n\n  public static void swap(int i, int j, int[] array) {\n    int temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n  }\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.quickselect(new int[] {8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.quickselect(new int[] {8, 5, 2, 9, 7, 6, 3}, 3) == 5);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function quickselect(array, k) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.quickselect = quickselect;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunction quickselect(array, k) {\n  const position = k - 1;\n  return quickselectHelper(array, 0, array.length - 1, position);\n}\n\nfunction quickselectHelper(array, startIdx, endIdx, position) {\n  while (true) {\n    if (startIdx > endIdx) {\n      throw new Error('Your algorithm should never arrive here!');\n    }\n    const pivotIdx = startIdx;\n    let leftIdx = startIdx + 1;\n    let rightIdx = endIdx;\n    while (leftIdx <= rightIdx) {\n      if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n        swap(leftIdx, rightIdx, array);\n      }\n      if (array[leftIdx] <= array[pivotIdx]) {\n        leftIdx++;\n      }\n      if (array[rightIdx] >= array[pivotIdx]) {\n        rightIdx--;\n      }\n    }\n    swap(pivotIdx, rightIdx, array);\n    if (rightIdx === position) {\n      return array[rightIdx];\n    } else if (rightIdx < position) {\n      startIdx = rightIdx + 1;\n    } else {\n      endIdx = rightIdx - 1;\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.quickselect = quickselect;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun quickselect(array: MutableList<Int>, k: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfun quickselect(array: MutableList<Int>, k: Int): Int {\n    val position = k - 1\n    return quickselectHelper(array, 0, array.size - 1, position)\n}\n\nfun quickselectHelper(array: MutableList<Int>, startIdx: Int, endIdx: Int, position: Int): Int {\n    var newStartIdx = startIdx\n    var newEndIdx = endIdx\n    while (true) {\n        if (newStartIdx > newEndIdx) {\n            throw Exception("Your algorithm should never arrive here!")\n        }\n        val pivotIdx = newStartIdx\n        var leftIdx = newStartIdx + 1\n        var rightIdx = newEndIdx\n        while (leftIdx <= rightIdx) {\n            if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n                swap(leftIdx, rightIdx, array)\n            }\n            if (array[leftIdx] <= array[pivotIdx]) {\n                leftIdx++\n            }\n            if (array[rightIdx] >= array[pivotIdx]) {\n                rightIdx--\n            }\n        }\n        swap(pivotIdx, rightIdx, array)\n        if (rightIdx === position) {\n            return array[rightIdx]\n        } else if (rightIdx < position) {\n            newStartIdx = rightIdx + 1\n        } else {\n            newEndIdx = rightIdx - 1\n        }\n    }\n}\n\nfun swap(i: Int, j: Int, array: MutableList<Int>) {\n    val temp = array[j]\n    array[j] = array[i]\n    array[i] = temp\n}\n',
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.quickselect as quickselect\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(quickselect(mutableListOf(8, 5, 2, 9, 5, 6, 3), 3) == 5)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.quickselect as quickselect\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        assert(quickselect(mutableListOf(8, 5, 2, 9, 5, 6, 3), 3) == 5)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def quickselect(array, k):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# Best: O(n) time | O(1) space\n# Average: O(n) time | O(1) space\n# Worst: O(n^2) time | O(1) space\ndef quickselect(array, k):\n    position = k - 1\n    return quickselectHelper(array, 0, len(array) - 1, position)\n\n\ndef quickselectHelper(array, startIdx, endIdx, position):\n    while True:\n        if startIdx > endIdx:\n            raise Exception("Your algorithm should never arrive here!")\n        pivotIdx = startIdx\n        leftIdx = startIdx + 1\n        rightIdx = endIdx\n        while leftIdx <= rightIdx:\n            if array[leftIdx] > array[pivotIdx] and array[rightIdx] < array[pivotIdx]:\n                swap(leftIdx, rightIdx, array)\n            if array[leftIdx] <= array[pivotIdx]:\n                leftIdx += 1\n            if array[rightIdx] >= array[pivotIdx]:\n                rightIdx -= 1\n        swap(pivotIdx, rightIdx, array)\n        if rightIdx == position:\n            return array[rightIdx]\n        elif rightIdx < position:\n            startIdx = rightIdx + 1\n        else:\n            endIdx = rightIdx - 1\n\n\ndef swap(one, two, array):\n    array[one], array[two] = array[two], array[one]\n',
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3), 5)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3), 5)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def quickselect(array, k)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def quickselect(array, k)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.quickselect\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.quickselect\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func quickSelect(_ array: [Int], _ k: Int) -> Int? {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Best: O(n) time | O(1) space\n  // Average: O(n) time | O(1) space\n  // Worst: O(n^2) time | O(1) space\n  func quickSelect(_ array: [Int], _ k: Int) -> Int? {\n    let position = k - 1\n    var startIndex = 0\n    var endIndex = array.count - 1\n    var variableArray = array\n\n    return quickSelectHelper(&variableArray, &startIndex, &endIndex, position)\n  }\n\n  func quickSelectHelper(_ array: inout [Int], _ startIndex: inout Int, _ endIndex: inout Int, _ position: Int) -> Int {\n    while true {\n      let pivotIndex = startIndex\n      var leftPointer = startIndex + 1\n      var rightPointer = endIndex\n\n      while leftPointer <= rightPointer {\n        if array[leftPointer] > array[pivotIndex], array[rightPointer] < array[pivotIndex] {\n          swap(&array, leftPointer, rightPointer)\n        }\n\n        if array[leftPointer] <= array[pivotIndex] {\n          leftPointer += 1\n        }\n\n        if array[rightPointer] >= array[pivotIndex] {\n          rightPointer -= 1\n        }\n      }\n\n      swap(&array, pivotIndex, rightPointer)\n\n      if rightPointer == position {\n        return array[rightPointer]\n      } else if rightPointer < position {\n        startIndex = rightPointer + 1\n      } else {\n        endIndex = rightPointer - 1\n      }\n    }\n  }\n\n  func swap(_ array: inout [Int], _ leftPointer: Int, _ rightPointer: Int) {\n    let temp = array[leftPointer]\n\n    array[leftPointer] = array[rightPointer]\n    array[rightPointer] = temp\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(5, program.quickSelect([8, 5, 2, 9, 7, 6, 3], 3))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(5, program.quickSelect([8, 5, 2, 9, 7, 6, 3], 3))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function quickselect(array: number[], k: number) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nexport function quickselect(array: number[], k: number) {\n  const position = k - 1;\n  return quickselectHelper(array, 0, array.length - 1, position);\n}\n\nfunction quickselectHelper(array: number[], startIdx: number, endIdx: number, position: number) {\n  while (true) {\n    if (startIdx > endIdx) {\n      throw new Error('Your algorithm should never arrive here!');\n    }\n    const pivotIdx = startIdx;\n    let leftIdx = startIdx + 1;\n    let rightIdx = endIdx;\n    while (leftIdx <= rightIdx) {\n      if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n        swap(leftIdx, rightIdx, array);\n      }\n      if (array[leftIdx] <= array[pivotIdx]) {\n        leftIdx++;\n      }\n      if (array[rightIdx] >= array[pivotIdx]) {\n        rightIdx--;\n      }\n    }\n    swap(pivotIdx, rightIdx, array);\n    if (rightIdx === position) {\n      return array[rightIdx];\n    } else if (rightIdx < position) {\n      startIdx = rightIdx + 1;\n    } else {\n      endIdx = rightIdx - 1;\n    }\n  }\n}\n\nfunction swap(i: number, j: number, array: number[]) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [8, 5, 2, 9, 7, 6, 3],
          schema: {
            items: {
              type: "integer",
            },
            type: "array",
            uniqueItems: true,
          },
        },
        {
          name: "k",
          example: 3,
          schema: {
            minimum: 1,
            type: "integer",
          },
        },
      ],
      tests: [
        {
          array: [8, 5, 2, 9, 7, 6, 3],
          k: 3,
        },
        {
          array: [1],
          k: 1,
        },
        {
          array: [43, 24, 37],
          k: 1,
        },
        {
          array: [43, 24, 37],
          k: 2,
        },
        {
          array: [43, 24, 37],
          k: 3,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 1,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 2,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 3,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 4,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 5,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 6,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 7,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 8,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 5,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 4,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 9,
        },
        {
          array: [
            1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
          ],
          k: 12,
        },
        {
          array: [
            1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
          ],
          k: 4,
        },
      ],
      jsonTests: [
        {
          array: [8, 5, 2, 9, 7, 6, 3],
          k: 3,
        },
        {
          array: [1],
          k: 1,
        },
        {
          array: [43, 24, 37],
          k: 1,
        },
        {
          array: [43, 24, 37],
          k: 2,
        },
        {
          array: [43, 24, 37],
          k: 3,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 1,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 2,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 3,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 4,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 5,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 6,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 7,
        },
        {
          array: [8, 3, 2, 5, 1, 7, 4, 6],
          k: 8,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 5,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 4,
        },
        {
          array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
          k: 9,
        },
        {
          array: [
            1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
          ],
          k: 12,
        },
        {
          array: [
            1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
          ],
          k: 4,
        },
      ],
      changelog: [],
      id: 33,
    },
    {
      uid: "array-of-products",
      testStrategy: "JSON",
      name: "Array Of Products",
      version: 0,
      releaseDate: "2020-11-16T00:00:00Z",
      category: "Arrays",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 29884,
        failureCount: 12723,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "557765813",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1540,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of integers and returns an\n  array of the same length, where each element in the output array is equal to\n  the product of every other number in the input array.\n</p>\n<p>\n  In other words, the value at <span>output[i]</span> is equal to the product of\n  every number in the input array other than <span>input[i]</span>.\n</p>\n<p>Note that you\'re expected to solve this problem without using division.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [5, 1, 4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[8, 40, 10, 20]\n<span class="CodeEditor-promptComment">// 8 is equal to 1 x 4 x 2</span>\n<span class="CodeEditor-promptComment">// 40 is equal to 5 x 4 x 2</span>\n<span class="CodeEditor-promptComment">// 10 is equal to 5 x 1 x 2</span>\n<span class="CodeEditor-promptComment">// 20 is equal to 5 x 1 x 4</span>\n</pre>\n</div>',
      hints: [
        "<p>\nThink about the most naive approach to solving this problem. How can we do exactly what the problem wants us to do without focusing at all on time and space complexity?\n</p>\n",
        "\n<p>\nUnderstand how output[i] is being calculated. How can we calculate the product of every element other than the one at the current index? Can we do this with just one loop through the input array, or do we have to do multiple loops?\n</p>\n",
        "\n<p>\nFor each index in the input array, try calculating the product of every element to the left and the product of every element to the right. You can do this with two loops through the array: one from left to right and one from right to left. How can these products help us?\n</p>",
      ],
      spaceTime:
        "O(n) time | O(n) space - where n is the length of the input array",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\n\nusing namespace std;\n\nvector<int> arrayOfProducts(vector<int> array) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n\nusing namespace std;\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nvector<int> arrayOfProducts(vector<int> array) {\n  vector<int> products(array.size());\n\n  for (int i = 0; i < array.size(); i++) {\n    int runningProduct = 1;\n    for (int j = 0; j < array.size(); j++) {\n      if (i != j) {\n        runningProduct *= array[j];\n      }\n    }\n    products[i] = runningProduct;\n  }\n  return products;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nvector<int> arrayOfProducts(vector<int> array) {\n  vector<int> products(array.size(), 1);\n  vector<int> leftProducts(array.size(), 1);\n  vector<int> rightProducts(array.size(), 1);\n\n  int leftRunningProduct = 1;\n  for (int i = 0; i < array.size(); i++) {\n    leftProducts[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  int rightRunningProduct = 1;\n  for (int i = array.size() - 1; i >= 0; i--) {\n    rightProducts[i] = rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  for (int i = 0; i < array.size(); i++) {\n    products[i] = leftProducts[i] * rightProducts[i];\n  }\n\n  return products;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n\nusing namespace std;\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nvector<int> arrayOfProducts(vector<int> array) {\n  vector<int> products(array.size(), 1);\n\n  int leftRunningProduct = 1;\n  for (int i = 0; i < array.size(); i++) {\n    products[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  int rightRunningProduct = 1;\n  for (int i = array.size() - 1; i >= 0; i--) {\n    products[i] *= rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  return products;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {5, 1, 4, 2};\n      vector<int> expected = {8, 40, 10, 20};\n      vector<int> actual = arrayOfProducts(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> input = {5, 1, 4, 2};\n      vector<int> expected = {8, 40, 10, 20};\n      vector<int> actual = arrayOfProducts(input);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\tpublic int[] ArrayOfProducts(int[] array) {\n\t\t// Write your code here.\n\t\treturn new int[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\t// O(n^2) time | O(n) space - where n is the length of the input array\n\tpublic int[] ArrayOfProducts(int[] array) {\n\t\tint[] products = new int[array.Length];\n\n\t\tfor (int i=0; i<array.Length; i++) {\n\t\t\tint runningProduct = 1;\n\t\t\tfor (int j=0; j<array.Length; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trunningProduct *= array[j];\n\t\t\t\t}\n\t\t\t\tproducts[i] = runningProduct;\n\t\t\t}\n\t\t}\n\n\t\treturn products;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\t// O(n) time | O(n) space - where n is the length of the input array\n\tpublic int[] ArrayOfProducts(int[] array) {\n\t\tint[] products = new int[array.Length];\n\t\tint[] leftProducts = new int[array.Length];\n\t\tint[] rightProducts = new int[array.Length];\n\n\t\tint leftRunningProduct = 1;\n\t\tfor (int i=0; i<array.Length; i++) {\n\t\t\tleftProducts[i] = leftRunningProduct;\n\t\t\tleftRunningProduct *= array[i];\n\t\t}\n\n\t\tint rightRunningProduct = 1;\n\t\tfor (int i=array.Length-1; i>=0; i--) {\n\t\t\trightProducts[i] = rightRunningProduct;\n\t\t\trightRunningProduct *= array[i];\n\t\t}\n\n\t\tfor (int i=0; i<array.Length; i++) {\n\t\t\tproducts[i] = leftProducts[i] * rightProducts[i];\n\t\t}\n\n\t\treturn products;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\t// O(n) time | O(n) space - where n is the length of the input array\n\tpublic int[] ArrayOfProducts(int[] array) {\n\t\tint[] products = new int[array.Length];\n\n\t\tint leftRunningProduct = 1;\n\t\tfor (int i=0; i<array.Length; i++) {\n\t\t\tproducts[i] = leftRunningProduct;\n\t\t\tleftRunningProduct *= array[i];\n\t\t}\n\n\t\tint rightRunningProduct = 1;\n\t\tfor (int i=array.Length-1; i>=0; i--) {\n\t\t\tproducts[i] *= rightRunningProduct;\n\t\t\trightRunningProduct *= array[i];\n\t\t}\n\n\t\treturn products;\n\t}\n}",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar input = new int[] {5, 1, 4, 2};\n\t\tvar expected = new int[] {8, 40, 10, 20};\n\t\tint[] actual = new Program().ArrayOfProducts(input);\n\t\tUtils.AssertTrue(expected.Length == actual.Length);\n\t\tfor (int i=0; i<actual.Length; i++) {\n\t\t\tUtils.AssertTrue(actual[i] == expected[i]);\n\t\t}\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar input = new int[] {5, 1, 4, 2};\n\t\tvar expected = new int[] {8, 40, 10, 20};\n\t\tint[] actual = new Program().ArrayOfProducts(input);\n\t\tUtils.AssertTrue(expected.Length == actual.Length);\n\t\tfor (int i=0; i<actual.Length; i++) {\n\t\t\tUtils.AssertTrue(actual[i] == expected[i]);\n\t\t}\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc ArrayOfProducts(array []int) []int {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space - where n is the number of elements in the input array\nfunc ArrayOfProducts(array []int) []int {\n\tproducts := make([]int, len(array))\n\n\tfor i := range array {\n\t\trunningProduct := 1\n\t\tfor j := range array {\n\t\t\tif i != j {\n\t\t\t\trunningProduct *= array[j]\n\t\t\t}\n\t\t}\n\t\tproducts[i] = runningProduct\n\t}\n\treturn products\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nfunc ArrayOfProducts(array []int) []int {\n\tproducts := make([]int, len(array))\n\tleftProducts := make([]int, len(array))\n\trightProducts := make([]int, len(array))\n\tfor i := range array {\n\t\tproducts[i] = 1\n\t\tleftProducts[i] = 1\n\t\trightProducts[i] = 1\n\t}\n\n\tleftRunningProduct := 1\n\tfor i := range array {\n\t\tleftProducts[i] = leftRunningProduct\n\t\tleftRunningProduct *= array[i]\n\t}\n\n\trightRunningProduct := 1\n\tfor i := len(array) - 1; i >= 0; i-- {\n\t\trightProducts[i] = rightRunningProduct\n\t\trightRunningProduct *= array[i]\n\t}\n\n\tfor i := range array {\n\t\tproducts[i] = leftProducts[i] * rightProducts[i]\n\t}\n\treturn products\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nfunc ArrayOfProducts(array []int) []int {\n\tproducts := make([]int, len(array))\n\tfor i := range array {\n\t\tproducts[i] = 1\n\t}\n\n\tleftRunningProduct := 1\n\tfor i := range array {\n\t\tproducts[i] = leftRunningProduct\n\t\tleftRunningProduct *= array[i]\n\t}\n\n\trightRunningProduct := 1\n\tfor i := len(array) - 1; i >= 0; i-- {\n\t\tproducts[i] *= rightRunningProduct\n\t\trightRunningProduct *= array[i]\n\t}\n\treturn products\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{5, 1, 4, 2}\n\texpected := []int{8, 40, 10, 20}\n\tactual := ArrayOfProducts(input)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []int{5, 1, 4, 2}\n\texpected := []int{8, 40, 10, 20}\n\tactual := ArrayOfProducts(input)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public int[] arrayOfProducts(int[] array) {\n    // Write your code here.\n    return new int[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the length of the input array\n  public int[] arrayOfProducts(int[] array) {\n    int[] products = new int[array.length];\n\n    for (int i = 0; i < array.length; i++) {\n      int runningProduct = 1;\n      for (int j = 0; j < array.length; j++) {\n        if (i != j) {\n          runningProduct *= array[j];\n        }\n        products[i] = runningProduct;\n      }\n    }\n\n    return products;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input array\n  public int[] arrayOfProducts(int[] array) {\n    int[] products = new int[array.length];\n    int[] leftProducts = new int[array.length];\n    int[] rightProducts = new int[array.length];\n\n    int leftRunningProduct = 1;\n    for (int i = 0; i < array.length; i++) {\n      leftProducts[i] = leftRunningProduct;\n      leftRunningProduct *= array[i];\n    }\n\n    int rightRunningProduct = 1;\n    for (int i = array.length - 1; i >= 0; i--) {\n      rightProducts[i] = rightRunningProduct;\n      rightRunningProduct *= array[i];\n    }\n\n    for (int i = 0; i < array.length; i++) {\n      products[i] = leftProducts[i] * rightProducts[i];\n    }\n\n    return products;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n) time | O(n) space - where n is the length of the input array\n  public int[] arrayOfProducts(int[] array) {\n    int[] products = new int[array.length];\n\n    int leftRunningProduct = 1;\n    for (int i = 0; i < array.length; i++) {\n      products[i] = leftRunningProduct;\n      leftRunningProduct *= array[i];\n    }\n\n    int rightRunningProduct = 1;\n    for (int i = array.length - 1; i >= 0; i--) {\n      products[i] *= rightRunningProduct;\n      rightRunningProduct *= array[i];\n    }\n\n    return products;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[] {5, 1, 4, 2};\n    var expected = new int[] {8, 40, 10, 20};\n    int[] actual = new Program().arrayOfProducts(input);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < actual.length; i++) {\n      Utils.assertTrue(actual[i] == expected[i]);\n    }\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    var input = new int[] {5, 1, 4, 2};\n    var expected = new int[] {8, 40, 10, 20};\n    int[] actual = new Program().arrayOfProducts(input);\n    Utils.assertTrue(expected.length == actual.length);\n    for (int i = 0; i < actual.length; i++) {\n      Utils.assertTrue(actual[i] == expected[i]);\n    }\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function arrayOfProducts(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.arrayOfProducts = arrayOfProducts;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = [];\n\n  for (let i = 0; i < array.length; i++) {\n    let runningProduct = 1;\n    for (let j = 0; j < array.length; j++) {\n      if (i !== j) {\n        runningProduct *= array[j];\n      }\n      products[i] = runningProduct;\n    }\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = new Array(array.length).fill(1);\n  const leftProducts = new Array(array.length).fill(1);\n  const rightProducts = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    leftProducts[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    rightProducts[i] = rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftProducts[i] * rightProducts[i];\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    products[i] *= rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun arrayOfProducts(array: List<Int>): List<Int> {\n    // Write your code here.\n    return array\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space - where n is the number of elements in the input array\nfun arrayOfProducts(array: List<Int>): List<Int> {\n    val products = MutableList(array.size) { 1 }\n\n    for (i in 0 until array.size) {\n        var runningProduct = 1\n        for (j in 0 until array.size) {\n            if (i != j) runningProduct *= array[j]\n        }\n        products[i] = runningProduct\n    }\n\n    return products\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nfun arrayOfProducts(array: List<Int>): List<Int> {\n    val products = MutableList(array.size) { 1 }\n    val leftProducts = MutableList(array.size) { 1 }\n    val rightProducts = MutableList(array.size) { 1 }\n\n    var leftRunningProduct = 1\n    for (i in 0 until array.size) {\n        leftProducts[i] = leftRunningProduct\n        leftRunningProduct *= array[i]\n    }\n\n    var rightRunningProduct = 1\n    for (i in array.size - 1 downTo 0) {\n        rightProducts[i] = rightRunningProduct\n        rightRunningProduct *= array[i]\n    }\n\n    for (i in 0 until array.size) {\n        products[i] = leftProducts[i] * rightProducts[i]\n    }\n\n    return products\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n) time | O(n) space - where n is the number of elements in the input array\nfun arrayOfProducts(array: List<Int>): List<Int> {\n    val products = MutableList(array.size) { 1 }\n\n    var leftRunningProduct = 1\n    for (i in 0 until array.size) {\n        products[i] = leftRunningProduct\n        leftRunningProduct *= array[i]\n    }\n\n    var rightRunningProduct = 1\n    for (i in array.size - 1 downTo 0) {\n        products[i] *= rightRunningProduct\n        rightRunningProduct *= array[i]\n    }\n\n    return products\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.arrayOfProducts\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(5, 1, 4, 2)\n        val expected = listOf(8, 40, 10, 20)\n        val output = arrayOfProducts(input)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.arrayOfProducts\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(5, 1, 4, 2)\n        val expected = listOf(8, 40, 10, 20)\n        val output = arrayOfProducts(input)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def arrayOfProducts(array):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space - where n is the length of the input array\ndef arrayOfProducts(array):\n    products = [1 for _ in range(len(array))]\n\n    for i in range(len(array)):\n        runningProduct = 1\n        for j in range(len(array)):\n            if i != j:\n                runningProduct *= array[j]\n        products[i] = runningProduct\n\n    return products\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the input array\ndef arrayOfProducts(array):\n    products = [1 for _ in range(len(array))]\n    leftProducts = [1 for _ in range(len(array))]\n    rightProducts = [1 for _ in range(len(array))]\n\n    leftRunningProduct = 1\n    for i in range(len(array)):\n        leftProducts[i] = leftRunningProduct\n        leftRunningProduct *= array[i]\n\n    rightRunningProduct = 1\n    for i in reversed(range(len(array))):\n        rightProducts[i] = rightRunningProduct\n        rightRunningProduct *= array[i]\n\n    for i in range(len(array)):\n        products[i] = leftProducts[i] * rightProducts[i]\n\n    return products\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n) time | O(n) space - where n is the length of the input array\ndef arrayOfProducts(array):\n    products = [1 for _ in range(len(array))]\n\n    leftRunningProduct = 1\n    for i in range(len(array)):\n        products[i] = leftRunningProduct\n        leftRunningProduct *= array[i]\n\n    rightRunningProduct = 1\n    for i in reversed(range(len(array))):\n        products[i] *= rightRunningProduct\n        rightRunningProduct *= array[i]\n\n    return products\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [5, 1, 4, 2]\n        expected = [8, 40, 10, 20]\n        actual = program.arrayOfProducts(array)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        array = [5, 1, 4, 2]\n        expected = [8, 40, 10, 20]\n        actual = program.arrayOfProducts(array)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def arrayOfProducts(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def arrayOfProducts(array)\n    # Write your code here.\n    return []\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def arrayOfProducts(array)\n    # Write your code here.\n    return []\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def arrayOfProducts(array)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.arrayOfProducts\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.arrayOfProducts\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func arrayOfProducts(_ array: [Int]) -> [Int] {\n    // Write your code here.\n    return [Int]()\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(n) space - where n is the number of elements in the input array\n  func arrayOfProducts(_ array: [Int]) -> [Int] {\n    var products = [Int](repeating: 0, count: array.count)\n\n    for i in 0 ..< array.count {\n      var runningProduct = 1\n      for j in 0 ..< array.count {\n        if i != j {\n          runningProduct *= array[j]\n        }\n      }\n      products[i] = runningProduct\n    }\n    return products\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the number of elements in the input array\n  func arrayOfProducts(_ array: [Int]) -> [Int] {\n    var products = [Int](repeating: 1, count: array.count)\n    var leftProducts = [Int](repeating: 1, count: array.count)\n    var rightProducts = [Int](repeating: 1, count: array.count)\n\n    var leftRunningProduct = 1\n    for i in 0 ..< array.count {\n      leftProducts[i] = leftRunningProduct\n      leftRunningProduct *= array[i]\n    }\n\n    var rightRunningProduct = 1\n    for i in stride(from: array.count - 1, through: 0, by: -1) {\n      rightProducts[i] = rightRunningProduct\n      rightRunningProduct *= array[i]\n    }\n\n    for i in 0 ..< array.count {\n      products[i] = leftProducts[i] * rightProducts[i]\n    }\n    return products\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n) time | O(n) space - where n is the number of elements in the input array\n  func arrayOfProducts(_ array: [Int]) -> [Int] {\n    var products = [Int](repeating: 1, count: array.count)\n\n    var leftRunningProduct = 1\n    for i in 0 ..< array.count {\n      products[i] = leftRunningProduct\n      leftRunningProduct *= array[i]\n    }\n\n    var rightRunningProduct = 1\n    for i in stride(from: array.count - 1, through: 0, by: -1) {\n      products[i] *= rightRunningProduct\n      rightRunningProduct *= array[i]\n    }\n    return products\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [5, 1, 4, 2]\n      var expected = [8, 40, 10, 20]\n      var actual = Program().arrayOfProducts(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = [5, 1, 4, 2]\n      var expected = [8, 40, 10, 20]\n      var actual = Program().arrayOfProducts(input)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function arrayOfProducts(array: number[]) {\n  // Write your code here.\n  return array;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nexport function arrayOfProducts(array: number[]) {\n  const products: number[] = [];\n\n  for (let i = 0; i < array.length; i++) {\n    let runningProduct = 1;\n    for (let j = 0; j < array.length; j++) {\n      if (i !== j) {\n        runningProduct *= array[j];\n      }\n      products[i] = runningProduct;\n    }\n  }\n\n  return products;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nexport function arrayOfProducts(array: number[]) {\n  const products: number[] = new Array(array.length).fill(1);\n  const leftProducts: number[] = new Array(array.length).fill(1);\n  const rightProducts: number[] = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    leftProducts[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    rightProducts[i] = rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftProducts[i] * rightProducts[i];\n  }\n\n  return products;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n) time | O(n) space - where n is the length of the input array\nexport function arrayOfProducts(array: number[]) {\n  const products: number[] = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    products[i] *= rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  return products;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "array",
          example: [5, 1, 4, 2],
          schema: {
            items: {
              type: "integer",
            },
            minItems: 1,
            type: "array",
          },
        },
      ],
      tests: [
        {
          array: [5, 1, 4, 2],
        },
        {
          array: [1, 8, 6, 2, 4],
        },
        {
          array: [-5, 2, -4, 14, -6],
        },
        {
          array: [9, 3, 2, 1, 9, 5, 3, 2],
        },
        {
          array: [4, 4],
        },
        {
          array: [0, 0, 0, 0],
        },
        {
          array: [1, 1, 1, 1],
        },
        {
          array: [-1, -1, -1],
        },
        {
          array: [-1, -1, -1, -1],
        },
        {
          array: [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        },
        {
          array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        },
      ],
      jsonTests: [
        {
          array: [5, 1, 4, 2],
        },
        {
          array: [1, 8, 6, 2, 4],
        },
        {
          array: [-5, 2, -4, 14, -6],
        },
        {
          array: [9, 3, 2, 1, 9, 5, 3, 2],
        },
        {
          array: [4, 4],
        },
        {
          array: [0, 0, 0, 0],
        },
        {
          array: [1, 1, 1, 1],
        },
        {
          array: [-1, -1, -1],
        },
        {
          array: [-1, -1, -1, -1],
        },
        {
          array: [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        },
        {
          array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        },
      ],
      changelog: [],
      id: 34,
    },
    {
      uid: "longest-string-chain",
      testStrategy: "JSON",
      name: "Longest String Chain",
      version: 0,
      releaseDate: "2019-11-21T00:00:00Z",
      category: "Dynamic Programming",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 3102,
        failureCount: 1115,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "374201798",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 1655,
      },
      prompt:
        '<div class="html">\n<p>\n  Given a list of strings, write a function that returns the longest string\n  chain that can be built from those strings.\n</p>\n<p>\n  A string chain is defined as follows: let string <span>A</span> be a string in\n  the initial array; if removing any single character from string\n  <span>A</span> yields a new string <span>B</span> that\'s contained in the\n  initial array of strings, then strings <span>A</span> and <span>B</span> form\n  a string chain of length 2. Similarly, if removing any single character from\n  string <span>B</span> yields a new string <span>C</span> that\'s contained in\n  the initial array of strings, then strings <span>A</span>, <span>B</span>, and\n  <span>C</span> form a string chain of length 3.\n</p>\n<p>\n  The function should return the string chain in descending order (i.e., from\n  the longest string to the shortest one). Note that string chains of length 1\n  don\'t exist; if the list of strings doesn\'t contain any string chain formed by\n  two or more strings, the function should return an empty array.\n</p>\n<p>\n  You can assume that there will only be one longest string chain.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">strings</span> = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["abcdef", "abcde", "abde", "ade", "ae"]\n</pre>\n</div>',
      hints: [
        "<p>\nFor each string, you will have to remove every letter one at a time to see if the resulting strings are contained in the input list of strings. What data structure lends itself to quickly checking if these strings are located in the list of input strings?\n</p>\n",
        "\n<p>\nRealize that every string in the input list of strings potentially has a string chain (and therefore a longest string chain) that starts with itself. Compute all of these string chains and store them so that you don't have to compute them more than once.\n</p>\n",
        "\n<p>\nSort the input list of strings (from shortest to longest string) in order to simplify the problem. Iterate through the list of sorted strings, and for each string, compute the longest string chain that starts with itself. To do so, try removing every letter from each string and seeing if the resulting strings are in the input list of strings; you can do so in constant time by dumping every string in a hash table. In the hash table, store the longest string chain of every string as you compute them. As you iterate through longer strings, whenever you find a shorter string for which you've already computed the longest string chain, you can very quickly append the longer string to that already-computed string chain. Do this for every string, and you'll eventually find the longest string chain that you're looking for.\n</p>\n",
        "\n<p>\nDo you need to store every string's longest string chain mentioned in Hint #3, or can you store less information per string so as to take up less auxiliary space?\n</p>",
      ],
      spaceTime:
        "O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and m is the length of the longest string",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\n\nusing namespace std;\n\nvector<string> longestStringChain(vector<string> strings) {\n  // Write your code here.\n  return {};\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct stringChain {\n  string nextString;\n  int maxChainLength;\n};\n\nvoid findLongestStringChain(string str,\n                            unordered_map<string, stringChain> &stringChains);\nstring getSmallerString(string str, int index);\nvoid tryUpdateLongestStringChain(\n    string currentString, string smallerString,\n    unordered_map<string, stringChain> &stringChains);\nvector<string>\nbuildLongestStringChain(vector<string> strings,\n                        unordered_map<string, stringChain> stringChains);\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n// and m is the length of the longest string\nvector<string> longestStringChain(vector<string> strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string\n  // chains.\n  unordered_map<string, stringChain> stringChains = {};\n  for (auto string : strings) {\n    stringChains[string] = {"", 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  vector<string> sortedStrings = strings;\n  sort(sortedStrings.begin(), sortedStrings.end(),\n       [](string a, string b) -> bool { return a.size() < b.size(); });\n\n  for (auto string : sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nvoid findLongestStringChain(string str,\n                            unordered_map<string, stringChain> &stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (int i = 0; i < str.size(); i++) {\n    string smallerString = getSmallerString(str, i);\n    if (stringChains.find(smallerString) == stringChains.end())\n      continue;\n    tryUpdateLongestStringChain(str, smallerString, stringChains);\n  }\n}\n\nstring getSmallerString(string str, int index) {\n  return str.substr(0, index) + str.substr(index + 1);\n}\n\nvoid tryUpdateLongestStringChain(\n    string currentString, string smallerString,\n    unordered_map<string, stringChain> &stringChains) {\n  int smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  int currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string\n  // leads to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nvector<string>\nbuildLongestStringChain(vector<string> strings,\n                        unordered_map<string, stringChain> stringChains) {\n  // Find the string that starts the longest string chain.\n  int maxChainLength = 0;\n  string chainStartingString = "";\n  for (auto string : strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  vector<string> ourLongestStringChain;\n  string currentString = chainStartingString;\n  while (currentString != "") {\n    ourLongestStringChain.push_back(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.size() == 1 ? vector<string>{}\n                                           : ourLongestStringChain;\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<string> strings = {"abde", "abc", "abd",   "abcde",\n                                "ade",  "ae",  "1abde", "abcdef"};\n      vector<string> expected = {"abcdef", "abcde", "abde", "ade", "ae"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<string> strings = {"abde", "abc", "abd",   "abcde",\n                                "ade",  "ae",  "1abde", "abcdef"};\n      vector<string> expected = {"abcdef", "abcde", "abde", "ade", "ae"};\n      assert(longestStringChain(strings) == expected);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic static List<string> LongestStringChain(List<string> strings) {\n\t\t// Write your code here.\n\t\treturn new List<string>();\n\t}\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\n\tpublic class stringChain {\n\t\tpublic string nextstring;\n\t\tpublic int maxChainLength;\n\n\t\tpublic stringChain(string nextstring, int maxChainLength) {\n\t\t\tthis.nextstring = nextstring;\n\t\t\tthis.maxChainLength = maxChainLength;\n\t\t}\n\t}\n\n\t// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n\t// and m is the length of the longest string\n\tpublic static List<string> LongestStringChain(List<string> strings) {\n\t\t// For every string, imagine the longest string chain that starts with it.\n\t\t// Set up every string to point to the next string in its respective longest\n\t\t// string chain. Also keep track of the lengths of these longest string\n\t\t// chains.\n\t\tDictionary<string,\n\t\t  stringChain> stringChains = new Dictionary<string, stringChain>();\n\t\tforeach (string str in strings) {\n\t\t\tstringChains[str] = new stringChain("", 1);\n\t\t}\n\n\t\t// Sort the strings based on their length so that whenever we visit a\n\t\t// string (as we iterate through them from left to right), we can\n\t\t// already have computed the longest string chains of any smaller strings.\n\t\tList<string> sortedstrings = new List<string>(strings);\n\t\tsortedstrings.Sort((a, b) => a.Length - b.Length);\n\n\t\tforeach (string str in sortedstrings) {\n\t\t\tfindLongeststringChain(str, stringChains);\n\t\t}\n\n\t\treturn buildLongeststringChain(strings, stringChains);\n\t}\n\n\tpublic static void findLongeststringChain(string str, Dictionary<string,\n\t  stringChain> stringChains) {\n\t\t// Try removing every letter of the current string to see if the\n\t\t// remaining strings form a string chain.\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tstring smallerstring = getSmallerstring(str, i);\n\t\t\tif (!stringChains.ContainsKey(smallerstring)) continue;\n\t\t\ttryUpdateLongeststringChain(str, smallerstring, stringChains);\n\t\t}\n\t}\n\n\tpublic static string getSmallerstring(string str, int index) {\n\t\treturn str.Substring(0, index) + str.Substring(index + 1);\n\t}\n\n\tpublic static void tryUpdateLongeststringChain(\n\t\tstring currentstring,\n\t\tstring smallerstring,\n\t\tDictionary<string, stringChain> stringChains\n\t\t) {\n\t\tint smallerstringChainLength = stringChains[smallerstring].maxChainLength;\n\t\tint currentstringChainLength = stringChains[currentstring].maxChainLength;\n\t\t// Update the string chain of the current string only if the smaller string\n\t\t// leads to a longer string chain.\n\t\tif (smallerstringChainLength + 1 > currentstringChainLength) {\n\t\t\tstringChains[currentstring].maxChainLength = smallerstringChainLength + 1;\n\t\t\tstringChains[currentstring].nextstring = smallerstring;\n\t\t}\n\t}\n\n\tpublic static List<string> buildLongeststringChain(List<string> strings, Dictionary<string,\n\t  stringChain> stringChains) {\n\t\t// Find the string that starts the longest string chain.\n\t\tint maxChainLength = 0;\n\t\tstring chainStartingstring = "";\n\t\tforeach (string str in strings) {\n\t\t\tif (stringChains[str].maxChainLength > maxChainLength) {\n\t\t\t\tmaxChainLength = stringChains[str].maxChainLength;\n\t\t\t\tchainStartingstring = str;\n\t\t\t}\n\t\t}\n\n\t\t// Starting at the string found above, build the longest string chain.\n\t\tList<string> ourLongeststringChain = new List<string>();\n\t\tstring currentstring = chainStartingstring;\n\t\twhile (currentstring != "") {\n\t\t\tourLongeststringChain.Add(currentstring);\n\t\t\tcurrentstring = stringChains[currentstring].nextstring;\n\t\t}\n\n\t\treturn ourLongeststringChain.Count ==\n\t\t       1 ? new List<string>() : ourLongeststringChain;\n\t}\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<string> strings = new List<string>(new [] {"abde", "abc", "abd",     "abcde",\n\t\t                                                "ade",    "ae",    "1abde",\n\t\t                                                "abcdef"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t"abcdef", "abcde", "abde", "ade", "ae"\n\t\t};\n\t\tUtils.AssertTrue(Program.LongestStringChain(strings).SequenceEqual(expected));\n\t}\n}\n',
          unitTests:
            'using System.Linq;\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tList<string> strings = new List<string>(new [] {"abde", "abc", "abd",     "abcde",\n\t\t                                                "ade",    "ae",    "1abde",\n\t\t                                                "abcdef"});\n\t\tList<string> expected = new List<string>(){\n\t\t\t"abcdef", "abcde", "abde", "ade", "ae"\n\t\t};\n\t\tUtils.AssertTrue(Program.LongestStringChain(strings).SequenceEqual(expected));\n\t}\n}\n',
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc LongestStringChain(strings []string) []string {\n\t// Write your code here.\n\treturn nil\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"sort"\n)\n\ntype Chain struct {\n\tNextString     string\n\tMaxChainLength int\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunc LongestStringChain(strings []string) []string {\n\t// For every string, imagine the longest string chain that starts with it.\n\t// Set up every string to point to the next string in its respective longest\n\t// string chain. Also keep track of the lengths of these longest string chains.\n\tstringChains := map[string]*Chain{}\n\tfor _, str := range strings {\n\t\tstringChains[str] = &Chain{NextString: "", MaxChainLength: 1}\n\t}\n\n\t// Sort the strings based on their length so that whenever we visit a\n\t// string (as we iterate through them from left to right), we can\n\t// already have computed the longest string chains of any smaller strings.\n\tsort.Slice(strings, func(i, j int) bool {\n\t\treturn len(strings[i]) < len(strings[j])\n\t})\n\tsortedStrings := strings\n\n\tfor _, str := range sortedStrings {\n\t\tfindLongestStringChain(str, stringChains)\n\t}\n\treturn buildLongestStringChain(strings, stringChains)\n}\n\nfunc findLongestStringChain(str string, stringChains map[string]*Chain) {\n\t// Try removing every letter of the current string to see if the\n\t// remaining strings form a string chain.\n\tfor i := range str {\n\t\tsmallerString := getSmallerString(str, i)\n\t\tif _, found := stringChains[smallerString]; !found {\n\t\t\tcontinue\n\t\t}\n\t\ttryUpdateLongestStringChain(str, smallerString, stringChains)\n\t}\n}\n\nfunc getSmallerString(str string, index int) string {\n\treturn str[:index] + str[index+1:]\n}\n\nfunc tryUpdateLongestStringChain(currentString, smallerString string, stringChains map[string]*Chain) {\n\tsmallerStringChainLength := stringChains[smallerString].MaxChainLength\n\tcurrentStringChainLength := stringChains[currentString].MaxChainLength\n\t// Update the string chain of the current string only if the smaller string leads\n\t// to a longer string chain.\n\tif smallerStringChainLength+1 > currentStringChainLength {\n\t\tstringChains[currentString].MaxChainLength = smallerStringChainLength + 1\n\t\tstringChains[currentString].NextString = smallerString\n\t}\n}\n\nfunc buildLongestStringChain(strings []string, stringChains map[string]*Chain) []string {\n\t// Find the string that starts the longest string chain.\n\tmaxChainLength := 0\n\tchainStartingString := ""\n\tfor _, str := range strings {\n\t\tif stringChains[str].MaxChainLength > maxChainLength {\n\t\t\tmaxChainLength = stringChains[str].MaxChainLength\n\t\t\tchainStartingString = str\n\t\t}\n\t}\n\n\t// Starting at the string found above, build the longest string chain.\n\tourLongestStringChain := []string{}\n\tcurrentString := chainStartingString\n\tfor currentString != "" {\n\t\tourLongestStringChain = append(ourLongestStringChain, currentString)\n\t\tcurrentString = stringChains[currentString].NextString\n\t}\n\tif len(ourLongestStringChain) == 1 {\n\t\treturn []string{}\n\t}\n\treturn ourLongestStringChain\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{"abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"}\n\texpected := []string{"abcdef", "abcde", "abde", "ade", "ae"}\n\toutput := LongestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{"abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"}\n\texpected := []string{"abcdef", "abcde", "abde", "ade", "ae"}\n\toutput := LongestStringChain(input)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static List<String> longestStringChain(List<String> strings) {\n    // Write your code here.\n    return new ArrayList<String>();\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  public static class stringChain {\n    String nextString;\n    Integer maxChainLength;\n\n    public stringChain(String nextString, Integer maxChainLength) {\n      this.nextString = nextString;\n      this.maxChainLength = maxChainLength;\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n  // and m is the length of the longest string\n  public static List<String> longestStringChain(List<String> strings) {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    Map<String, stringChain> stringChains = new HashMap<String, stringChain>();\n    for (String string : strings) {\n      stringChains.put(string, new stringChain("", 1));\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    List<String> sortedStrings = new ArrayList<String>(strings);\n    sortedStrings.sort((a, b) -> a.length() - b.length());\n\n    for (String string : sortedStrings) {\n      findLongestStringChain(string, stringChains);\n    }\n\n    return buildLongestStringChain(strings, stringChains);\n  }\n\n  public static void findLongestStringChain(String string, Map<String, stringChain> stringChains) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (int i = 0; i < string.length(); i++) {\n      String smallerString = getSmallerString(string, i);\n      if (!stringChains.containsKey(smallerString)) continue;\n      tryUpdateLongestStringChain(string, smallerString, stringChains);\n    }\n  }\n\n  public static String getSmallerString(String string, int index) {\n    return string.substring(0, index) + string.substring(index + 1);\n  }\n\n  public static void tryUpdateLongestStringChain(\n      String currentString, String smallerString, Map<String, stringChain> stringChains) {\n    int smallerStringChainLength = stringChains.get(smallerString).maxChainLength;\n    int currentStringChainLength = stringChains.get(currentString).maxChainLength;\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerStringChainLength + 1 > currentStringChainLength) {\n      stringChains.get(currentString).maxChainLength = smallerStringChainLength + 1;\n      stringChains.get(currentString).nextString = smallerString;\n    }\n  }\n\n  public static List<String> buildLongestStringChain(\n      List<String> strings, Map<String, stringChain> stringChains) {\n    // Find the string that starts the longest string chain.\n    int maxChainLength = 0;\n    String chainStartingString = "";\n    for (String string : strings) {\n      if (stringChains.get(string).maxChainLength > maxChainLength) {\n        maxChainLength = stringChains.get(string).maxChainLength;\n        chainStartingString = string;\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    List<String> ourLongestStringChain = new ArrayList<String>();\n    String currentString = chainStartingString;\n    while (currentString != "") {\n      ourLongestStringChain.add(currentString);\n      currentString = stringChains.get(currentString).nextString;\n    }\n\n    return ourLongestStringChain.size() == 1 ? new ArrayList<String>() : ourLongestStringChain;\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList("abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"));\n    List<String> expected =\n        new ArrayList<String>(Arrays.asList("abcdef", "abcde", "abde", "ade", "ae"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n',
          unitTests:
            'import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    List<String> strings =\n        new ArrayList<String>(\n            Arrays.asList("abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"));\n    List<String> expected =\n        new ArrayList<String>(Arrays.asList("abcdef", "abcde", "abde", "ade", "ae"));\n    Utils.assertTrue(Program.longestStringChain(strings).equals(expected));\n  }\n}\n',
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function longestStringChain(strings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestStringChain = longestStringChain;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunction longestStringChain(strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string, stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string, index) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString, smallerString, stringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings, stringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n\nexports.longestStringChain = longestStringChain;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun longestStringChain(strings: List<String>): List<String> {\n    // Write your code here.\n    return listOf()\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\ndata class StringChain(var nextString: String, var maxChainLength: Int)\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings\n// and m is the length of the longest string\nfun longestStringChain(strings: List<String>): List<String> {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string\n    // chains.\n    val stringChains = mutableMapOf<String, StringChain>()\n    for (string in strings) {\n        stringChains[string] = StringChain("", 1)\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    val sortedStrings = strings.toMutableList().sortedWith(Comparator<String> { a, b -> a.length - b.length })\n\n    for (string in sortedStrings) {\n        findLongestStringChain(string, stringChains)\n    }\n\n    return buildLongestStringChain(strings, stringChains)\n}\n\nfun findLongestStringChain(string: String, stringChains: Map<String, StringChain>) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for (i in 0 until string.length) {\n        val smallerString = getSmallerString(string, i)\n        if (!stringChains.containsKey(smallerString)) continue\n        tryUpdateLongestStringChain(string, smallerString, stringChains)\n    }\n}\n\nfun getSmallerString(string: String, index: Int): String {\n    return string.substring(0, index) + string.substring(index + 1)\n}\n\nfun tryUpdateLongestStringChain(currentString: String, smallerString: String, stringChains: Map<String, StringChain>) {\n    val smallerStringChainLength = stringChains[smallerString]!!.maxChainLength\n    val currentStringChainLength = stringChains[currentString]!!.maxChainLength\n    // Update the string chain of the current string only if the smaller string\n    // leads to a longer string chain.\n    if (smallerStringChainLength + 1 > currentStringChainLength) {\n        stringChains[currentString]!!.maxChainLength = smallerStringChainLength + 1\n        stringChains[currentString]!!.nextString = smallerString\n    }\n}\n\nfun buildLongestStringChain(strings: List<String>, stringChains: Map<String, StringChain>): List<String> {\n    // Find the string that starts the longest string chain.\n    var maxChainLength = 0\n    var chainStartingString = ""\n    for (string in strings) {\n        if (stringChains[string]!!.maxChainLength > maxChainLength) {\n            maxChainLength = stringChains[string]!!.maxChainLength\n            chainStartingString = string\n        }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    val ourLongestStringChain = mutableListOf<String>()\n    var currentString = chainStartingString\n    while (currentString != "") {\n        ourLongestStringChain.add(currentString)\n        currentString = stringChains[currentString]!!.nextString\n    }\n\n    return if (ourLongestStringChain.size == 1) listOf() else ourLongestStringChain\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.longestStringChain\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val strings = listOf("abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef")\n        val expected = listOf("abcdef", "abcde", "abde", "ade", "ae")\n        assert(longestStringChain(strings).equals(expected))\n    }\n}\n',
          unitTests:
            'import com.algoexpert.program.longestStringChain\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val strings = listOf("abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef")\n        val expected = listOf("abcdef", "abcde", "abde", "ade", "ae")\n        assert(longestStringChain(strings).equals(expected))\n    }\n}\n',
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def longestStringChain(strings):\n    # Write your code here.\n    pass\n",
          solutions: [
            '# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n# m is the length of the longest string\ndef longestStringChain(strings):\n    # For every string, imagine the longest string chain that starts with it.\n    # Set up every string to point to the next string in its respective longest\n    # string chain. Also keep track of the lengths of these longest string chains.\n    stringChains = {}\n    for string in strings:\n        stringChains[string] = {"nextString": "", "maxChainLength": 1}\n\n    # Sort the strings based on their length so that whenever we visit a\n    # string (as we iterate through them from left to right), we can\n    # already have computed the longest string chains of any smaller strings.\n    sortedStrings = sorted(strings, key=len)\n    for string in sortedStrings:\n        findLongestStringChain(string, stringChains)\n\n    return buildLongestStringChain(strings, stringChains)\n\n\ndef findLongestStringChain(string, stringChains):\n    # Try removing every letter of the current string to see if the\n    # remaining strings form a string chain.\n    for i in range(len(string)):\n        smallerString = getSmallerString(string, i)\n        if smallerString not in stringChains:\n            continue\n        tryUpdateLongestStringChain(string, smallerString, stringChains)\n\n\ndef getSmallerString(string, index):\n    return string[0:index] + string[index + 1 :]\n\n\ndef tryUpdateLongestStringChain(currentString, smallerString, stringChains):\n    smallerStringChainLength = stringChains[smallerString]["maxChainLength"]\n    currentStringChainLength = stringChains[currentString]["maxChainLength"]\n    # Update the string chain of the current string only if the smaller string leads\n    # to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength:\n        stringChains[currentString]["maxChainLength"] = smallerStringChainLength + 1\n        stringChains[currentString]["nextString"] = smallerString\n\n\ndef buildLongestStringChain(strings, stringChains):\n    # Find the string that starts the longest string chain.\n    maxChainLength = 0\n    chainStartingString = ""\n    for string in strings:\n        if stringChains[string]["maxChainLength"] > maxChainLength:\n            maxChainLength = stringChains[string]["maxChainLength"]\n            chainStartingString = string\n\n    # Starting at the string found above, build the longest string chain.\n    ourLongestStringChain = []\n    currentString = chainStartingString\n    while currentString != "":\n        ourLongestStringChain.append(currentString)\n        currentString = stringChains[currentString]["nextString"]\n\n    return [] if len(ourLongestStringChain) == 1 else ourLongestStringChain\n',
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n        expected = ["abcdef", "abcde", "abde", "ade", "ae"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        strings = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n        expected = ["abcdef", "abcde", "abde", "ade", "ae"]\n        self.assertEqual(program.longestStringChain(strings), expected)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def longestStringChain(strings)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def longestStringChain(strings)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestStringChain\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.longestStringChain\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // Write your code here.\n    return []\n  }\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Chain {\n    var nextString: String\n    var maxChainLength: Int\n\n    init(_ nextString: String, _ maxChainLength: Int) {\n      self.nextString = nextString\n      self.maxChainLength = maxChainLength\n    }\n  }\n\n  // O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n  // m is the length of the longest string\n  func longestStringChain(_ strings: [String]) -> [String] {\n    // For every string, imagine the longest string chain that starts with it.\n    // Set up every string to point to the next string in its respective longest\n    // string chain. Also keep track of the lengths of these longest string chains.\n    var stringChains = [String: Chain]()\n    for str in strings {\n      stringChains[str] = Chain("", 1)\n    }\n\n    // Sort the strings based on their length so that whenever we visit a\n    // string (as we iterate through them from left to right), we can\n    // already have computed the longest string chains of any smaller strings.\n    let sortedStrings = strings.sorted {\n      $0.length < $1.length\n    }\n\n    for str in sortedStrings {\n      findLongestStringChain(str, &stringChains)\n    }\n    return buildLongestStringChain(strings, &stringChains)\n  }\n\n  func findLongestStringChain(_ string: String, _ stringChains: inout [String: Chain]) {\n    // Try removing every letter of the current string to see if the\n    // remaining strings form a string chain.\n    for i in 0 ..< string.length {\n      let smallerString = getSmallerString(string, i)\n      if let _ = stringChains[smallerString] {\n        tryUpdateLongestStringChain(string, smallerString, &stringChains)\n      }\n    }\n  }\n\n  func getSmallerString(_ string: String, _ index: Int) -> String {\n    var s = string\n    let i = s.index(s.startIndex, offsetBy: index)\n    s.remove(at: i)\n    return s\n  }\n\n  func tryUpdateLongestStringChain(_ currentString: String, _ smallerString: String, _ stringChains: inout [String: Chain]) {\n    let smallerStringChainLength = stringChains[smallerString]!.maxChainLength\n    let currentStringChainLength = stringChains[currentString]!.maxChainLength\n    // Update the string chain of the current string only if the smaller string leads\n    // to a longer string chain.\n    if smallerStringChainLength + 1 > currentStringChainLength {\n      stringChains[currentString]!.maxChainLength = smallerStringChainLength + 1\n      stringChains[currentString]!.nextString = smallerString\n    }\n  }\n\n  func buildLongestStringChain(_ strings: [String], _ stringChains: inout [String: Chain]) -> [String] {\n    // Find the string that starts the longest string chain.\n    var maxChainLength = 0\n    var chainStartingString = ""\n    for str in strings {\n      if stringChains[str]!.maxChainLength > maxChainLength {\n        maxChainLength = stringChains[str]!.maxChainLength\n        chainStartingString = str\n      }\n    }\n\n    // Starting at the string found above, build the longest string chain.\n    var ourLongestStringChain = [String]()\n    var currentString = chainStartingString\n    while currentString != "" {\n      ourLongestStringChain.append(currentString)\n      currentString = stringChains[currentString]!.nextString\n    }\n\n    if ourLongestStringChain.count == 1 {\n      return [String]()\n    }\n    return ourLongestStringChain\n  }\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let input = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n      let expected = ["abcdef", "abcde", "abde", "ade", "ae"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let input = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n      let expected = ["abcdef", "abcde", "abde", "ade", "ae"]\n      let output = program.longestStringChain(input)\n      try assertEqual(output, expected)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function longestStringChain(strings: string[]) {\n  // Write your code here.\n  return [''];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface StringChains {\n  [key: string]: {\n    nextString: string;\n    maxChainLength: number;\n  };\n}\n\n// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nexport function longestStringChain(strings: string[]) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains: StringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string: string, stringChains: StringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string: string, index: number) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString: string, smallerString: string, stringChains: StringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings: string[], stringChains: StringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain: string[] = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "strings",
          example: [
            "abde",
            "abc",
            "abd",
            "abcde",
            "ade",
            "ae",
            "1abde",
            "abcdef",
          ],
          schema: {
            items: {
              type: "string",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          strings: [
            "abde",
            "abc",
            "abd",
            "abcde",
            "ade",
            "ae",
            "1abde",
            "abcdef",
          ],
        },
        {
          strings: ["abcdefg", "abcdef", "abcde", "abcd", "abc", "ab", "a"],
        },
        {
          strings: ["abcdefg", "abdefg", "abdfg", "bdfg", "bfg", "bg", "g"],
        },
        {
          strings: [
            "abcdefg",
            "1234",
            "abdefg",
            "abdfg",
            "123",
            "12",
            "bg",
            "g",
            "12345",
            "12a345",
          ],
        },
        {
          strings: [
            "abcdefg1",
            "1234c",
            "abdefg2",
            "abdfg",
            "123",
            "122",
            "bgg",
            "g",
            "1a2345",
            "12a345",
          ],
        },
        {
          strings: [
            "lgoprt",
            "12345678",
            "algoxpert",
            "abcde",
            "123468",
            "lgoxprt",
            "abde",
            "lgopt",
            "1234678",
            "ade",
            "ae",
            "algoxprt",
            "a",
            "1abde",
            "lgpt",
            "123456789",
            "234678",
            "algoexpert",
          ],
        },
        {
          strings: [
            "12345678",
            "algoxpert",
            "123468",
            "abde",
            "lgopt",
            "1234678",
            "ade",
            "ae",
            "a",
            "1abde",
            "lgpt",
            "123456789",
            "234678",
            "algoexpert",
          ],
        },
      ],
      jsonTests: [
        {
          strings: [
            "abde",
            "abc",
            "abd",
            "abcde",
            "ade",
            "ae",
            "1abde",
            "abcdef",
          ],
        },
        {
          strings: ["abcdefg", "abcdef", "abcde", "abcd", "abc", "ab", "a"],
        },
        {
          strings: ["abcdefg", "abdefg", "abdfg", "bdfg", "bfg", "bg", "g"],
        },
        {
          strings: [
            "abcdefg",
            "1234",
            "abdefg",
            "abdfg",
            "123",
            "12",
            "bg",
            "g",
            "12345",
            "12a345",
          ],
        },
        {
          strings: [
            "abcdefg1",
            "1234c",
            "abdefg2",
            "abdfg",
            "123",
            "122",
            "bgg",
            "g",
            "1a2345",
            "12a345",
          ],
        },
        {
          strings: [
            "lgoprt",
            "12345678",
            "algoxpert",
            "abcde",
            "123468",
            "lgoxprt",
            "abde",
            "lgopt",
            "1234678",
            "ade",
            "ae",
            "algoxprt",
            "a",
            "1abde",
            "lgpt",
            "123456789",
            "234678",
            "algoexpert",
          ],
        },
        {
          strings: [
            "12345678",
            "algoxpert",
            "123468",
            "abde",
            "lgopt",
            "1234678",
            "ade",
            "ae",
            "a",
            "1abde",
            "lgpt",
            "123456789",
            "234678",
            "algoexpert",
          ],
        },
      ],
      changelog: [],
      id: 35,
    },
    {
      uid: "binary-tree-diameter",
      testStrategy: "JSON",
      name: "Binary Tree Diameter",
      version: 0,
      releaseDate: "2020-11-16T00:00:00Z",
      category: "Binary Trees",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 15372,
        failureCount: 6451,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "557855845",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1053,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and returns its diameter. The\n  diameter of a binary tree is defined as the length of its longest path, even\n  if that path doesn\'t pass through the root of the tree.\n</p>\n<p>\n  A path is a collection of connected nodes in a tree, where no node is\n  connected to more than two other nodes. The length of a path is the number of\n  edges between the path\'s first node and its last node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =        1\n            /   \\\n           3     2\n         /   \\ \n        7     4\n       /       \\\n      8         5\n     /           \\\n    9             6\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class="CodeEditor-promptComment">// 9 -> 8 -> 7 -> 3 -> 4 -> 5 -> 6</span>\n<span class="CodeEditor-promptComment">// There are 6 edges between the</span>\n<span class="CodeEditor-promptComment">// first node and the last node</span>\n<span class="CodeEditor-promptComment">// of this tree\'s longest path.</span>\n</pre>\n</div>',
      hints: [
        "<p>\nHow can you use the height of a binary tree and the heights of its subtrees to calculate its diameter?\n</p>\n",
        "\n<p>\nThe length of the longest path that goes through the root of a binary tree is the sum of the heights of its left and right subtrees (left subtree height + right subtree height). The diameter of a binary tree can be calculated by taking the maximum of: 1) the maximum subtree diameter (max(left subtree diameter, right subtree diameter)); and 2) the length of the longest path that goes through the root (left subtree height + right subtree height).\n</p>\n",
        "\n<p>\nImplement a variation of depth-first search that recursively keeps track of both the diameter and the height of a each subtree in the input binary tree. Follow Hint #2 to continuously compute these diameters.\n</p>",
      ],
      spaceTime:
        "Average case: when the tree is balanced\nO(n) time | O(h) space - where n is the number of nodes in the Binary Tree and h is the height of the Binary Tree",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: "tree",
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\n// This is an input class. Do not edit.\nclass BinaryTree {\npublic:\n  int value;\n  BinaryTree *left;\n  BinaryTree *right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nint binaryTreeDiameter(BinaryTree *tree) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass BinaryTree {\npublic:\n  int value;\n  BinaryTree *left;\n  BinaryTree *right;\n\n  BinaryTree(int value) {\n    this->value = value;\n    left = nullptr;\n    right = nullptr;\n  }\n};\n\nstruct TreeInfo {\n  int diameter;\n  int height;\n};\n\nTreeInfo getTreeInfo(BinaryTree *tree);\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nint binaryTreeDiameter(BinaryTree *tree) { return getTreeInfo(tree).diameter; }\n\nTreeInfo getTreeInfo(BinaryTree *tree) {\n  if (tree == nullptr) {\n    return TreeInfo{0, 0};\n  }\n\n  TreeInfo leftTreeInfo = getTreeInfo(tree->left);\n  TreeInfo rightTreeInfo = getTreeInfo(tree->right);\n\n  int longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  int maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  int currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar);\n  int currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return TreeInfo{currentDiameter, currentHeight};\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      BinaryTree *root = new BinaryTree(1);\n      root->left = new BinaryTree(3);\n      root->left->left = new BinaryTree(7);\n      root->left->left->left = new BinaryTree(8);\n      root->left->left->left->left = new BinaryTree(9);\n      root->left->right = new BinaryTree(4);\n      root->left->right->right = new BinaryTree(5);\n      root->left->right->right->right = new BinaryTree(6);\n      root->right = new BinaryTree(2);\n      int expected = 6;\n      int actual = binaryTreeDiameter(root);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      BinaryTree *root = new BinaryTree(1);\n      root->left = new BinaryTree(3);\n      root->left->left = new BinaryTree(7);\n      root->left->left->left = new BinaryTree(8);\n      root->left->left->left->left = new BinaryTree(9);\n      root->left->right = new BinaryTree(4);\n      root->left->right->right = new BinaryTree(5);\n      root->left->right->right->right = new BinaryTree(6);\n      root->right = new BinaryTree(2);\n      int expected = 6;\n      int actual = binaryTreeDiameter(root);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\tpublic int BinaryTreeDiameter(BinaryTree tree) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n\n\tpublic class BinaryTree {\n\t\tpublic int value;\n\t\tpublic BinaryTree left;\n\t\tpublic BinaryTree right;\n\n\t\tpublic BinaryTree(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\n\n\npublic class Program {\n\n\t// Average case: when the tree is balanced\n\t// O(n) time | O(h) space - where n is the number of nodes in\n\t// the Binary Tree and h is the height of the Binary Tree\n\tpublic int BinaryTreeDiameter(BinaryTree tree) {\n\t\treturn getTreeInfo(tree).diameter;\n\t}\n\n\tpublic TreeInfo getTreeInfo(BinaryTree tree) {\n\t\tif (tree == null) {\n\t\t\treturn new TreeInfo(0, 0);\n\t\t}\n\n\t\tTreeInfo leftTreeInfo = getTreeInfo(tree.left);\n\t\tTreeInfo rightTreeInfo = getTreeInfo(tree.right);\n\n\t\tint longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n\t\tint maxDiameterSoFar = Math.Max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n\t\tint currentDiameter = Math.Max(longestPathThroughRoot, maxDiameterSoFar);\n\t\tint currentHeight = 1 + Math.Max(leftTreeInfo.height, rightTreeInfo.height);\n\n\t\treturn new TreeInfo(currentDiameter, currentHeight);\n\t}\n\n\tpublic class TreeInfo {\n\t\tpublic int diameter;\n\t\tpublic int height;\n\t\tpublic TreeInfo(int diameter, int height) {\n\t\t\tthis.diameter = diameter;\n\t\t\tthis.height = height;\n\t\t}\n\t}\n\n\tpublic class BinaryTree {\n\t\tpublic int value;\n\t\tpublic BinaryTree left;\n\t\tpublic BinaryTree right;\n\n\t\tpublic BinaryTree(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}\n\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar root = new Program.BinaryTree(1);\n\t\troot.left = new Program.BinaryTree(3);\n\t\troot.left.left = new Program.BinaryTree(7);\n\t\troot.left.left.left = new Program.BinaryTree(8);\n\t\troot.left.left.left.left = new Program.BinaryTree(9);\n\t\troot.left.right = new Program.BinaryTree(4);\n\t\troot.left.right.right = new Program.BinaryTree(5);\n\t\troot.left.right.right.right = new Program.BinaryTree(6);\n\t\troot.right = new Program.BinaryTree(2);\n\t\tvar expected = 6;\n\t\tvar actual = new Program().BinaryTreeDiameter(root);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tvar root = new Program.BinaryTree(1);\n\t\troot.left = new Program.BinaryTree(3);\n\t\troot.left.left = new Program.BinaryTree(7);\n\t\troot.left.left.left = new Program.BinaryTree(8);\n\t\troot.left.left.left.left = new Program.BinaryTree(9);\n\t\troot.left.right = new Program.BinaryTree(4);\n\t\troot.left.right.right = new Program.BinaryTree(5);\n\t\troot.left.right.right.right = new Program.BinaryTree(6);\n\t\troot.right = new Program.BinaryTree(2);\n\t\tvar expected = 6;\n\t\tvar actual = new Program().BinaryTreeDiameter(root);\n\t\tUtils.AssertTrue(expected == actual);\n\t}\n}\n\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\nfunc BinaryTreeDiameter(tree *BinaryTree) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// This is an input class. Do not edit.\ntype BinaryTree struct {\n\tValue int\n\n\tLeft  *BinaryTree\n\tRight *BinaryTree\n}\n\ntype TreeInfo struct {\n\tdiameter int\n\theight   int\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunc BinaryTreeDiameter(tree *BinaryTree) int {\n\treturn getTreeInfo(tree).diameter\n}\n\nfunc getTreeInfo(tree *BinaryTree) TreeInfo {\n\tif tree == nil {\n\t\treturn TreeInfo{0, 0}\n\t}\n\n\tleftTreeInfo := getTreeInfo(tree.Left)\n\trightTreeInfo := getTreeInfo(tree.Right)\n\n\tlongestPathThroughRoot := leftTreeInfo.height + rightTreeInfo.height\n\tmaxDiameterSoFar := max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n\tcurrentDiameter := max(longestPathThroughRoot, maxDiameterSoFar)\n\tcurrentHeight := 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n\treturn TreeInfo{currentDiameter, currentHeight}\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 3}\n\troot.Left.Left = &BinaryTree{Value: 7}\n\troot.Left.Left.Left = &BinaryTree{Value: 8}\n\troot.Left.Left.Left.Left = &BinaryTree{Value: 9}\n\troot.Left.Right = &BinaryTree{Value: 4}\n\troot.Left.Right.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Right.Right = &BinaryTree{Value: 6}\n\troot.Right = &BinaryTree{Value: 2}\n\texpected := 6\n\tactual := BinaryTreeDiameter(root)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\troot := &BinaryTree{Value: 1}\n\troot.Left = &BinaryTree{Value: 3}\n\troot.Left.Left = &BinaryTree{Value: 7}\n\troot.Left.Left.Left = &BinaryTree{Value: 8}\n\troot.Left.Left.Left.Left = &BinaryTree{Value: 9}\n\troot.Left.Right = &BinaryTree{Value: 4}\n\troot.Left.Right.Right = &BinaryTree{Value: 5}\n\troot.Left.Right.Right.Right = &BinaryTree{Value: 6}\n\troot.Right = &BinaryTree{Value: 2}\n\texpected := 6\n\tactual := BinaryTreeDiameter(root)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  // This is an input class. Do not edit.\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left = null;\n    public BinaryTree right = null;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n\n  public int binaryTreeDiameter(BinaryTree tree) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // Average case: when the tree is balanced\n  // O(n) time | O(h) space - where n is the number of nodes in\n  // the Binary Tree and h is the height of the Binary Tree\n  public int binaryTreeDiameter(BinaryTree tree) {\n    return getTreeInfo(tree).diameter;\n  }\n\n  public TreeInfo getTreeInfo(BinaryTree tree) {\n    if (tree == null) {\n      return new TreeInfo(0, 0);\n    }\n\n    TreeInfo leftTreeInfo = getTreeInfo(tree.left);\n    TreeInfo rightTreeInfo = getTreeInfo(tree.right);\n\n    int longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n    int maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n    int currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n    int currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n    return new TreeInfo(currentDiameter, currentHeight);\n  }\n\n  static class TreeInfo {\n    public int diameter;\n    public int height;\n\n    public TreeInfo(int diameter, int height) {\n      this.diameter = diameter;\n      this.height = height;\n    }\n  }\n\n  static class BinaryTree {\n    public int value;\n    public BinaryTree left;\n    public BinaryTree right;\n\n    public BinaryTree(int value) {\n      this.value = value;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree input = new TestBinaryTree(1);\n    input.insert(new int[] {2, 3, 4, 5, 6, 7}, 0);\n    var expected = 4;\n    var actual = new Program().binaryTreeDiameter(input);\n    Utils.assertTrue(expected == actual);\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue = new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    TestBinaryTree input = new TestBinaryTree(1);\n    input.insert(new int[] {2, 3, 4, 5, 6, 7}, 0);\n    var expected = 4;\n    var actual = new Program().binaryTreeDiameter(input);\n    Utils.assertTrue(expected == actual);\n  }\n\n  class TestBinaryTree extends Program.BinaryTree {\n    public TestBinaryTree(int value) {\n      super(value);\n    }\n\n    public void insert(int[] values, int i) {\n      if (i >= values.length) {\n        return;\n      }\n      ArrayDeque<Program.BinaryTree> queue = new ArrayDeque<Program.BinaryTree>();\n      queue.addLast(this);\n      while (queue.size() > 0) {\n        Program.BinaryTree current = queue.pollFirst();\n        if (current.left == null) {\n          current.left = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.left);\n        if (current.right == null) {\n          current.right = new Program.BinaryTree(values[i]);\n          break;\n        }\n        queue.addLast(current.right);\n      }\n      insert(values, i + 1);\n    }\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction binaryTreeDiameter(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.binaryTreeDiameter = binaryTreeDiameter;\nexports.BinaryTree = BinaryTree;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction binaryTreeDiameter(tree) {\n  return getTreeInfo(tree).diameter;\n}\n\nfunction getTreeInfo(tree) {\n  if (tree === null) {\n    return new TreeInfo(0, 0);\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  const maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  const currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n  const currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return new TreeInfo(currentDiameter, currentHeight);\n}\n\nclass TreeInfo {\n  constructor(diameter, height) {\n    this.diameter = diameter;\n    this.height = height;\n  }\n}\n\n// Do not edit the line below.\nexports.binaryTreeDiameter = binaryTreeDiameter;\nexports.BinaryTree = BinaryTree;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\n// This is an input class. Do not edit.\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nfun binaryTreeDiameter(tree: BinaryTree?): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\nopen class BinaryTree(value: Int) {\n    var value = value\n    var left: BinaryTree? = null\n    var right: BinaryTree? = null\n}\n\nopen class TreeInfo(diameter: Int, height: Int) {\n    val diameter = diameter\n    val height = height\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfun binaryTreeDiameter(tree: BinaryTree): Int {\n    return getTreeInfo(tree).diameter\n}\n\nfun getTreeInfo(tree: BinaryTree?): TreeInfo {\n    if (tree == null) return TreeInfo(0, 0)\n\n    val leftTreeInfo = getTreeInfo(tree.left)\n    val rightTreeInfo = getTreeInfo(tree.right)\n\n    val longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    val maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    val currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    val currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.binaryTreeDiameter\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(3)\n        root.left!!.left = BinaryTree(7)\n        root.left!!.left!!.left = BinaryTree(8)\n        root.left!!.left!!.left!!.left = BinaryTree(9)\n        root.left!!.right = BinaryTree(4)\n        root.left!!.right!!.right = BinaryTree(5)\n        root.left!!.right!!.right!!.right = BinaryTree(6)\n        root.right = BinaryTree(2)\n        val expected = 6\n        var output = binaryTreeDiameter(root)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.BinaryTree\nimport com.algoexpert.program.binaryTreeDiameter\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val root = BinaryTree(1)\n        root.left = BinaryTree(3)\n        root.left!!.left = BinaryTree(7)\n        root.left!!.left!!.left = BinaryTree(8)\n        root.left!!.left!!.left!!.left = BinaryTree(9)\n        root.left!!.right = BinaryTree(4)\n        root.left!!.right!!.right = BinaryTree(5)\n        root.left!!.right!!.right!!.right = BinaryTree(6)\n        root.right = BinaryTree(2)\n        val expected = 6\n        var output = binaryTreeDiameter(root)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "# This is an input class. Do not edit.\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef binaryTreeDiameter(tree):\n    # Write your code here.\n    return -1\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass BinaryTree:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\n# Average case: when the tree is balanced\n# O(n) time | O(h) space - where n is the number of nodes in\n# the Binary Tree and h is the height of the Binary Tree\ndef binaryTreeDiameter(tree):\n    return getTreeInfo(tree).diameter\n\n\ndef getTreeInfo(tree):\n    if tree is None:\n        return TreeInfo(0, 0)\n\n    leftTreeInfo = getTreeInfo(tree.left)\n    rightTreeInfo = getTreeInfo(tree.right)\n\n    longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n\n\nclass TreeInfo:\n    def __init__(self, diameter, height):\n        self.diameter = diameter\n        self.height = height\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(3)\n        root.left.left = program.BinaryTree(7)\n        root.left.left.left = program.BinaryTree(8)\n        root.left.left.left.left = program.BinaryTree(9)\n        root.left.right = program.BinaryTree(4)\n        root.left.right.right = program.BinaryTree(5)\n        root.left.right.right.right = program.BinaryTree(6)\n        root.right = program.BinaryTree(2)\n        expected = 6\n        actual = program.binaryTreeDiameter(root)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        root = program.BinaryTree(1)\n        root.left = program.BinaryTree(3)\n        root.left.left = program.BinaryTree(7)\n        root.left.left.left = program.BinaryTree(8)\n        root.left.left.left.left = program.BinaryTree(9)\n        root.left.right = program.BinaryTree(4)\n        root.left.right.right = program.BinaryTree(5)\n        root.left.right.right.right = program.BinaryTree(6)\n        root.right = program.BinaryTree(2)\n        expected = 6\n        actual = program.binaryTreeDiameter(root)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def binaryTreeDiameter(tree)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# This is an input struct. Do not edit.\nclass BinaryTree\n  attr_accessor :value\n  attr_accessor :left\n  attr_accessor :right\n\n  def initialize(value)\n    @value = value\n    @left = nil\n    @right = nil\n  end\nend\n\nclass Program\n  def binaryTreeDiameter(tree)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binaryTreeDiameter\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.binaryTreeDiameter\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  // This is an input class. Do not edit.\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  func binaryTreeDiameter(_ tree: BinaryTree) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class BinaryTree {\n    var value: Int\n    var left: BinaryTree?\n    var right: BinaryTree?\n\n    init(value: Int) {\n      self.value = value\n      left = nil\n      right = nil\n    }\n  }\n\n  class TreeInfo {\n    var diameter: Int\n    var height: Int\n\n    init(_ diameter: Int, _ height: Int) {\n      self.diameter = diameter\n      self.height = height\n    }\n  }\n\n  // Average case: when the tree is balanced\n  // O(n) time | O(h) space - where n is the number of nodes in\n  // the Binary Tree and h is the height of the Binary Tree\n  func binaryTreeDiameter(_ tree: BinaryTree) -> Int {\n    return getTreeInfo(tree).diameter\n  }\n\n  func getTreeInfo(_ tree: BinaryTree?) -> TreeInfo {\n    if tree == nil {\n      return TreeInfo(0, 0)\n    }\n\n    let leftTreeInfo = getTreeInfo(tree!.left)\n    let rightTreeInfo = getTreeInfo(tree!.right)\n\n    let longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height\n    let maxDiameterSoFar = max(leftTreeInfo.diameter, rightTreeInfo.diameter)\n    let currentDiameter = max(longestPathThroughRoot, maxDiameterSoFar)\n    let currentHeight = 1 + max(leftTreeInfo.height, rightTreeInfo.height)\n\n    return TreeInfo(currentDiameter, currentHeight)\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 3)\n      root.left!.left = Program.BinaryTree(value: 7)\n      root.left!.left!.left = Program.BinaryTree(value: 8)\n      root.left!.left!.left!.left = Program.BinaryTree(value: 9)\n      root.left!.right = Program.BinaryTree(value: 4)\n      root.left!.right!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.right!.right = Program.BinaryTree(value: 6)\n      root.right = Program.BinaryTree(value: 2)\n      let expected = 6\n      var actual = Program().binaryTreeDiameter(root)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      let root = Program.BinaryTree(value: 1)\n      root.left = Program.BinaryTree(value: 3)\n      root.left!.left = Program.BinaryTree(value: 7)\n      root.left!.left!.left = Program.BinaryTree(value: 8)\n      root.left!.left!.left!.left = Program.BinaryTree(value: 9)\n      root.left!.right = Program.BinaryTree(value: 4)\n      root.left!.right!.right = Program.BinaryTree(value: 5)\n      root.left!.right!.right!.right = Program.BinaryTree(value: 6)\n      root.right = Program.BinaryTree(value: 2)\n      let expected = 6\n      var actual = Program().binaryTreeDiameter(root)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport function binaryTreeDiameter(tree: BinaryTree) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nexport class BinaryTree {\n  value: number;\n  left: BinaryTree | null;\n  right: BinaryTree | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nexport function binaryTreeDiameter(tree: BinaryTree) {\n  return getTreeInfo(tree).diameter;\n}\n\nfunction getTreeInfo(tree: BinaryTree | null): TreeInfo {\n  if (tree === null) {\n    return new TreeInfo(0, 0);\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  const maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  const currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n  const currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return new TreeInfo(currentDiameter, currentHeight);\n}\n\nclass TreeInfo {\n  diameter: number;\n  height: number;\n\n  constructor(diameter: number, height: number) {\n    this.diameter = diameter;\n    this.height = height;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "tree",
          example: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "2",
                value: 1,
              },
              {
                id: "3",
                left: "7",
                right: "4",
                value: 3,
              },
              {
                id: "7",
                left: "8",
                right: null,
                value: 7,
              },
              {
                id: "8",
                left: "9",
                right: null,
                value: 8,
              },
              {
                id: "9",
                left: null,
                right: null,
                value: 9,
              },
              {
                id: "4",
                left: null,
                right: "5",
                value: 4,
              },
              {
                id: "5",
                left: null,
                right: "6",
                value: 5,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
          schema: {
            description:
              "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
            properties: {
              nodes: {
                items: {
                  properties: {
                    id: {
                      type: "string",
                    },
                    left: {
                      type: ["string", "null"],
                    },
                    right: {
                      type: ["string", "null"],
                    },
                    value: {
                      type: "integer",
                    },
                  },
                  required: ["id", "value", "left", "right"],
                  type: "object",
                },
                type: "array",
              },
              root: {
                type: "string",
              },
            },
            required: ["root", "nodes"],
            type: "object",
          },
        },
      ],
      tests: [
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "2",
                value: 1,
              },
              {
                id: "3",
                left: "7",
                right: "4",
                value: 3,
              },
              {
                id: "7",
                left: "8",
                right: null,
                value: 7,
              },
              {
                id: "8",
                left: "9",
                right: null,
                value: 8,
              },
              {
                id: "9",
                left: null,
                right: null,
                value: 9,
              },
              {
                id: "4",
                left: null,
                right: "5",
                value: 4,
              },
              {
                id: "5",
                left: null,
                right: "6",
                value: 5,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: "6",
                right: "7",
                value: 3,
              },
              {
                id: "7",
                left: null,
                right: null,
                value: 7,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
              {
                id: "2",
                left: "4",
                right: "5",
                value: 2,
              },
              {
                id: "5",
                left: null,
                right: null,
                value: 5,
              },
              {
                id: "4",
                left: null,
                right: null,
                value: 4,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "-1",
                value: 1,
              },
              {
                id: "-1",
                left: null,
                right: null,
                value: -1,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "-5",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "-5",
                left: "6",
                right: null,
                value: -5,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "9",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "9",
                left: "14",
                right: "10",
                value: 9,
              },
              {
                id: "10",
                left: null,
                right: "11",
                value: 10,
              },
              {
                id: "11",
                left: null,
                right: "12",
                value: 11,
              },
              {
                id: "12",
                left: null,
                right: "17",
                value: 12,
              },
              {
                id: "17",
                left: null,
                right: null,
                value: 17,
              },
              {
                id: "14",
                left: null,
                right: "19",
                value: 14,
              },
              {
                id: "19",
                left: "25",
                right: null,
                value: 19,
              },
              {
                id: "25",
                left: null,
                right: null,
                value: 25,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "5",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "5",
                left: null,
                right: null,
                value: 5,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "5",
                right: null,
                value: 1,
              },
              {
                id: "5",
                left: "7",
                right: "9",
                value: 5,
              },
              {
                id: "9",
                left: null,
                right: "12",
                value: 9,
              },
              {
                id: "12",
                left: null,
                right: null,
                value: 12,
              },
              {
                id: "7",
                left: "8",
                right: null,
                value: 7,
              },
              {
                id: "8",
                left: null,
                right: null,
                value: 8,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: null,
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: "19",
                right: null,
                value: 3,
              },
              {
                id: "19",
                left: null,
                right: null,
                value: 19,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "6",
                left: null,
                right: "1",
                value: 6,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "6",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "3",
                left: null,
                right: "10",
                value: 3,
              },
              {
                id: "10",
                left: "1",
                right: null,
                value: 10,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "3",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: "3",
                right: null,
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: "5",
                value: 3,
              },
              {
                id: "5",
                left: null,
                right: "10",
                value: 5,
              },
              {
                id: "10",
                left: null,
                right: null,
                value: 10,
              },
            ],
            root: "2",
          },
        },
      ],
      jsonTests: [
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "2",
                value: 1,
              },
              {
                id: "3",
                left: "7",
                right: "4",
                value: 3,
              },
              {
                id: "7",
                left: "8",
                right: null,
                value: 7,
              },
              {
                id: "8",
                left: "9",
                right: null,
                value: 8,
              },
              {
                id: "9",
                left: null,
                right: null,
                value: 9,
              },
              {
                id: "4",
                left: null,
                right: "5",
                value: 4,
              },
              {
                id: "5",
                left: null,
                right: "6",
                value: 5,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: "6",
                right: "7",
                value: 3,
              },
              {
                id: "7",
                left: null,
                right: null,
                value: 7,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
              {
                id: "2",
                left: "4",
                right: "5",
                value: 2,
              },
              {
                id: "5",
                left: null,
                right: null,
                value: 5,
              },
              {
                id: "4",
                left: null,
                right: null,
                value: 4,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "2",
                right: "-1",
                value: 1,
              },
              {
                id: "-1",
                left: null,
                right: null,
                value: -1,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "-5",
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "-5",
                left: "6",
                right: null,
                value: -5,
              },
              {
                id: "6",
                left: null,
                right: null,
                value: 6,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "9",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "9",
                left: "14",
                right: "10",
                value: 9,
              },
              {
                id: "10",
                left: null,
                right: "11",
                value: 10,
              },
              {
                id: "11",
                left: null,
                right: "12",
                value: 11,
              },
              {
                id: "12",
                left: null,
                right: "17",
                value: 12,
              },
              {
                id: "17",
                left: null,
                right: null,
                value: 17,
              },
              {
                id: "14",
                left: null,
                right: "19",
                value: 14,
              },
              {
                id: "19",
                left: "25",
                right: null,
                value: 19,
              },
              {
                id: "25",
                left: null,
                right: null,
                value: 25,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "3",
                right: "5",
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: null,
                value: 3,
              },
              {
                id: "5",
                left: null,
                right: null,
                value: 5,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: "5",
                right: null,
                value: 1,
              },
              {
                id: "5",
                left: "7",
                right: "9",
                value: 5,
              },
              {
                id: "9",
                left: null,
                right: "12",
                value: 9,
              },
              {
                id: "12",
                left: null,
                right: null,
                value: 12,
              },
              {
                id: "7",
                left: "8",
                right: null,
                value: 7,
              },
              {
                id: "8",
                left: null,
                right: null,
                value: 8,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "1",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: null,
                right: null,
                value: 2,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "4",
                left: "2",
                right: null,
                value: 4,
              },
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: null,
                right: "3",
                value: 1,
              },
              {
                id: "3",
                left: "19",
                right: null,
                value: 3,
              },
              {
                id: "19",
                left: null,
                right: null,
                value: 19,
              },
            ],
            root: "4",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "6",
                left: null,
                right: "1",
                value: 6,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "6",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "3",
                left: null,
                right: "10",
                value: 3,
              },
              {
                id: "10",
                left: "1",
                right: null,
                value: 10,
              },
              {
                id: "1",
                left: null,
                right: null,
                value: 1,
              },
            ],
            root: "3",
          },
        },
        {
          tree: {
            nodes: [
              {
                id: "2",
                left: "1",
                right: null,
                value: 2,
              },
              {
                id: "1",
                left: "3",
                right: null,
                value: 1,
              },
              {
                id: "3",
                left: null,
                right: "5",
                value: 3,
              },
              {
                id: "5",
                left: null,
                right: "10",
                value: 5,
              },
              {
                id: "10",
                left: null,
                right: null,
                value: 10,
              },
            ],
            root: "2",
          },
        },
      ],
      changelog: [],
      id: 36,
    },
    {
      uid: "linked-list-construction",
      testStrategy: "JSON",
      name: "Linked List Construction",
      version: 0,
      releaseDate: "2018-10-20T00:00:00Z",
      category: "Linked Lists",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 11316,
        failureCount: 9412,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "293493132",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 2101,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a <span>DoublyLinkedList</span> class that has a <span>head</span> and a\n  <span>tail</span>, both of which point to either a linked list\n  <span>Node</span> or <span>None</span> / <span>null</span>. The class should\n  support:\n</p>\n<ul>\n  <li>\n    Setting the head and tail of the linked list.\n  </li>\n  <li>\n    Inserting nodes before and after other nodes as well as at given positions\n    (the position of the head node is <span>1</span>).\n  </li>\n  <li>Removing given nodes and removing nodes with given values.</li>\n  <li>Searching for nodes with given values.</li>\n</ul>\n<p>\n  Note that the <span>setHead</span>, <span>setTail</span>,\n  <span>insertBefore</span>, <span>insertAfter</span>,\n  <span>insertAtPosition</span>, and <span>remove</span> methods all take in\n  actual <span>Node</span>s as input parameters—not integers (except for\n  <span>insertAtPosition</span>, which also takes in an integer representing the\n  position); this means that you don\'t need to create any new <span>Node</span>s\n  in these methods. The input nodes can be either stand-alone nodes or nodes\n  that are already in the linked list. If they\'re nodes that are already in the\n  linked list, the methods will effectively be <i>moving</i> the nodes within\n  the linked list. You won\'t be told if the input nodes are already in the\n  linked list, so your code will have to defensively handle this scenario.\n</p>\n<p>\n  If you\'re doing this problem in an untyped language like Python or JavaScript,\n  you may want to look at the various function signatures in a typed language\n  like Java or TypeScript to get a better idea of what each input parameter is.\n</p>\n<p>\n  Each <span>Node</span> has an integer <span>value</span> as well as a\n  <span>prev</span> node and a <span>next</span> node, both of which can point\n  to either another node or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// Assume the following linked list has already been created:</span>\n1 <-> 2 <-> 3 <-> 4 <-> 5\n<span class="CodeEditor-promptComment">// Assume that we also have the following stand-alone nodes:</span>\n3, 3, 6\n<span class="CodeEditor-promptParameter">setHead</span>(4): 4 <-> 1 <-> 2 <-> 3 <-> 5 <span class="CodeEditor-promptComment">// set the existing node with value 4 as the head</span>\n<span class="CodeEditor-promptParameter">setTail</span>(6): 4 <-> 1 <-> 2 <-> 3 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// set the stand-alone node with value 6 as the tail</span>\n<span class="CodeEditor-promptParameter">insertBefore</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <span class="CodeEditor-promptComment">// move the existing node with value 3 before the existing node with value 6</span>\n<span class="CodeEditor-promptParameter">insertAfter</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class="CodeEditor-promptComment">// insert a stand-alone node with value 3 after the existing node with value 6</span>\n<span class="CodeEditor-promptParameter">insertAtPosition</span>(1, 3): 3 <-> 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class="CodeEditor-promptComment">// insert a stand-alone node with value 3 in position 1</span>\n<span class="CodeEditor-promptParameter">removeNodesWithValue</span>(3): 4 <-> 1 <-> 2 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// remove all nodes with value 3</span>\n<span class="CodeEditor-promptParameter">remove</span>(2): 4 <-> 1 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// remove the existing node with value 2</span>\n<span class="CodeEditor-promptParameter">containsNodeWithValue</span>(5): true\n</pre>\n</div>',
      hints: [
        "<p>\nWhen dealing with linked lists, it's very important to keep track of pointers on nodes (i.e., the \"next\" and \"prev\" properties on the nodes). For instance, if you're inserting a node in a linked list, but that node is already located somewhere else in the linked list (in other words, if you're moving a node), it's crucial to completely update the pointers of the adjacent nodes of the node being moved before updating the node's own pointers. The order in which you update nodes' pointers will make or break your algorithm.\n</p>\n",
        "\n<p>\nRealize that the insertBefore() and insertAfter() methods can be used to implement the setHead(), setTail(), and insertAtPosition() methods; making the insertBefore() and insertAfter() methods as robust as possible will simplify your code for the other methods. Make sure to take care of edge cases involving inserting nodes before the head of the linked list or inserting nodes after the tail of the linked list.\n</p>\n",
        "\n<p>\nSimilar to Hint #2, realize that the remove() method can be used to implement the removeNodesWithValue() method as well as parts of the insertBefore() and insertAfter() methods; make sure that the remove() method handles edge cases regarding the head and the tail.\n</p>",
      ],
      spaceTime:
        "setHead, setTail, insertBefore, insertAfter, and remove: O(1) time | O(1) space\ninsertAtPosition: O(p) time | O(1) space - where p is input position\nremoveNodesWithValue, containsNodeWithValue: O(n) time | O(1) space - where n is the number of nodes in the linked list",
      notes: "",
      isSlowExecution: false,
      isLongOutput: true,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nclass Node {\npublic:\n  int value;\n  Node *prev;\n  Node *next;\n\n  Node(int value);\n};\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\npublic:\n  Node *head;\n  Node *tail;\n\n  DoublyLinkedList() {\n    head = nullptr;\n    tail = nullptr;\n  }\n\n  void setHead(Node *node) {\n    // Write your code here.\n  }\n\n  void setTail(Node *node) {\n    // Write your code here.\n  }\n\n  void insertBefore(Node *node, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAfter(Node *node, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAtPosition(int position, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void removeNodesWithValue(int value) {\n    // Write your code here.\n  }\n\n  void remove(Node *node) {\n    // Write your code here.\n  }\n\n  bool containsNodeWithValue(int value) {\n    // Write your code here.\n    return false;\n  }\n};\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\nclass Node {\npublic:\n  int value;\n  Node *prev;\n  Node *next;\n\n  Node(int value);\n};\n\nclass DoublyLinkedList {\npublic:\n  Node *head;\n  Node *tail;\n\n  DoublyLinkedList() {\n    head = nullptr;\n    tail = nullptr;\n  }\n\n  // O(1) time | O(1) space\n  void setHead(Node *node) {\n    if (head == nullptr) {\n      head = node;\n      tail = node;\n      return;\n    }\n    insertBefore(head, node);\n  }\n\n  // O(1) time | O(1) space\n  void setTail(Node *node) {\n    if (tail == nullptr) {\n      setHead(node);\n      return;\n    }\n    insertAfter(tail, node);\n  }\n\n  // O(1) time | O(1) space\n  void insertBefore(Node *node, Node *nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail)\n      return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node->prev;\n    nodeToInsert->next = node;\n    if (node->prev == nullptr) {\n      head = nodeToInsert;\n    } else {\n      node->prev->next = nodeToInsert;\n    }\n    node->prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  void insertAfter(Node *node, Node *nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail)\n      return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node;\n    nodeToInsert->next = node->next;\n    if (node->next == nullptr) {\n      tail = nodeToInsert;\n    } else {\n      node->next->prev = nodeToInsert;\n    }\n    node->next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  void insertAtPosition(int position, Node *nodeToInsert) {\n    if (position == 1) {\n      setHead(nodeToInsert);\n      return;\n    }\n    Node *node = head;\n    int currentPosition = 1;\n    while (node != nullptr && currentPosition++ != position)\n      node = node->next;\n    if (node != nullptr) {\n      insertBefore(node, nodeToInsert);\n    } else {\n      setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  void removeNodesWithValue(int value) {\n    Node *node = head;\n    while (node != nullptr) {\n      Node *nodeToRemove = node;\n      node = node->next;\n      if (nodeToRemove->value == value)\n        remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  void remove(Node *node) {\n    if (node == head)\n      head = head->next;\n    if (node == tail)\n      tail = tail->prev;\n    removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  bool containsNodeWithValue(int value) {\n    Node *node = head;\n    while (node != nullptr && node->value != value)\n      node = node->next;\n    return node != nullptr;\n  }\n\n  void removeNodeBindings(Node *node) {\n    if (node->prev != nullptr)\n      node->prev->next = node->next;\n    if (node->next != nullptr)\n      node->next->prev = node->prev;\n    node->prev = nullptr;\n    node->next = nullptr;\n  }\n};\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = nullptr;\n  next = nullptr;\n};\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.head;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.tail;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid bindNodes(Node *nodeOne, Node *nodeTwo) {\n  nodeOne->next = nodeTwo;\n  nodeTwo->prev = nodeOne;\n}\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      DoublyLinkedList linkedList;\n      Node one(1);\n      Node two(2);\n      Node three(3);\n      Node three2(3);\n      Node three3(3);\n      Node four(4);\n      Node five(5);\n      Node six(6);\n      bindNodes(&one, &two);\n      bindNodes(&two, &three);\n      bindNodes(&three, &four);\n      bindNodes(&four, &five);\n      linkedList.head = &one;\n      linkedList.tail = &five;\n\n      linkedList.setHead(&four);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 3, 5}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{5, 3, 2, 1, 4}));\n\n      linkedList.setTail(&six);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 3, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 5, 3, 2, 1, 4}));\n\n      linkedList.insertBefore(&six, &three);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 3, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 3, 5, 2, 1, 4}));\n\n      linkedList.insertAfter(&six, &three2);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 3, 6, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 6, 3, 5, 2, 1, 4}));\n\n      linkedList.insertAtPosition(1, &three3);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 4, 1, 2, 5, 3, 6, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 6, 3, 5, 2, 1, 4, 3}));\n\n      linkedList.removeNodesWithValue(3);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 5, 2, 1, 4}));\n\n      linkedList.remove(&two);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 1, 4}));\n\n      assert(linkedList.containsNodeWithValue(5) == true);\n    });\n  }\n};\n',
          unitTests:
            '#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = nullptr;\n  next = nullptr;\n};\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.head;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.tail;\n  while (node != nullptr) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid bindNodes(Node *nodeOne, Node *nodeTwo) {\n  nodeOne->next = nodeTwo;\n  nodeTwo->prev = nodeOne;\n}\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      DoublyLinkedList linkedList;\n      Node one(1);\n      Node two(2);\n      Node three(3);\n      Node three2(3);\n      Node three3(3);\n      Node four(4);\n      Node five(5);\n      Node six(6);\n      bindNodes(&one, &two);\n      bindNodes(&two, &three);\n      bindNodes(&three, &four);\n      bindNodes(&four, &five);\n      linkedList.head = &one;\n      linkedList.tail = &five;\n\n      linkedList.setHead(&four);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 3, 5}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{5, 3, 2, 1, 4}));\n\n      linkedList.setTail(&six);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 3, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 5, 3, 2, 1, 4}));\n\n      linkedList.insertBefore(&six, &three);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 3, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 3, 5, 2, 1, 4}));\n\n      linkedList.insertAfter(&six, &three2);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 3, 6, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 6, 3, 5, 2, 1, 4}));\n\n      linkedList.insertAtPosition(1, &three3);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 4, 1, 2, 5, 3, 6, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 6, 3, 5, 2, 1, 4, 3}));\n\n      linkedList.removeNodesWithValue(3);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 5, 2, 1, 4}));\n\n      linkedList.remove(&two);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 5, 6}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 1, 4}));\n\n      assert(linkedList.containsNodeWithValue(5) == true);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n// Feel free to add new properties and methods to the class.\npublic class Program {\n\tpublic class DoublyLinkedList {\n\t\tpublic Node Head;\n\t\tpublic Node Tail;\n\n\t\tpublic void SetHead(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void SetTail(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertBefore(Node node, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertAfter(Node node, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertAtPosition(int position, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void RemoveNodesWithValue(int value) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void Remove(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic bool ContainsNodeWithValue(int value) {\n\t\t\t// Write your code here.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Do not edit the class below.\n\tpublic class Node {\n\t\tpublic int Value;\n\t\tpublic Node Prev;\n\t\tpublic Node Next;\n\n\t\tpublic Node(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\tpublic class DoublyLinkedList {\n\t\tpublic Node Head;\n\t\tpublic Node Tail;\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void SetHead(Node node) {\n\t\t\tif (Head == null) {\n\t\t\t\tHead = node;\n\t\t\t\tTail = node;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tInsertBefore(Head, node);\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void SetTail(Node node) {\n\t\t\tif (Tail == null) {\n\t\t\t\tSetHead(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tInsertAfter(Tail, node);\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void InsertBefore(Node node, Node nodeToInsert) {\n\t\t\tif (nodeToInsert == Head && nodeToInsert == Tail) return;\n\t\t\tRemove(nodeToInsert);\n\t\t\tnodeToInsert.Prev = node.Prev;\n\t\t\tnodeToInsert.Next = node;\n\t\t\tif (node.Prev == null) {\n\t\t\t\tHead = nodeToInsert;\n\t\t\t} else {\n\t\t\t\tnode.Prev.Next = nodeToInsert;\n\t\t\t}\n\t\t\tnode.Prev = nodeToInsert;\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void InsertAfter(Node node, Node nodeToInsert) {\n\t\t\tif (nodeToInsert == Head && nodeToInsert == Tail) return;\n\t\t\tRemove(nodeToInsert);\n\t\t\tnodeToInsert.Prev = node;\n\t\t\tnodeToInsert.Next = node.Next;\n\t\t\tif (node.Next == null) {\n\t\t\t\tTail = nodeToInsert;\n\t\t\t} else {\n\t\t\t\tnode.Next.Prev = nodeToInsert;\n\t\t\t}\n\t\t\tnode.Next = nodeToInsert;\n\t\t}\n\n\t\t// O(p) time | O(1) space\n\t\tpublic void InsertAtPosition(int position, Node nodeToInsert) {\n\t\t\tif (position == 1) {\n\t\t\t\tSetHead(nodeToInsert);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tNode node = Head;\n\t\t\tint currentPosition = 1;\n\t\t\twhile (node != null && currentPosition++ != position) node = node.Next;\n\t\t\tif (node != null) {\n\t\t\t\tInsertBefore(node, nodeToInsert);\n\t\t\t} else {\n\t\t\t\tSetTail(nodeToInsert);\n\t\t\t}\n\t\t}\n\n\t\t// O(n) time | O(1) space\n\t\tpublic void RemoveNodesWithValue(int value) {\n\t\t\tNode node = Head;\n\t\t\twhile (node != null) {\n\t\t\t\tNode nodeToRemove = node;\n\t\t\t\tnode = node.Next;\n\t\t\t\tif (nodeToRemove.Value == value) Remove(nodeToRemove);\n\t\t\t}\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void Remove(Node node) {\n\t\t\tif (node == Head) Head = Head.Next;\n\t\t\tif (node == Tail) Tail = Tail.Prev;\n\t\t\tRemoveNodeBindings(node);\n\t\t}\n\n\t\t// O(n) time | O(1) space\n\t\tpublic bool ContainsNodeWithValue(int value) {\n\t\t\tNode node = Head;\n\t\t\twhile (node != null && node.Value != value) node = node.Next;\n\t\t\treturn node != null;\n\t\t}\n\n\t\tpublic void RemoveNodeBindings(Node node) {\n\t\t\tif (node.Prev != null) node.Prev.Next = node.Next;\n\t\t\tif (node.Next != null) node.Next.Prev = node.Prev;\n\t\t\tnode.Prev = null;\n\t\t\tnode.Next = null;\n\t\t}\n\t}\n\n\tpublic class Node {\n\t\tpublic int Value;\n\t\tpublic Node Prev;\n\t\tpublic Node Next;\n\n\t\tpublic Node(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\tprivate List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Head;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Next;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Tail;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Prev;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n\t\tnodeOne.Next = nodeTwo;\n\t\tnodeTwo.Prev = nodeOne;\n\t}\n\n\tprivate bool compare(List<int> array1, int[] array2) {\n\t\tif (array1.Count != array2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < array1.Count; i++) {\n\t\t\tif (array1[i] != array2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node one = new Program.Node(1);\n\t\tProgram.Node two = new Program.Node(2);\n\t\tProgram.Node three = new Program.Node(3);\n\t\tProgram.Node three2 = new Program.Node(3);\n\t\tProgram.Node three3 = new Program.Node(3);\n\t\tProgram.Node four = new Program.Node(4);\n\t\tProgram.Node five = new Program.Node(5);\n\t\tProgram.Node six = new Program.Node(6);\n\t\tbindNodes(one, two);\n\t\tbindNodes(two, three);\n\t\tbindNodes(three, four);\n\t\tbindNodes(four, five);\n\t\tlinkedList.Head = one;\n\t\tlinkedList.Tail = five;\n\n\t\tlinkedList.SetHead(four);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {5, 3, 2, 1, 4}));\n\n\t\tlinkedList.SetTail(six);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 3, 2, 1, 4}));\n\n\t\tlinkedList.InsertBefore(six, three);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAfter(six, three2);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAtPosition(1, three3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n\n\t\tlinkedList.RemoveNodesWithValue(3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 2, 1, 4}));\n\n\t\tlinkedList.Remove(two);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(\n\t\t\t  linkedList), new int[] {4, 1, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(\n\t\t\t  linkedList), new int[] {6, 5, 1, 4}));\n\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(5));\n\t}\n}\n",
          unitTests:
            "using System.Collections.Generic;\n\npublic class ProgramTest {\n\tprivate List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Head;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Next;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Tail;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Prev;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n\t\tnodeOne.Next = nodeTwo;\n\t\tnodeTwo.Prev = nodeOne;\n\t}\n\n\tprivate bool compare(List<int> array1, int[] array2) {\n\t\tif (array1.Count != array2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < array1.Count; i++) {\n\t\t\tif (array1[i] != array2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node one = new Program.Node(1);\n\t\tProgram.Node two = new Program.Node(2);\n\t\tProgram.Node three = new Program.Node(3);\n\t\tProgram.Node three2 = new Program.Node(3);\n\t\tProgram.Node three3 = new Program.Node(3);\n\t\tProgram.Node four = new Program.Node(4);\n\t\tProgram.Node five = new Program.Node(5);\n\t\tProgram.Node six = new Program.Node(6);\n\t\tbindNodes(one, two);\n\t\tbindNodes(two, three);\n\t\tbindNodes(three, four);\n\t\tbindNodes(four, five);\n\t\tlinkedList.Head = one;\n\t\tlinkedList.Tail = five;\n\n\t\tlinkedList.SetHead(four);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {5, 3, 2, 1, 4}));\n\n\t\tlinkedList.SetTail(six);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 3, 2, 1, 4}));\n\n\t\tlinkedList.InsertBefore(six, three);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAfter(six, three2);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAtPosition(1, three3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n\n\t\tlinkedList.RemoveNodesWithValue(3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 2, 1, 4}));\n\n\t\tlinkedList.Remove(two);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(\n\t\t\t  linkedList), new int[] {4, 1, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(\n\t\t\t  linkedList), new int[] {6, 5, 1, 4}));\n\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(5));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "// Feel free to add methods and fields to the struct definitions.\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\treturn &DoublyLinkedList{}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\tif ll.Head == nil {\n\t\tll.Head = node\n\t\tll.Tail = node\n\t\treturn\n\t}\n\tll.InsertBefore(ll.Head, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\tif ll.Tail == nil {\n\t\tll.SetHead(node)\n\t\treturn\n\t}\n\tll.InsertAfter(ll.Tail, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node.Prev\n\tnodeToInsert.Next = node\n\tif node.Prev == nil {\n\t\tll.Head = nodeToInsert\n\t} else {\n\t\tnode.Prev.Next = nodeToInsert\n\t}\n\tnode.Prev = nodeToInsert\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node\n\tnodeToInsert.Next = node.Next\n\tif node.Next == nil {\n\t\tll.Tail = nodeToInsert\n\t} else {\n\t\tnode.Next.Prev = nodeToInsert\n\t}\n\tnode.Next = nodeToInsert\n}\n\n// O(p) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\tif position == 1 {\n\t\tll.SetHead(nodeToInsert)\n\t\treturn\n\t}\n\tnode := ll.Head\n\tcurrentPosition := 1\n\tfor node != nil && currentPosition != position {\n\t\tnode = node.Next\n\t\tcurrentPosition += 1\n\t}\n\tif node != nil {\n\t\tll.InsertBefore(node, nodeToInsert)\n\t} else {\n\t\tll.SetTail(nodeToInsert)\n\t}\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\tnode := ll.Head\n\tfor node != nil {\n\t\tnodeToRemove := node\n\t\tnode = node.Next\n\t\tif nodeToRemove.Value == value {\n\t\t\tll.Remove(nodeToRemove)\n\t\t}\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\tif node == ll.Head {\n\t\tll.Head = ll.Head.Next\n\t}\n\tif node == ll.Tail {\n\t\tll.Tail = ll.Tail.Prev\n\t}\n\tll.removeNodeBindings(node)\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\tnode := ll.Head\n\tfor node != nil && node.Value != value {\n\t\tnode = node.Next\n\t}\n\treturn node != nil\n}\n\nfunc (ll *DoublyLinkedList) removeNodeBindings(node *Node) {\n\tif node.Prev != nil {\n\t\tnode.Prev.Next = node.Next\n\t}\n\tif node.Next != nil {\n\t\tnode.Next.Prev = node.Prev\n\t}\n\tnode.Prev = nil\n\tnode.Next = nil\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tone := NewNode(1)\n\ttwo := NewNode(2)\n\tthree := NewNode(3)\n\tthree2 := NewNode(3)\n\tthree3 := NewNode(3)\n\tfour := NewNode(4)\n\tfive := NewNode(5)\n\tsix := NewNode(6)\n\tbindNodes(one, two)\n\tbindNodes(two, three)\n\tbindNodes(three, four)\n\tbindNodes(four, five)\n\tlinkedList.Head = one\n\tlinkedList.Tail = five\n\n\tlinkedList.SetHead(four)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{5, 3, 2, 1, 4})\n\n\tlinkedList.SetTail(six)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 3, 2, 1, 4})\n\n\tlinkedList.InsertBefore(six, three)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAfter(six, three2)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAtPosition(1, three3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4, 3})\n\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 2, 1, 4})\n\n\tlinkedList.Remove(two)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 1, 4})\n\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(5), true)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc bindNodes(nodeOne *Node, nodeTwo *Node) {\n\tnodeOne.Next = nodeTwo\n\tnodeTwo.Prev = nodeOne\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tone := NewNode(1)\n\ttwo := NewNode(2)\n\tthree := NewNode(3)\n\tthree2 := NewNode(3)\n\tthree3 := NewNode(3)\n\tfour := NewNode(4)\n\tfive := NewNode(5)\n\tsix := NewNode(6)\n\tbindNodes(one, two)\n\tbindNodes(two, three)\n\tbindNodes(three, four)\n\tbindNodes(four, five)\n\tlinkedList.Head = one\n\tlinkedList.Tail = five\n\n\tlinkedList.SetHead(four)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{5, 3, 2, 1, 4})\n\n\tlinkedList.SetTail(six)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 3, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 3, 2, 1, 4})\n\n\tlinkedList.InsertBefore(six, three)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAfter(six, three2)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4})\n\n\tlinkedList.InsertAtPosition(1, three3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 6, 3, 5, 2, 1, 4, 3})\n\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 2, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 2, 1, 4})\n\n\tlinkedList.Remove(two)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{4, 1, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 5, 1, 4})\n\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(5), true)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc bindNodes(nodeOne *Node, nodeTwo *Node) {\n\tnodeOne.Next = nodeTwo\n\tnodeTwo.Prev = nodeOne\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\n// Feel free to add new properties and methods to the class.\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    public void setHead(Node node) {\n      // Write your code here.\n    }\n\n    public void setTail(Node node) {\n      // Write your code here.\n    }\n\n    public void insertBefore(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAfter(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void removeNodesWithValue(int value) {\n      // Write your code here.\n    }\n\n    public void remove(Node node) {\n      // Write your code here.\n    }\n\n    public boolean containsNodeWithValue(int value) {\n      // Write your code here.\n      return false;\n    }\n  }\n\n  // Do not edit the class below.\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    // O(1) time | O(1) space\n    public void setHead(Node node) {\n      if (head == null) {\n        head = node;\n        tail = node;\n        return;\n      }\n      insertBefore(head, node);\n    }\n\n    // O(1) time | O(1) space\n    public void setTail(Node node) {\n      if (tail == null) {\n        setHead(node);\n        return;\n      }\n      insertAfter(tail, node);\n    }\n\n    // O(1) time | O(1) space\n    public void insertBefore(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node.prev;\n      nodeToInsert.next = node;\n      if (node.prev == null) {\n        head = nodeToInsert;\n      } else {\n        node.prev.next = nodeToInsert;\n      }\n      node.prev = nodeToInsert;\n    }\n\n    // O(1) time | O(1) space\n    public void insertAfter(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node;\n      nodeToInsert.next = node.next;\n      if (node.next == null) {\n        tail = nodeToInsert;\n      } else {\n        node.next.prev = nodeToInsert;\n      }\n      node.next = nodeToInsert;\n    }\n\n    // O(p) time | O(1) space\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      if (position == 1) {\n        setHead(nodeToInsert);\n        return;\n      }\n      Node node = head;\n      int currentPosition = 1;\n      while (node != null && currentPosition++ != position) node = node.next;\n      if (node != null) {\n        insertBefore(node, nodeToInsert);\n      } else {\n        setTail(nodeToInsert);\n      }\n    }\n\n    // O(n) time | O(1) space\n    public void removeNodesWithValue(int value) {\n      Node node = head;\n      while (node != null) {\n        Node nodeToRemove = node;\n        node = node.next;\n        if (nodeToRemove.value == value) remove(nodeToRemove);\n      }\n    }\n\n    // O(1) time | O(1) space\n    public void remove(Node node) {\n      if (node == head) head = head.next;\n      if (node == tail) tail = tail.prev;\n      removeNodeBindings(node);\n    }\n\n    // O(n) time | O(1) space\n    public boolean containsNodeWithValue(int value) {\n      Node node = head;\n      while (node != null && node.value != value) node = node.next;\n      return node != null;\n    }\n\n    public void removeNodeBindings(Node node) {\n      if (node.prev != null) node.prev.next = node.next;\n      if (node.next != null) node.next.prev = node.prev;\n      node.prev = null;\n      node.next = null;\n    }\n  }\n\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  private List<Integer> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.next = nodeTwo;\n    nodeTwo.prev = nodeOne;\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.head = one;\n    linkedList.tail = five;\n\n    linkedList.setHead(four);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {5, 3, 2, 1, 4}));\n\n    linkedList.setTail(six);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 3, 2, 1, 4}));\n\n    linkedList.insertBefore(six, three);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 3, 5, 2, 1, 4}));\n\n    linkedList.insertAfter(six, three2);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4}));\n\n    linkedList.insertAtPosition(1, three3);\n    Utils.assertTrue(\n        compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(\n        compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 2, 1, 4}));\n\n    linkedList.remove(two);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 1, 4}));\n\n    Utils.assertTrue(linkedList.containsNodeWithValue(5));\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  private List<Integer> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.next = nodeTwo;\n    nodeTwo.prev = nodeOne;\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.head = one;\n    linkedList.tail = five;\n\n    linkedList.setHead(four);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {5, 3, 2, 1, 4}));\n\n    linkedList.setTail(six);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 3, 2, 1, 4}));\n\n    linkedList.insertBefore(six, three);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 3, 5, 2, 1, 4}));\n\n    linkedList.insertAfter(six, three2);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4}));\n\n    linkedList.insertAtPosition(1, three3);\n    Utils.assertTrue(\n        compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(\n        compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 2, 1, 4}));\n\n    linkedList.remove(two);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 1, 4}));\n\n    Utils.assertTrue(linkedList.containsNodeWithValue(5));\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node) {\n    // Write your code here.\n  }\n\n  setTail(node) {\n    // Write your code here.\n  }\n\n  insertBefore(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAfter(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position, nodeToInsert) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value) {\n    // Write your code here.\n  }\n\n  remove(node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the lines below.\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position, nodeToInsert) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nclass Node(value: Int) {\n    val value = value\n    var prev: Node? = null\n    var next: Node? = null\n}\n\nclass DoublyLinkedList {\n    private var head: Node? = null\n    private var tail: Node? = null\n\n    fun setHead(node: Node) {\n        // Write your code here.\n    }\n\n    fun setTail(node: Node) {\n        // Write your code here.\n    }\n\n    fun insertBefore(node: Node, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun insertAfter(node: Node, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun insertAtPosition(position: Int, nodeToInsert: Node) {\n        // Write your code here.\n    }\n\n    fun removeNodesWithValue(value: Int) {\n        // Write your code here.\n    }\n\n    fun remove(node: Node) {\n        // Write your code here.\n    }\n\n    fun containsNodeWithValue(value: Int): Boolean {\n        // Write your code here.\n        return false\n    }\n\n    fun getHead(): Node? { return this.head }\n\n    fun getTail(): Node? { return this.tail }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nclass Node(value: Int) {\n    val value = value\n    var prev: Node? = null\n    var next: Node? = null\n}\n\nclass DoublyLinkedList {\n    private var head: Node? = null\n    private var tail: Node? = null\n\n    // O(1) time | O(1) space\n    fun setHead(node: Node) {\n        if (this.head == null) {\n            this.head = node\n            this.tail = node\n            return\n        }\n        this.insertBefore(this.head!!, node)\n    }\n\n    // O(1) time | O(1) space\n    fun setTail(node: Node) {\n        if (this.tail == null) {\n            setHead(node)\n            return\n        }\n        insertAfter(this.tail!!, node)\n    }\n\n    // O(1) time | O(1) space\n    fun insertBefore(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == this.tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if (node.prev == null) {\n            this.head = nodeToInsert\n        } else {\n            node.prev!!.next = nodeToInsert\n        }\n        node.prev = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    fun insertAfter(node: Node, nodeToInsert: Node) {\n        if (nodeToInsert == this.head && nodeToInsert == tail) return\n        remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if (node.next == null) {\n            this.tail = nodeToInsert\n        } else {\n            node.next!!.prev = nodeToInsert\n        }\n        node.next = nodeToInsert\n    }\n\n    // O(p) time | O(1) space\n    fun insertAtPosition(position: Int, nodeToInsert: Node) {\n        if (position == 1) {\n            setHead(nodeToInsert)\n            return\n        }\n\n        var node: Node? = this.head\n        var currentPosition = 1\n        while (node != null && currentPosition++ != position) {\n            node = node.next\n        }\n\n        if (node != null) {\n            insertBefore(node, nodeToInsert)\n        } else {\n            setTail(nodeToInsert)\n        }\n    }\n\n    // O(n) time | O(1) space\n    fun removeNodesWithValue(value: Int) {\n        var node: Node? = head\n        while (node != null) {\n            var nextNode = node.next\n            if (node.value == value) remove(node)\n            node = nextNode\n        }\n    }\n\n    // O(1) time | O(1) space\n    fun remove(node: Node) {\n        if (node == this.head) this.head = node.next\n        if (node == this.tail) this.tail = node.prev\n        removeNodeBindings(node)\n    }\n\n    // O(n) time | O(1) space\n    fun containsNodeWithValue(value: Int): Boolean {\n        var node: Node? = this.head\n        while (node != null) {\n            if (node.value == value) return true\n            node = node.next\n        }\n        return false\n    }\n\n    fun removeNodeBindings(node: Node) {\n        if (node.prev != null) node.prev!!.next = node.next\n        if (node.next != null) node.next!!.prev = node.prev\n        node.prev = null\n        node.next = null\n    }\n\n    fun getHead(): Node? { return this.head }\n\n    fun getTail(): Node? { return this.tail }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.DoublyLinkedList\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n\n    fun bindNodes(nodeOne: Node, nodeTwo: Node) {\n        nodeOne.next = nodeTwo\n        nodeTwo.prev = nodeOne\n    }\n\n    fun headToTail(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getHead()\n        while (current != null) {\n            values.add(current.value)\n            current = current.next\n        }\n        return values\n    }\n\n    fun tailToHead(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getTail()\n        while (current != null) {\n            values.add(current.value)\n            current = current.prev\n        }\n        return values\n    }\n\n    @Test\n    fun TestCase1() {\n        val linkedList = DoublyLinkedList()\n\n        val one = Node(1)\n        val two = Node(2)\n        val three = Node(3)\n        val three2 = Node(3)\n        val three3 = Node(3)\n        val four = Node(4)\n        val five = Node(5)\n        val six = Node(6)\n\n        linkedList.setHead(one)\n        linkedList.insertAfter(one, two)\n        linkedList.insertAfter(two, three)\n        linkedList.insertAfter(three, four)\n        linkedList.insertAfter(four, five)\n\n        linkedList.setHead(four)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5))\n        assert(tailToHead(linkedList) == listOf(5, 3, 2, 1, 4))\n\n        linkedList.setTail(six)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 3, 2, 1, 4))\n\n        linkedList.insertBefore(six, three)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6))\n        assert(tailToHead(linkedList) == listOf(6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAfter(six, three2)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAtPosition(1, three3)\n        assert(headToTail(linkedList) == listOf(3, 4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4, 3))\n\n        linkedList.removeNodesWithValue(3)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 2, 1, 4))\n\n        linkedList.remove(two)\n        assert(headToTail(linkedList) == listOf(4, 1, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 1, 4))\n\n        assert(linkedList.containsNodeWithValue(5))\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.DoublyLinkedList\nimport com.algoexpert.program.Node\n\nclass ProgramTest {\n\n    fun bindNodes(nodeOne: Node, nodeTwo: Node) {\n        nodeOne.next = nodeTwo\n        nodeTwo.prev = nodeOne\n    }\n\n    fun headToTail(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getHead()\n        while (current != null) {\n            values.add(current.value)\n            current = current.next\n        }\n        return values\n    }\n\n    fun tailToHead(dll: DoublyLinkedList): List<Int> {\n        val values = mutableListOf<Int>()\n        var current: Node? = dll.getTail()\n        while (current != null) {\n            values.add(current.value)\n            current = current.prev\n        }\n        return values\n    }\n\n    @Test\n    fun TestCase1() {\n        val linkedList = DoublyLinkedList()\n\n        val one = Node(1)\n        val two = Node(2)\n        val three = Node(3)\n        val three2 = Node(3)\n        val three3 = Node(3)\n        val four = Node(4)\n        val five = Node(5)\n        val six = Node(6)\n\n        linkedList.setHead(one)\n        linkedList.insertAfter(one, two)\n        linkedList.insertAfter(two, three)\n        linkedList.insertAfter(three, four)\n        linkedList.insertAfter(four, five)\n\n        linkedList.setHead(four)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5))\n        assert(tailToHead(linkedList) == listOf(5, 3, 2, 1, 4))\n\n        linkedList.setTail(six)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 3, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 3, 2, 1, 4))\n\n        linkedList.insertBefore(six, three)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6))\n        assert(tailToHead(linkedList) == listOf(6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAfter(six, three2)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4))\n\n        linkedList.insertAtPosition(1, three3)\n        assert(headToTail(linkedList) == listOf(3, 4, 1, 2, 5, 3, 6, 3))\n        assert(tailToHead(linkedList) == listOf(3, 6, 3, 5, 2, 1, 4, 3))\n\n        linkedList.removeNodesWithValue(3)\n        assert(headToTail(linkedList) == listOf(4, 1, 2, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 2, 1, 4))\n\n        linkedList.remove(two)\n        assert(headToTail(linkedList) == listOf(4, 1, 5, 6))\n        assert(tailToHead(linkedList) == listOf(6, 5, 1, 4))\n\n        assert(linkedList.containsNodeWithValue(5))\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "# This is an input class. Do not edit.\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\n# Feel free to add new properties and methods to the class.\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def setHead(self, node):\n        # Write your code here.\n        pass\n\n    def setTail(self, node):\n        # Write your code here.\n        pass\n\n    def insertBefore(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAfter(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAtPosition(self, position, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def removeNodesWithValue(self, value):\n        # Write your code here.\n        pass\n\n    def remove(self, node):\n        # Write your code here.\n        pass\n\n    def containsNodeWithValue(self, value):\n        # Write your code here.\n        pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    # O(1) time | O(1) space\n    def setHead(self, node):\n        if self.head is None:\n            self.head = node\n            self.tail = node\n            return\n        self.insertBefore(self.head, node)\n\n    # O(1) time | O(1) space\n    def setTail(self, node):\n        if self.tail is None:\n            self.setHead(node)\n            return\n        self.insertAfter(self.tail, node)\n\n    # O(1) time | O(1) space\n    def insertBefore(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if node.prev is None:\n            self.head = nodeToInsert\n        else:\n            node.prev.next = nodeToInsert\n        node.prev = nodeToInsert\n\n    # O(1) time | O(1) space\n    def insertAfter(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if node.next is None:\n            self.tail = nodeToInsert\n        else:\n            node.next.prev = nodeToInsert\n        node.next = nodeToInsert\n\n    # O(p) time | O(1) space\n    def insertAtPosition(self, position, nodeToInsert):\n        if position == 1:\n            self.setHead(nodeToInsert)\n            return\n        node = self.head\n        currentPosition = 1\n        while node is not None and currentPosition != position:\n            node = node.next\n            currentPosition += 1\n        if node is not None:\n            self.insertBefore(node, nodeToInsert)\n        else:\n            self.setTail(nodeToInsert)\n\n    # O(n) time | O(1) space\n    def removeNodesWithValue(self, value):\n        node = self.head\n        while node is not None:\n            nodeToRemove = node\n            node = node.next\n            if nodeToRemove.value == value:\n                self.remove(nodeToRemove)\n\n    # O(1) time | O(1) space\n    def remove(self, node):\n        if node == self.head:\n            self.head = self.head.next\n        if node == self.tail:\n            self.tail = self.tail.prev\n        self.removeNodeBindings(node)\n\n    # O(n) time | O(1) space\n    def containsNodeWithValue(self, value):\n        node = self.head\n        while node is not None and node.value != value:\n            node = node.next\n        return node is not None\n\n    def removeNodeBindings(self, node):\n        if node.prev is not None:\n            node.prev.next = node.next\n        if node.next is not None:\n            node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nNode = TestNode\nif hasattr(program, "Node"):\n    Node = program.Node\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef bindNodes(nodeOne, nodeTwo):\n    nodeOne.next = nodeTwo\n    nodeTwo.prev = nodeOne\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        one = Node(1)\n        two = Node(2)\n        three = Node(3)\n        three2 = Node(3)\n        three3 = Node(3)\n        four = Node(4)\n        five = Node(5)\n        six = Node(6)\n        bindNodes(one, two)\n        bindNodes(two, three)\n        bindNodes(three, four)\n        bindNodes(four, five)\n        linkedList.head = one\n        linkedList.tail = five\n\n        linkedList.setHead(four)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 3, 2, 1, 4])\n\n        linkedList.setTail(six)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 3, 2, 1, 4])\n\n        linkedList.insertBefore(six, three)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAfter(six, three2)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAtPosition(1, three3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4, 3])\n\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 2, 1, 4])\n\n        linkedList.remove(two)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 1, 4])\n\n        self.assertEqual(linkedList.containsNodeWithValue(5), True)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nNode = TestNode\nif hasattr(program, "Node"):\n    Node = program.Node\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef bindNodes(nodeOne, nodeTwo):\n    nodeOne.next = nodeTwo\n    nodeTwo.prev = nodeOne\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        one = Node(1)\n        two = Node(2)\n        three = Node(3)\n        three2 = Node(3)\n        three3 = Node(3)\n        four = Node(4)\n        five = Node(5)\n        six = Node(6)\n        bindNodes(one, two)\n        bindNodes(two, three)\n        bindNodes(three, four)\n        bindNodes(four, five)\n        linkedList.head = one\n        linkedList.tail = five\n\n        linkedList.setHead(four)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 3, 2, 1, 4])\n\n        linkedList.setTail(six)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 3, 2, 1, 4])\n\n        linkedList.insertBefore(six, three)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAfter(six, three2)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAtPosition(1, three3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4, 3])\n\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 2, 1, 4])\n\n        linkedList.remove(two)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 1, 4])\n\n        self.assertEqual(linkedList.containsNodeWithValue(5), True)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def getNthFib(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.getNthFib\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    func containsNodeWithValue(value: Int) -> Bool {\n      // Write your code here.\n      return false\n    }\n\n    func remove(node: Node) {\n      // Write your code here.\n    }\n\n    func removeNodesWithValue(value: Int) {\n      // Write your code here.\n    }\n\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func setHead(node: Node) {\n      // Write your code here.\n    }\n\n    func setTail(node: Node) {\n      // Write your code here.\n    }\n\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      // Write your code here.\n    }\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    // O(N) time | O(1) space\n    func containsNodeWithValue(value: Int) -> Bool {\n      var node = head\n      while node !== nil, node?.value != value {\n        node = node?.next\n      }\n\n      return node !== nil\n    }\n\n    // O(1) time | O(1) space\n    func remove(node: Node) {\n      if node === head {\n        head = head?.next\n      }\n\n      if node === tail {\n        tail = tail?.previous\n      }\n\n      removeNodeBindings(node: node)\n    }\n\n    // O(N) time | O(1) space\n    func removeNodesWithValue(value: Int) {\n      var node = head\n\n      while node !== nil {\n        let nodeToRemove = node\n        node = node?.next\n        if nodeToRemove?.value == value {\n          remove(node: nodeToRemove!)\n        }\n      }\n    }\n\n    // O(1) time | O(1) space\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node.previous\n      nodeToInsert.next = node\n\n      if node.previous == nil {\n        head = nodeToInsert\n      } else {\n        node.previous?.next = nodeToInsert\n      }\n\n      node.previous = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node\n      nodeToInsert.next = node.next\n\n      if node.next == nil {\n        tail = nodeToInsert\n      } else {\n        node.next?.previous = nodeToInsert\n      }\n\n      node.next = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func setHead(node: Node) {\n      if head == nil {\n        head = node\n        tail = node\n        return\n      }\n\n      insertBefore(node: head!, nodeToInsert: node)\n    }\n\n    // O(1) time | O(1) space\n    func setTail(node: Node) {\n      if tail == nil {\n        setHead(node: node)\n        return\n      }\n\n      insertAfter(node: tail!, nodeToInsert: node)\n    }\n\n    // O(P) time | O(1) space\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      if position == 1 {\n        setHead(node: nodeToInsert)\n        return\n      }\n\n      var node = head\n      var currentPosition = 1\n      while node !== nil, currentPosition != position {\n        node = node?.next\n        currentPosition = currentPosition + 1\n      }\n\n      if node !== nil {\n        insertBefore(node: node!, nodeToInsert: nodeToInsert)\n      } else {\n        setTail(node: nodeToInsert)\n      }\n    }\n\n    func removeNodeBindings(node: Node) {\n      if let previous = node.previous {\n        previous.next = node.next\n      }\n\n      if let next = node.next {\n        next.previous = node.previous\n      }\n\n      node.previous = nil\n      node.next = nil\n    }\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let one = Program.Node(value: 1)\n      let two = Program.Node(value: 2)\n      let three = Program.Node(value: 3)\n      let three2 = Program.Node(value: 3)\n      let three3 = Program.Node(value: 3)\n      let four = Program.Node(value: 4)\n      let five = Program.Node(value: 5)\n      let six = Program.Node(value: 6)\n      bindNodes(nodeOne: one, nodeTwo: two)\n      bindNodes(nodeOne: two, nodeTwo: three)\n      bindNodes(nodeOne: three, nodeTwo: four)\n      bindNodes(nodeOne: four, nodeTwo: five)\n      linkedList.head = one\n      linkedList.tail = five\n\n      linkedList.setHead(node: four)\n      try assertEqual([4, 1, 2, 3, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.setTail(node: six)\n      try assertEqual([4, 1, 2, 3, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertBefore(node: six, nodeToInsert: three)\n      try assertEqual([4, 1, 2, 5, 3, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAfter(node: six, nodeToInsert: three2)\n      try assertEqual([4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: three3)\n      try assertEqual([3, 4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4, 3], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual([4, 1, 2, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.remove(node: two)\n      try assertEqual([4, 1, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 5))\n    }\n  }\n\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func bindNodes(nodeOne: Program.Node, nodeTwo: Program.Node) {\n    nodeOne.next = nodeTwo\n    nodeTwo.previous = nodeOne\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let one = Program.Node(value: 1)\n      let two = Program.Node(value: 2)\n      let three = Program.Node(value: 3)\n      let three2 = Program.Node(value: 3)\n      let three3 = Program.Node(value: 3)\n      let four = Program.Node(value: 4)\n      let five = Program.Node(value: 5)\n      let six = Program.Node(value: 6)\n      bindNodes(nodeOne: one, nodeTwo: two)\n      bindNodes(nodeOne: two, nodeTwo: three)\n      bindNodes(nodeOne: three, nodeTwo: four)\n      bindNodes(nodeOne: four, nodeTwo: five)\n      linkedList.head = one\n      linkedList.tail = five\n\n      linkedList.setHead(node: four)\n      try assertEqual([4, 1, 2, 3, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.setTail(node: six)\n      try assertEqual([4, 1, 2, 3, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertBefore(node: six, nodeToInsert: three)\n      try assertEqual([4, 1, 2, 5, 3, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAfter(node: six, nodeToInsert: three2)\n      try assertEqual([4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: three3)\n      try assertEqual([3, 4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4, 3], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual([4, 1, 2, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.remove(node: two)\n      try assertEqual([4, 1, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 5))\n    }\n  }\n\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func bindNodes(nodeOne: Program.Node, nodeTwo: Program.Node) {\n    nodeOne.next = nodeTwo\n    nodeTwo.previous = nodeOne\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "// This is an input class. Do not edit.\nexport class Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node: Node) {\n    // Write your code here.\n  }\n\n  setTail(node: Node) {\n    // Write your code here.\n  }\n\n  insertBefore(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAfter(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value: number) {\n    // Write your code here.\n  }\n\n  remove(node: Node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value: number) {\n    // Write your code here.\n    return false;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nexport class Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node: Node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node: Node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value: number) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node: Node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value: number) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node: Node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass TestNode {\n  value: number;\n  prev: TestNode | null;\n  next: TestNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne: TestNode, nodeTwo: TestNode) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nclass TestNode {\n  value: number;\n  prev: TestNode | null;\n  next: TestNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne: TestNode, nodeTwo: TestNode) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "nodes",
          example: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-2",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
            {
              id: "5",
              next: null,
              prev: null,
              value: 5,
            },
            {
              id: "6",
              next: null,
              prev: null,
              value: 6,
            },
          ],
          schema: {
            description:
              "You'll be able to reference these nodes by their <span>id</span>\nin the <span>classMethodsToCall</span>.\n",
            items: {
              properties: {
                id: {
                  type: "string",
                },
                next: {
                  type: "null",
                },
                prev: {
                  type: "null",
                },
                value: {
                  type: "integer",
                },
              },
              required: ["id", "value", "prev", "next"],
              type: "object",
            },
            type: "array",
          },
        },
        {
          name: "classMethodsToCall",
          example: [
            {
              arguments: ["5"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["3"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setHead",
            },
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["6"],
              method: "setTail",
            },
            {
              arguments: ["6", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["6", "3-2"],
              method: "insertAfter",
            },
            {
              arguments: [1, "3-3"],
              method: "insertAtPosition",
            },
            {
              arguments: [3],
              method: "removeNodesWithValue",
            },
            {
              arguments: ["2"],
              method: "remove",
            },
            {
              arguments: [5],
              method: "containsNodeWithValue",
            },
          ],
          schema: {
            description:
              "These methods will be called in the order that they appear in below\non a <span>DoublyLinkedList</span> and with their respective arguments.\nFor methods that take in actual <span>Node</span>s as parameters, you can\ncreate <span>nodes</span> below and reference them by their <span>id</span>.\n",
            items: {
              properties: {
                arguments: {
                  maxItems: 2,
                  type: "array",
                },
                method: {
                  enum: [
                    "setHead",
                    "setTail",
                    "insertBefore",
                    "insertAfter",
                    "insertAtPosition",
                    "removeNodesWithValue",
                    "remove",
                    "containsNodeWithValue",
                  ],
                  type: "string",
                },
              },
              required: ["method", "arguments"],
              type: "object",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          classMethodsToCall: [
            {
              arguments: ["5"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["3"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setHead",
            },
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["6"],
              method: "setTail",
            },
            {
              arguments: ["6", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["6", "3-2"],
              method: "insertAfter",
            },
            {
              arguments: [1, "3-3"],
              method: "insertAtPosition",
            },
            {
              arguments: [3],
              method: "removeNodesWithValue",
            },
            {
              arguments: ["2"],
              method: "remove",
            },
            {
              arguments: [5],
              method: "containsNodeWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-2",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
            {
              id: "5",
              next: null,
              prev: null,
              value: 5,
            },
            {
              id: "6",
              next: null,
              prev: null,
              value: 6,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: [1, "1"],
              method: "insertAtPosition",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
            {
              arguments: ["2", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["1"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
            {
              arguments: ["2", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
            {
              arguments: ["1"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "1"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["4", "5"],
              method: "insertAfter",
            },
            {
              arguments: ["5", "6"],
              method: "insertAfter",
            },
            {
              arguments: ["6", "7"],
              method: "insertAfter",
            },
            {
              arguments: [7, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [1, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [2, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [3, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [4, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [5, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [6, "1"],
              method: "insertAtPosition",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
            {
              id: "5",
              next: null,
              prev: null,
              value: 5,
            },
            {
              id: "6",
              next: null,
              prev: null,
              value: 6,
            },
            {
              id: "7",
              next: null,
              prev: null,
              value: 7,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["1"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["4"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["2"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "1-2"],
              method: "insertAfter",
            },
            {
              arguments: ["1-2", "1-3"],
              method: "insertAfter",
            },
            {
              arguments: ["1-3", "1-4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-2",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-3",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-4",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "1-2"],
              method: "insertAfter",
            },
            {
              arguments: ["1-2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "1-3"],
              method: "insertAfter",
            },
            {
              arguments: ["1-3", "4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-2",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-3",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-4",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "containsNodeWithValue",
            },
            {
              arguments: [2],
              method: "containsNodeWithValue",
            },
            {
              arguments: [3],
              method: "containsNodeWithValue",
            },
            {
              arguments: [4],
              method: "containsNodeWithValue",
            },
            {
              arguments: [5],
              method: "containsNodeWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
      ],
      jsonTests: [
        {
          classMethodsToCall: [
            {
              arguments: ["5"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["3"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setHead",
            },
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["4"],
              method: "setHead",
            },
            {
              arguments: ["6"],
              method: "setTail",
            },
            {
              arguments: ["6", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["6", "3-2"],
              method: "insertAfter",
            },
            {
              arguments: [1, "3-3"],
              method: "insertAtPosition",
            },
            {
              arguments: [3],
              method: "removeNodesWithValue",
            },
            {
              arguments: ["2"],
              method: "remove",
            },
            {
              arguments: [5],
              method: "containsNodeWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-2",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "3-3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
            {
              id: "5",
              next: null,
              prev: null,
              value: 5,
            },
            {
              id: "6",
              next: null,
              prev: null,
              value: 6,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: [1, "1"],
              method: "insertAtPosition",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["2"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
            {
              arguments: ["2", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["1"],
              method: "setTail",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setTail",
            },
            {
              arguments: ["1", "2"],
              method: "insertBefore",
            },
            {
              arguments: ["2", "3"],
              method: "insertBefore",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
            {
              arguments: ["1"],
              method: "setHead",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "1"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertBefore",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["4", "5"],
              method: "insertAfter",
            },
            {
              arguments: ["5", "6"],
              method: "insertAfter",
            },
            {
              arguments: ["6", "7"],
              method: "insertAfter",
            },
            {
              arguments: [7, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [1, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [2, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [3, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [4, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [5, "1"],
              method: "insertAtPosition",
            },
            {
              arguments: [6, "1"],
              method: "insertAtPosition",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
            {
              id: "5",
              next: null,
              prev: null,
              value: 5,
            },
            {
              id: "6",
              next: null,
              prev: null,
              value: 6,
            },
            {
              id: "7",
              next: null,
              prev: null,
              value: 7,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["1"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["4"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: ["2"],
              method: "remove",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "1-2"],
              method: "insertAfter",
            },
            {
              arguments: ["1-2", "1-3"],
              method: "insertAfter",
            },
            {
              arguments: ["1-3", "1-4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-2",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-3",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-4",
              next: null,
              prev: null,
              value: 1,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "1-2"],
              method: "insertAfter",
            },
            {
              arguments: ["1-2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "1-3"],
              method: "insertAfter",
            },
            {
              arguments: ["1-3", "4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "removeNodesWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-2",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-3",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "1-4",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
        {
          classMethodsToCall: [
            {
              arguments: ["1"],
              method: "setHead",
            },
            {
              arguments: ["1", "2"],
              method: "insertAfter",
            },
            {
              arguments: ["2", "3"],
              method: "insertAfter",
            },
            {
              arguments: ["3", "4"],
              method: "insertAfter",
            },
            {
              arguments: [1],
              method: "containsNodeWithValue",
            },
            {
              arguments: [2],
              method: "containsNodeWithValue",
            },
            {
              arguments: [3],
              method: "containsNodeWithValue",
            },
            {
              arguments: [4],
              method: "containsNodeWithValue",
            },
            {
              arguments: [5],
              method: "containsNodeWithValue",
            },
          ],
          nodes: [
            {
              id: "1",
              next: null,
              prev: null,
              value: 1,
            },
            {
              id: "2",
              next: null,
              prev: null,
              value: 2,
            },
            {
              id: "3",
              next: null,
              prev: null,
              value: 3,
            },
            {
              id: "4",
              next: null,
              prev: null,
              value: 4,
            },
          ],
        },
      ],
      changelog: [],
      id: 37,
    },
    {
      uid: "minimum-waiting-time",
      testStrategy: "JSON",
      name: "Minimum Waiting Time",
      version: 0,
      releaseDate: "2021-01-19T00:00:00Z",
      category: "Greedy Algorithms",
      difficulty: 1,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 26881,
        failureCount: 10189,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "497547733",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 926,
      },
      prompt:
        "<div class=\"html\">\n<p>\n  You're given a non-empty array of positive integers representing the amounts\n  of time that specific queries take to execute. Only one query can be executed\n  at a time, but the queries can be executed in any order.\n</p>\n<p>\n  A query's <b>waiting time</b> is defined as the amount of time that it must\n  wait before its execution starts. In other words, if a query is executed\n  second, then its waiting time is the duration of the first query; if a query\n  is executed third, then its waiting time is the sum of the durations of the\n  first two queries.\n</p>\n<p>\n  Write a function that returns the minimum amount of total waiting time for all\n  of the queries. For example, if you're given the queries of durations\n  <span>[1, 4, 5]</span>, then the total waiting time if the queries were\n  executed in the order of <span>[5, 1, 4]</span> would be\n  <span>(0) + (5) + (5 + 1) = 11</span>. The first query of duration\n  <span>5</span> would be executed immediately, so its waiting time would be\n  <span>0</span>, the second query of duration <span>1</span> would have to wait\n  <span>5</span> seconds (the duration of the first query) to be executed, and\n  the last query would have to wait the duration of the first two queries before\n  being executed.\n</p>\n<p>Note: you're allowed to mutate the input array.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">queries</span> = [3, 2, 1, 2, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n17\n</pre>\n</div>",
      hints: [
        "<p>\nEven though you don't need to return the actual order in which the queries will be executed to minimize the total waiting time, it's important to determine what this order should be. Start by doing so.\n</p>\n",
        "\n<p>\nCan you solve this problem with constant space? What advantage does being able to mutate the input array provide?\n</p>\n",
        "\n<p>\nSort the input array in place, and execute the shortest queries in their sorted order. This should allow you to calculate the minimum waiting time. \n</p>\n",
        "\n<p>\nCreate a variable to store the total waiting time, and iterate through the sorted input array. At each iteration, multiply the number of queries left by the duration of the current query, and add that to the total waiting time.\n</p>",
      ],
      spaceTime:
        "O(nlogn) time | O(1) space - where n is the number of queries",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nint minimumWaitingTime(vector<int> queries) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// O(nlogn) time | O(1) space - where n is the number of queries\nint minimumWaitingTime(vector<int> queries) {\n  sort(queries.begin(), queries.end());\n\n  int totalWaitingTime = 0;\n  for (int idx = 0; idx < queries.size(); idx++) {\n    int duration = queries[idx];\n    int queriesLeft = queries.size() - (idx + 1);\n    totalWaitingTime += duration * queriesLeft;\n  }\n\n  return totalWaitingTime;\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> queries = {3, 2, 1, 2, 6};\n      int expected = 17;\n      auto actual = minimumWaitingTime(queries);\n      assert(expected == actual);\n    });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1", []() {\n      vector<int> queries = {3, 2, 1, 2, 6};\n      int expected = 17;\n      auto actual = minimumWaitingTime(queries);\n      assert(expected == actual);\n    });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic int MinimumWaitingTime(int[] queries) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System;\nusing System.Linq;\n\n\npublic class Program {\n\n\t// O(nlogn) time | O(1) space - where n is the number of queries\n\tpublic int MinimumWaitingTime(int[] queries) {\n\t\tArray.Sort(queries);\n\n\t\tint totalWaitingTime = 0;\n\t\tfor (int idx = 0; idx < queries.Length; idx++) {\n\t\t\tint duration = queries[idx];\n\t\t\tint queriesLeft = queries.Length - (idx + 1);\n\t\t\ttotalWaitingTime += duration * queriesLeft;\n\t\t}\n\n\t\treturn totalWaitingTime;\n\t}\n}\n\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] queries = new int[] {3, 2, 1, 2, 6};\n\t\tint expected = 17;\n\t\tvar actual = new Program().MinimumWaitingTime(queries);\n\t\tUtils.AssertTrue(actual == expected);\n\t}\n}\n",
          unitTests:
            "using System;\n\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tint[] queries = new int[] {3, 2, 1, 2, 6};\n\t\tint expected = 17;\n\t\tvar actual = new Program().MinimumWaitingTime(queries);\n\t\tUtils.AssertTrue(actual == expected);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc MinimumWaitingTime(queries []int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            '// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\nimport (\n\t"sort"\n)\n\n// O(nlogn) time | O(1) space - where n is the number of queries\nfunc MinimumWaitingTime(queries []int) int {\n\tsort.Ints(queries)\n\n\ttotalWaitingTime := 0\n\tfor idx, duration := range queries {\n\t\tqueriesLeft := len(queries) - (idx + 1)\n\t\ttotalWaitingTime += duration * queriesLeft\n\t}\n\n\treturn totalWaitingTime\n}\n',
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tqueries := []int{3, 2, 1, 2, 6}\n\texpected := 17\n\tactual := MinimumWaitingTime(queries)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tqueries := []int{3, 2, 1, 2, 6}\n\texpected := 17\n\tactual := MinimumWaitingTime(queries)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public int minimumWaitingTime(int[] queries) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(nlogn) time | O(1) space - where n is the number of queries\n  public int minimumWaitingTime(int[] queries) {\n    Arrays.sort(queries);\n\n    int totalWaitingTime = 0;\n    for (int idx = 0; idx < queries.length; idx++) {\n      int duration = queries[idx];\n      int queriesLeft = queries.length - (idx + 1);\n      totalWaitingTime += duration * queriesLeft;\n    }\n\n    return totalWaitingTime;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] queries = new int[] {3, 2, 1, 2, 6};\n    int expected = 17;\n    var actual = new Program().minimumWaitingTime(queries);\n    Utils.assertTrue(actual == expected);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    int[] queries = new int[] {3, 2, 1, 2, 6};\n    int expected = 17;\n    var actual = new Program().minimumWaitingTime(queries);\n    Utils.assertTrue(actual == expected);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function minimumWaitingTime(queries) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.minimumWaitingTime = minimumWaitingTime;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(1) space - where n is the number of queries\nfunction minimumWaitingTime(queries) {\n  queries.sort((a, b) => a - b);\n\n  let totalWaitingTime = 0;\n  for (let idx = 0; idx < queries.length; idx++) {\n    const duration = queries[idx];\n    const queriesLeft = queries.length - (idx + 1);\n    totalWaitingTime += duration * queriesLeft;\n  }\n\n  return totalWaitingTime;\n}\n\n// Do not edit the line below.\nexports.minimumWaitingTime = minimumWaitingTime;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun minimumWaitingTime(queries: MutableList<Int>): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(nlogn) time | O(1) space - where n is the number of queries\nfun minimumWaitingTime(queries: MutableList<Int>): Int {\n    queries.sort()\n\n    var totalWaitingTime = 0\n    for (idx in 0 until queries.size) {\n        val duration = queries[idx]\n        val queriesLeft = queries.size - (idx + 1)\n        totalWaitingTime += duration * queriesLeft\n    }\n\n    return totalWaitingTime\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.minimumWaitingTime\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val queries = mutableListOf(3, 2, 1, 2, 6)\n        val expected = 17\n        val output = minimumWaitingTime(queries)\n        assert(expected == output)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.minimumWaitingTime\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val queries = mutableListOf(3, 2, 1, 2, 6)\n        val expected = 17\n        val output = minimumWaitingTime(queries)\n        assert(expected == output)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def minimumWaitingTime(queries):\n    # Write your code here.\n    return 0\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(nlogn) time | O(1) space - where n is the number of queries\ndef minimumWaitingTime(queries):\n    queries.sort()\n\n    totalWaitingTime = 0\n    for idx, duration in enumerate(queries):\n        queriesLeft = len(queries) - (idx + 1)\n        totalWaitingTime += duration * queriesLeft\n\n    return totalWaitingTime\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        queries = [3, 2, 1, 2, 6]\n        expected = 17\n        actual = program.minimumWaitingTime(queries)\n        self.assertEqual(actual, expected)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        queries = [3, 2, 1, 2, 6]\n        expected = 17\n        actual = program.minimumWaitingTime(queries)\n        self.assertEqual(actual, expected)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def minimumWaitingTime(queries)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minimumWaitingTime(queries)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumWaitingTime\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumWaitingTime\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func minimumWaitingTime(_ queries: inout [Int]) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(nlogn) time | O(1) space - where n is the number of queries\n  func minimumWaitingTime(_ queries: inout [Int]) -> Int {\n    queries.sort()\n\n    var totalWaitingTime = 0\n    for (idx, duration) in queries.enumerated() {\n      let queriesLeft = queries.count - (idx + 1)\n      totalWaitingTime += duration * queriesLeft\n    }\n\n    return totalWaitingTime\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var queries = [3, 2, 1, 2, 6]\n      var expected = 17\n      var actual = Program().minimumWaitingTime(&queries)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var queries = [3, 2, 1, 2, 6]\n      var expected = 17\n      var actual = Program().minimumWaitingTime(&queries)\n      try assertEqual(expected, actual)\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function minimumWaitingTime(queries: number[]) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(nlogn) time | O(1) space - where n is the number of queries\nexport function minimumWaitingTime(queries: number[]) {\n  queries.sort((a, b) => a - b);\n\n  let totalWaitingTime = 0;\n  for (let idx = 0; idx < queries.length; idx++) {\n    const duration = queries[idx];\n    const queriesLeft = queries.length - (idx + 1);\n    totalWaitingTime += duration * queriesLeft;\n  }\n\n  return totalWaitingTime;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "queries",
          example: [3, 2, 1, 2, 6],
          schema: {
            items: {
              minimum: 1,
              type: "integer",
            },
            minItems: 1,
            type: "array",
          },
        },
      ],
      tests: [
        {
          queries: [3, 2, 1, 2, 6],
        },
        {
          queries: [2, 1, 1, 1],
        },
        {
          queries: [1, 2, 4, 5, 2, 1],
        },
        {
          queries: [25, 30, 2, 1],
        },
        {
          queries: [1, 1, 1, 1, 1],
        },
        {
          queries: [7, 9, 2, 3],
        },
        {
          queries: [4, 3, 1, 1, 3, 2, 1, 8],
        },
        {
          queries: [2],
        },
        {
          queries: [7],
        },
        {
          queries: [8, 9],
        },
        {
          queries: [1, 9],
        },
        {
          queries: [5, 4, 3, 2, 1],
        },
        {
          queries: [1, 2, 3, 4, 5],
        },
        {
          queries: [1, 1, 1, 4, 5, 6, 8, 1, 1, 2, 1],
        },
        {
          queries: [17, 4, 3],
        },
      ],
      jsonTests: [
        {
          queries: [3, 2, 1, 2, 6],
        },
        {
          queries: [2, 1, 1, 1],
        },
        {
          queries: [1, 2, 4, 5, 2, 1],
        },
        {
          queries: [25, 30, 2, 1],
        },
        {
          queries: [1, 1, 1, 1, 1],
        },
        {
          queries: [7, 9, 2, 3],
        },
        {
          queries: [4, 3, 1, 1, 3, 2, 1, 8],
        },
        {
          queries: [2],
        },
        {
          queries: [7],
        },
        {
          queries: [8, 9],
        },
        {
          queries: [1, 9],
        },
        {
          queries: [5, 4, 3, 2, 1],
        },
        {
          queries: [1, 2, 3, 4, 5],
        },
        {
          queries: [1, 1, 1, 4, 5, 6, 8, 1, 1, 2, 1],
        },
        {
          queries: [17, 4, 3],
        },
      ],
      changelog: [],
      id: 38,
    },
    {
      uid: "number-of-binary-tree-topologies",
      testStrategy: "JSON",
      name: "Number Of Binary Tree Topologies",
      version: 0,
      releaseDate: "2000-05-04T00:00:00Z",
      category: "Recursion",
      difficulty: 4,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 3937,
        failureCount: 1236,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "262809662",
        duration: 0,
        instructor: "Clement Mihailescu",
        overviewTime: 0,
        codeWalkthroughTime: 2030,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in a non-negative integer <span>n</span> and\n  returns the number of possible Binary Tree topologies that can be created with\n  exactly n nodes.\n</p>\n<p>\n  A Binary Tree topology is defined as any Binary Tree configuration,\n  irrespective of node values. For instance, there exist only two Binary Tree\n  topologies when <span>n</span> is equal to <span>2</span>: a root node with a\n  left node, and a root node with a right node.\n</p>\n<p>\n  Note that when <span>n</span> is equal to <span>0</span>, there\'s one topology\n  that can be created: the <span>None</span> / <span>null</span> node.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n</pre>\n</div>',
      hints: [
        "<p>\nEvery Binary Tree topology of n nodes where n is greater than 0 must have a root node and an amount of nodes on both of its sides totaling n - 1. For instance, one such topology could have a root node, n - 3 nodes in its left subtree, and 2 nodes in its right subtree. Another one could have a root node, 4 nodes in its left subtree, and n - 3 nodes in its right subtree. How many distinct Binary Tree topologies with a root node, a left subtree of x nodes, and a right subtree of n - 1 - x nodes are there?\n</p>\n",
        "\n<p>\nConsider a Binary Tree topology of n nodes with a root node, x nodes in its left subtree, and n - 1 - x nodes in its right subtree, and call this topology T1. This is one of possibly many topologies of n nodes. Realize that for every distinct topology T-Lk of x nodes (i.e. for every distinct topology of T1's left subtree) there is a corresponding, distinct topology of as many nodes as T1. Similarly, for every distinct topology T-Rk of n - 1 - x nodes (i.e. for every distinct topology of T1's right subtree) there is a corresponding, distinct topology of as many nodes as T1. In fact, every unique combination of left and right topologies T-Lk and T-Rk forms a distinct topology of as many nodes as T1, and this is true for every x between 0 and n - 1. Realizing this, can you implement a recursive algorithm that solves this problem?\n</p>\n",
        "\n<p>\nIterate through every number x between 0 and n - 1 inclusive; at every number x, recursively calculate the number of distinct topologies of x nodes and multiply that by the number of distinct topologies of n - 1 - x nodes. Sum all of the products that you calculate to find the total number of distinct topologies of n nodes.\n</p>\n",
        "\n<p>\nCan you improve the recursive algorithm mentioned in Hints #2 and #3 by using a caching system (memoization)? Can you implement the algorithm iteratively? Is there any advantage to doing so?\n</p>",
      ],
      spaceTime: "O(n^2) time | O(n) space - where n is the input number",
      notes: "",
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "using namespace std;\n\nint numberOfBinaryTreeTopologies(int n) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nint numberOfBinaryTreeTopologies(int n) {\n  if (n == 0) {\n    return 1;\n  }\n  int numberOfTrees = 0;\n  for (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    int rightTreeSize = n - 1 - leftTreeSize;\n    int numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize);\n    int numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  return numberOfTrees;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <unordered_map>\nusing namespace std;\n\nint helper(int n, unordered_map<int, int> *cache);\n\n// O(n^2) time | O(n) space\nint numberOfBinaryTreeTopologies(int n) {\n  unordered_map<int, int> cache{{0, 1}};\n  return helper(n, &cache);\n}\n\nint helper(int n, unordered_map<int, int> *cache) {\n  if (cache->find(n) != cache->end()) {\n    return cache->at(n);\n  }\n  int numberOfTrees = 0;\n  for (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    int rightTreeSize = n - 1 - leftTreeSize;\n    int numberOfLeftTrees = helper(leftTreeSize, cache);\n    int numberOfRightTrees = helper(rightTreeSize, cache);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  cache->insert({n, numberOfTrees});\n  return numberOfTrees;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing namespace std;\n\n// O(n^2) time | O(n) space\nint numberOfBinaryTreeTopologies(int n) {\n  vector<int> cache{1};\n  for (int m = 1; m < n + 1; m++) {\n    int numberOfTrees = 0;\n    for (int leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n      int rightTreeSize = m - 1 - leftTreeSize;\n      int numberOfLeftTrees = cache[leftTreeSize];\n      int numberOfRightTrees = cache[rightTreeSize];\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    cache.push_back(numberOfTrees);\n  }\n  return cache[n];\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(numberOfBinaryTreeTopologies(3) == 5); });\n  }\n};\n',
          unitTests:
            'class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest("Test Case 1",\n            []() { assert(numberOfBinaryTreeTopologies(3) == 5); });\n  }\n};\n',
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\npublic class Program {\n\tpublic static int NumberOfBinaryTreeTopologies(int n) {\n\t\t// Write your code here.\n\t\treturn -1;\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npublic class Program {\n\t// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\n\tpublic static int NumberOfBinaryTreeTopologies(int n) {\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint numberOfTrees = 0;\n\t\tfor (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n\t\t\tint rightTreeSize = n - 1 - leftTreeSize;\n\t\t\tint numberOfLeftTrees = NumberOfBinaryTreeTopologies(leftTreeSize);\n\t\t\tint numberOfRightTrees = NumberOfBinaryTreeTopologies(rightTreeSize);\n\t\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n\t\t}\n\t\treturn numberOfTrees;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n^2) time | O(n) space\n\tpublic static int NumberOfBinaryTreeTopologies(int n) {\n\t\tDictionary<int, int> cache = new Dictionary<int, int>();\n\t\tcache.Add(0, 1);\n\t\treturn NumberOfBinaryTreeTopologies(n, cache);\n\t}\n\n\tpublic static int NumberOfBinaryTreeTopologies(int n, Dictionary<int, int> cache) {\n\t\tif (cache.ContainsKey(n)) {\n\t\t\treturn cache[n];\n\t\t}\n\t\tint numberOfTrees = 0;\n\t\tfor (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n\t\t\tint rightTreeSize = n - 1 - leftTreeSize;\n\t\t\tint numberOfLeftTrees = NumberOfBinaryTreeTopologies(leftTreeSize, cache);\n\t\t\tint numberOfRightTrees = NumberOfBinaryTreeTopologies(rightTreeSize, cache);\n\t\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n\t\t}\n\t\tcache.Add(n, numberOfTrees);\n\t\treturn numberOfTrees;\n\t}\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(n^2) time | O(n) space\n\tpublic static int NumberOfBinaryTreeTopologies(int n) {\n\t\tList<int> cache = new List<int>();\n\t\tcache.Add(1);\n\t\tfor (int m = 1; m < n + 1; m++) {\n\t\t\tint numberOfTrees = 0;\n\t\t\tfor (int leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n\t\t\t\tint rightTreeSize = m - 1 - leftTreeSize;\n\t\t\t\tint numberOfLeftTrees = cache[leftTreeSize];\n\t\t\t\tint numberOfRightTrees = cache[rightTreeSize];\n\t\t\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n\t\t\t}\n\t\t\tcache.Add(numberOfTrees);\n\t\t}\n\t\treturn cache[n];\n\t}\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.NumberOfBinaryTreeTopologies(3) == 5);\n\t}\n}\n",
          unitTests:
            "public class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tUtils.AssertTrue(Program.NumberOfBinaryTreeTopologies(3) == 5);\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc NumberOfBinaryTreeTopologies(n int) int {\n\t// Write your code here.\n\treturn -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nfunc NumberOfBinaryTreeTopologies(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tnumberOfTrees := 0\n\tfor leftTreeSize := 0; leftTreeSize < n; leftTreeSize++ {\n\t\trightTreeSize := n - 1 - leftTreeSize\n\t\tnumberOfLeftTrees := NumberOfBinaryTreeTopologies(leftTreeSize)\n\t\tnumberOfRightTrees := NumberOfBinaryTreeTopologies(rightTreeSize)\n\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees\n\t}\n\treturn numberOfTrees\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space\nfunc NumberOfBinaryTreeTopologies(n int) int {\n\treturn helper(n, map[int]int{0: 1})\n}\n\nfunc helper(n int, cache map[int]int) int {\n\tif val, found := cache[n]; found {\n\t\treturn val\n\t}\n\tnumberOfTrees := 0\n\tfor leftTreeSize := 0; leftTreeSize < n; leftTreeSize++ {\n\t\trightTreeSize := n - 1 - leftTreeSize\n\t\tnumberOfLeftTrees := helper(leftTreeSize, cache)\n\t\tnumberOfRightTrees := helper(rightTreeSize, cache)\n\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees\n\t}\n\tcache[n] = numberOfTrees\n\treturn numberOfTrees\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n^2) time | O(n) space\nfunc NumberOfBinaryTreeTopologies(n int) int {\n\tcache := []int{1}\n\tfor m := 1; m < n+1; m++ {\n\t\tnumberOfTrees := 0\n\t\tfor leftTreeSize := 0; leftTreeSize < m; leftTreeSize++ {\n\t\t\trightTreeSize := m - 1 - leftTreeSize\n\t\t\tnumberOfLeftTrees := cache[leftTreeSize]\n\t\t\tnumberOfRightTrees := cache[rightTreeSize]\n\t\t\tnumberOfTrees += numberOfLeftTrees * numberOfRightTrees\n\t\t}\n\t\tcache = append(cache, numberOfTrees)\n\t}\n\treturn cache[n]\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 5\n\toutput := NumberOfBinaryTreeTopologies(3)\n\trequire.Equal(t, expected, output)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := 5\n\toutput := NumberOfBinaryTreeTopologies(3)\n\trequire.Equal(t, expected, output)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n  public static int numberOfBinaryTreeTopologies(int n) {\n    // Write your code here.\n    return -1;\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\n  public static int numberOfBinaryTreeTopologies(int n) {\n    if (n == 0) {\n      return 1;\n    }\n    int numberOfTrees = 0;\n    for (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n      int rightTreeSize = n - 1 - leftTreeSize;\n      int numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize);\n      int numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize);\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    return numberOfTrees;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space\n  public static int numberOfBinaryTreeTopologies(int n) {\n    Map<Integer, Integer> cache = new HashMap<Integer, Integer>();\n    cache.put(0, 1);\n    return numberOfBinaryTreeTopologies(n, cache);\n  }\n\n  public static int numberOfBinaryTreeTopologies(int n, Map<Integer, Integer> cache) {\n    if (cache.containsKey(n)) {\n      return cache.get(n);\n    }\n    int numberOfTrees = 0;\n    for (int leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n      int rightTreeSize = n - 1 - leftTreeSize;\n      int numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache);\n      int numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache);\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    cache.put(n, numberOfTrees);\n    return numberOfTrees;\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(n^2) time | O(n) space\n  public static int numberOfBinaryTreeTopologies(int n) {\n    List<Integer> cache = new ArrayList<Integer>();\n    cache.add(1);\n    for (int m = 1; m < n + 1; m++) {\n      int numberOfTrees = 0;\n      for (int leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n        int rightTreeSize = m - 1 - leftTreeSize;\n        int numberOfLeftTrees = cache.get(leftTreeSize);\n        int numberOfRightTrees = cache.get(rightTreeSize);\n        numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n      }\n      cache.add(numberOfTrees);\n    }\n    return cache.get(n);\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.numberOfBinaryTreeTopologies(3) == 5);\n  }\n}\n",
          unitTests:
            "class ProgramTest {\n  @Test\n  public void TestCase1() {\n    Utils.assertTrue(Program.numberOfBinaryTreeTopologies(3) == 5);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function numberOfBinaryTreeTopologies(n) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n) {\n  if (n === 0) return 1;\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  return numberOfTrees;\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n, cache = {0: 1}) {\n  if (n in cache) return cache[n];\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  cache[n] = numberOfTrees;\n  return numberOfTrees;\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n) {\n  const cache = [1];\n  for (let m = 1; m < n + 1; m++) {\n    let numberOfTrees = 0;\n    for (let leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n      const rightTreeSize = m - 1 - leftTreeSize;\n      const numberOfLeftTrees = cache[leftTreeSize];\n      const numberOfRightTrees = cache[rightTreeSize];\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    cache.push(numberOfTrees);\n  }\n  return cache[n];\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun numberOfBinaryTreeTopologies(n: Int): Int {\n    // Write your code here.\n    return -1\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nfun numberOfBinaryTreeTopologies(n: Int): Int {\n    if (n == 0) {\n        return 1\n    }\n    var numberOfTrees = 0\n    for (leftTreeSize in 0 until n) {\n        val rightTreeSize = n - 1 - leftTreeSize\n        val numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize)\n        val numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize)\n        numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n    }\n    return numberOfTrees\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space\nfun numberOfBinaryTreeTopologies(n: Int): Int {\n    val cache = mutableMapOf<Int, Int>()\n    cache[0] = 1\n    return numberOfBinaryTreeTopologies(n, cache)\n}\n\nfun numberOfBinaryTreeTopologies(n: Int, cache: MutableMap<Int, Int>): Int {\n    if (cache.contains(n)) {\n        return cache[n]!!\n    }\n\n    var numberOfTrees = 0\n    for (leftTreeSize in 0 until n) {\n        val rightTreeSize = n - 1 - leftTreeSize\n        val numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache)\n        val numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache)\n        numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n    }\n    cache[n] = numberOfTrees\n    return numberOfTrees\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\n// O(n^2) time | O(n) space\nfun numberOfBinaryTreeTopologies(n: Int): Int {\n    val cache = mutableListOf<Int>(1)\n    for (m in 1 until n + 1) {\n        var numberOfTrees = 0\n        for (leftTreeSize in 0 until m) {\n            val rightTreeSize = m - 1 - leftTreeSize\n            val numberOfLeftTrees = cache[leftTreeSize]\n            val numberOfRightTrees = cache[rightTreeSize]\n            numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n        }\n        cache.add(numberOfTrees)\n    }\n    return cache[n]\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.numberOfBinaryTreeTopologies\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val output = numberOfBinaryTreeTopologies(3)\n        assert(output == 5)\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.numberOfBinaryTreeTopologies\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val output = numberOfBinaryTreeTopologies(3)\n        assert(output == 5)\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def numberOfBinaryTreeTopologies(n):\n    # Write your code here.\n    pass\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\ndef numberOfBinaryTreeTopologies(n):\n    if n == 0:\n        return 1\n    numberOfTrees = 0\n    for leftTreeSize in range(n):\n        rightTreeSize = n - 1 - leftTreeSize\n        numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize)\n        numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize)\n        numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n    return numberOfTrees\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space\ndef numberOfBinaryTreeTopologies(n, cache={0: 1}):\n    if n in cache:\n        return cache[n]\n    numberOfTrees = 0\n    for leftTreeSize in range(n):\n        rightTreeSize = n - 1 - leftTreeSize\n        numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache)\n        numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache)\n        numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n    cache[n] = numberOfTrees\n    return numberOfTrees\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n^2) time | O(n) space\ndef numberOfBinaryTreeTopologies(n):\n    cache = [1]\n    for m in range(1, n + 1):\n        numberOfTrees = 0\n        for leftTreeSize in range(m):\n            rightTreeSize = m - 1 - leftTreeSize\n            numberOfLeftTrees = cache[leftTreeSize]\n            numberOfRightTrees = cache[rightTreeSize]\n            numberOfTrees += numberOfLeftTrees * numberOfRightTrees\n        cache.append(numberOfTrees)\n    return cache[n]\n",
          ],
          sandboxCode:
            "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.numberOfBinaryTreeTopologies(3), 5)\n",
          unitTests:
            "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(program.numberOfBinaryTreeTopologies(3), 5)\n",
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: true,
          startingCode:
            "class Program\n  def numberOfBinaryTreeTopologies(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def numberOfBinaryTreeTopologies(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def numberOfBinaryTreeTopologies(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def numberOfBinaryTreeTopologies(n)\n    # Write your code here.\n    return -1\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.numberOfBinaryTreeTopologies\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.numberOfBinaryTreeTopologies\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func numberOfBinaryTreeTopologies(_ n: Int) -> Int {\n    // Write your code here.\n    return -1\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // Upper Bound: (O(n * (2n)!)/(n!(n + 1)!)) time | O(n) space\n  func numberOfBinaryTreeTopologies(_ n: Int) -> Int {\n    if n == 0 {\n      return 1\n    }\n\n    var numberOfTopologies = 0\n\n    for leftTreeSize in 0 ..< n {\n      let rightTreeSize = n - 1 - leftTreeSize\n\n      let leftNumberOfTopologies = numberOfBinaryTreeTopologies(leftTreeSize)\n      let rightNumberOfTopologies = numberOfBinaryTreeTopologies(rightTreeSize)\n      numberOfTopologies += leftNumberOfTopologies * rightNumberOfTopologies\n    }\n\n    return numberOfTopologies\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(1) space\n  func numberOfBinaryTreeTopologies(_ n: Int) -> Int {\n    var cache = [0: 1]\n    return numberOfBinaryTreeTopologiesHelper(n, &cache)\n  }\n\n  func numberOfBinaryTreeTopologiesHelper(_ n: Int, _ cache: inout [Int: Int]) -> Int {\n    if let cachedValue = cache[n] {\n      return cachedValue\n    }\n\n    var numberOfTopologies = 0\n\n    for leftTreeSize in 0 ..< n {\n      let rightTreeSize = n - 1 - leftTreeSize\n\n      let leftNumberOfTopologies = numberOfBinaryTreeTopologiesHelper(leftTreeSize, &cache)\n      let rightNumberOfTopologies = numberOfBinaryTreeTopologiesHelper(rightTreeSize, &cache)\n      numberOfTopologies += leftNumberOfTopologies * rightNumberOfTopologies\n    }\n\n    cache[n] = numberOfTopologies\n    return numberOfTopologies\n  }\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n^2) time | O(1) space\n  func numberOfBinaryTreeTopologies(_ n: Int) -> Int {\n    var cache = [1]\n\n    for currentMax in stride(from: 1, through: n, by: 1) {\n      var numberOfTopologies = 0\n\n      for leftTreeSize in stride(from: 0, to: currentMax, by: 1) {\n        let rightTreeSize = currentMax - 1 - leftTreeSize\n\n        let leftNumberOfTopologies = cache[leftTreeSize]\n        let rightNumberOfTopologies = cache[rightTreeSize]\n        numberOfTopologies += leftNumberOfTopologies * rightNumberOfTopologies\n      }\n\n      cache.append(numberOfTopologies)\n    }\n\n    return cache[n]\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(5, program.numberOfBinaryTreeTopologies(3))\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest("Test Case 1") { () throws -> Void in\n      try assertEqual(5, program.numberOfBinaryTreeTopologies(3))\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function numberOfBinaryTreeTopologies(n: number) {\n  // Write your code here.\n  return -1;\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nexport function numberOfBinaryTreeTopologies(n: number) {\n  if (n === 0) return 1;\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  return numberOfTrees;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface Cache {\n  [key: number]: number;\n}\n\n// O(n^2) time | O(n) space\nexport function numberOfBinaryTreeTopologies(n: number, cache: Cache = {0: 1}) {\n  if (n in cache) return cache[n];\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  cache[n] = numberOfTrees;\n  return numberOfTrees;\n}\n",
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n^2) time | O(n) space\nexport function numberOfBinaryTreeTopologies(n: number) {\n  const cache = [1];\n  for (let m = 1; m < n + 1; m++) {\n    let numberOfTrees = 0;\n    for (let leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n      const rightTreeSize = m - 1 - leftTreeSize;\n      const numberOfLeftTrees = cache[leftTreeSize];\n      const numberOfRightTrees = cache[rightTreeSize];\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    cache.push(numberOfTrees);\n  }\n  return cache[n];\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "n",
          example: 3,
          schema: {
            minimum: 0,
            type: "integer",
          },
        },
      ],
      tests: [
        {
          n: 3,
        },
        {
          n: 0,
        },
        {
          n: 1,
        },
        {
          n: 2,
        },
        {
          n: 4,
        },
        {
          n: 5,
        },
        {
          n: 6,
        },
        {
          n: 7,
        },
        {
          n: 8,
        },
        {
          n: 9,
        },
        {
          n: 10,
        },
        {
          n: 11,
        },
      ],
      jsonTests: [
        {
          n: 3,
        },
        {
          n: 0,
        },
        {
          n: 1,
        },
        {
          n: 2,
        },
        {
          n: 4,
        },
        {
          n: 5,
        },
        {
          n: 6,
        },
        {
          n: 7,
        },
        {
          n: 8,
        },
        {
          n: 9,
        },
        {
          n: 10,
        },
        {
          n: 11,
        },
      ],
      changelog: [],
      id: 39,
    },
    {
      uid: "minimum-characters-for-words",
      testStrategy: "JSON",
      name: "Minimum Characters For Words",
      version: 0,
      releaseDate: "2021-05-17T00:00:00Z",
      category: "Strings",
      difficulty: 2,
      acl: {
        isFree: false,
        productRequired: ["algoexpert"],
        isAvailable: true,
      },
      languagesSupported: [
        "cpp",
        "csharp",
        "go",
        "java",
        "javascript",
        "kotlin",
        "swift",
        "python",
        "typescript",
      ],
      submissionStatistics: {
        correctCount: 6946,
        failureCount: 1310,
      },
      assessmentSummary: null,
      video: {
        vimeoId: "535393659",
        duration: 0,
        instructor: "Tim Ruscica",
        overviewTime: 0,
        codeWalkthroughTime: 1190,
      },
      prompt:
        '<div class="html">\n<p>\n  Write a function that takes in an array of words and returns the smallest\n  array of characters needed to form all of the words. The characters don\'t need\n  to be in any particular order.\n</p>\n<p>\n  For example, the characters <span>["y", "r", "o", "u"]</span> are needed to\n  form the words <span>["your", "you", "or", "yo"]</span>.\n</p>\n<p>\n  Note: the input words won\'t contain any spaces; however, they might contain\n  punctuation and/or special characters.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">words</span> = ["this", "that", "did", "deed", "them!", "a"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n<span class="CodeEditor-promptComment">// The characters could be ordered differently.</span>\n</pre>\n</div>',
      hints: [
        "<p>\n  There are a few different ways to solve this problem, but all of them use the\n  same general approach. You'll need to determine not only all of the unique\n  characters required to form the input words, but also their required\n  frequencies. What determines the required frequencies of characters to form\n  multiple words?\n</p>\n",
        '\n<p>\n  The word that contains the highest frequency of any character dictates how\n  many of those characters are required. For example, given\n  <span>words = ["A", "AAAA"]</span> you need 4 <span>A</span>s, because the\n  word that contains the most of amount of <span>A</span>s has 4.\n</p>\n',
        "\n<p>\n  Use a hash table to keep track of the maximum frequencies of all unique\n  characters that occur across all words. Count the frequency of each character\n  in each word, and use those per-word frequencies to update your\n  maximum-character-frequency hash table. Once you've determined the maximum\n  frequency of each character across all words, you can use the built-up hash\n  table to generate your output array.\n</p>",
      ],
      spaceTime:
        "O(n * l) time | O(c) space - where n is the number of words, l is the length of the longest word, and c is the number of unique characters across all words\nSee notes under video explanation for details about the space complexity.",
      notes:
        '<div class="html">\n<p>\n  The space complexity of <span>O(c)</span>, where <span>c</span> is the number\n  of unique characters across all words, is actually a lower bound for our\n  solution\'s space complexity.\n</p>\n<p>\n  This is because the <span>maximumCharacterFrequencies</span> hash table will\n  take up <span>O(c)</span> space, but the output array of characters might take\n  up more space if some unique characters appear multiple times in a single\n  word. For example, we might have a hash table <span>{"a": 3"}</span> with one\n  character but an output array <span>["a", "a", "a"]</span> with three\n  characters.\n</p>\n<p>\n  An upper bound for the space complexity is <span>O(n * l)</span>, which\n  happens when every single character in each word is unique across all words\n  and the output array therefore contains <span>n * l</span> characters.\n</p>\n</div>',
      isSlowExecution: false,
      isLongOutput: false,
      visualization: {
        inputType: null,
        outputType: null,
      },
      resources: {
        cpp: {
          language: "cpp",
          solutionsDisabled: false,
          startingCode:
            "#include <vector>\nusing namespace std;\n\nvector<char> minimumCharactersForWords(vector<string> words) {\n  // Write your code here.\n  return {};\n}",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nunordered_map<char, int> countCharacterFrequencies(const string &string);\nvoid updateMaximumFrequencies(const unordered_map<char, int> &frequencies,\n                              unordered_map<char, int> &maximumFrequencies);\nvector<char> makeArrayFromCharacterFrequencies(\n    const unordered_map<char, int> &characterFrequencies);\n\n// O(n * l) time | O(c) space - where n is the number of words,\n// l is the length of the longest word, and c is the number of\n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nvector<char> minimumCharactersForWords(vector<string> words) {\n  unordered_map<char, int> maximumCharacterFrequencies;\n\n  for (auto const &word : words) {\n    auto characterFrequencies = countCharacterFrequencies(word);\n    updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies);\n  }\n\n  return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies);\n}\n\nunordered_map<char, int> countCharacterFrequencies(const string &string) {\n  unordered_map<char, int> characterFrequencies;\n\n  for (auto character : string) {\n    if (characterFrequencies.find(character) == characterFrequencies.end()) {\n      characterFrequencies[character] = 0;\n    }\n\n    characterFrequencies[character] += 1;\n  }\n\n  return characterFrequencies;\n}\n\nvoid updateMaximumFrequencies(const unordered_map<char, int> &frequencies,\n                              unordered_map<char, int> &maximumFrequencies) {\n  for (const auto &[character, frequency] : frequencies) {\n    if (maximumFrequencies.find(character) != maximumFrequencies.end()) {\n      maximumFrequencies[character] =\n          max(frequency, maximumFrequencies[character]);\n    } else {\n      maximumFrequencies[character] = frequency;\n    }\n  }\n}\n\nvector<char> makeArrayFromCharacterFrequencies(\n    const unordered_map<char, int> &characterFrequencies) {\n  vector<char> characters;\n\n  for (const auto &[character, frequency] : characterFrequencies) {\n    for (int idx = 0; idx < frequency; idx++) {\n      characters.push_back(character);\n    }\n  }\n\n  return characters;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> input = {\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\"};\n      vector<char> expected = {'t', 't', 'h', 'i', 's', 'a',\n                               'd', 'd', 'e', 'e', 'm', '!'};\n      auto actual = minimumCharactersForWords(input);\n      sort(actual.begin(), actual.end());\n      sort(expected.begin(), expected.end());\n      assert(expected == actual);\n    });\n  }\n};\n",
          unitTests:
            "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<string> input = {\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\"};\n      vector<char> expected = {'t', 't', 'h', 'i', 's', 'a',\n                               'd', 'd', 'e', 'e', 'm', '!'};\n      auto actual = minimumCharactersForWords(input);\n      sort(actual.begin(), actual.end());\n      sort(expected.begin(), expected.end());\n      assert(expected == actual);\n    });\n  }\n};\n",
        },
        csharp: {
          language: "csharp",
          solutionsDisabled: false,
          startingCode:
            "using System;\n\n\npublic class Program {\n\n\tpublic string[] MinimumCharactersForWords(string[] words) {\n\t\t// Write your code here.\n\t\treturn new string[] {};\n\t}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nusing System.Collections.Generic;\nusing System;\n\n\npublic class Program {\n\n\t// O(n * l) time | O(c) space - where n is the number of words,\n\t// l is the length of the longest word, and c is the number of\n\t// unique characters across all words\n\t// See notes under video explanation for details about the space complexity.\n\tpublic char[] MinimumCharactersForWords(string[] words) {\n\t\tDictionary<char, int> maximumCharFrequencies = new Dictionary<char, int>();\n\n\t\tforeach (var word in words) {\n\t\t\tDictionary<char, int> characterFrequencies = countCharFrequencies(word);\n\t\t\tupdateMaximumFrequencies(characterFrequencies, maximumCharFrequencies);\n\t\t}\n\n\t\treturn makeArrayFromCharFrequencies(maximumCharFrequencies);\n\t}\n\n\tpublic Dictionary<char, int> countCharFrequencies(string str) {\n\t\tDictionary<char, int> characterFrequencies = new Dictionary<char, int>();\n\n\t\tforeach (var character in str.ToCharArray()) {\n\t\t\tcharacterFrequencies[character] = characterFrequencies.GetValueOrDefault(\n\t\t\t\tcharacter, 0) + 1;\n\t\t}\n\n\t\treturn characterFrequencies;\n\t}\n\n\tpublic void updateMaximumFrequencies(Dictionary<char, int> frequencies,\n\t  Dictionary<char, int> maximumFrequencies) {\n\n\t\tforeach (var frequency in frequencies) {\n\t\t\tchar character = frequency.Key;\n\t\t\tint characterFrequency = frequency.Value;\n\n\t\t\tif (maximumFrequencies.ContainsKey(character)) {\n\t\t\t\tmaximumFrequencies[character] = Math.Max(characterFrequency,\n\t\t\t\t    maximumFrequencies[\n\t\t\t\t\t    character]);\n\t\t\t} else {\n\t\t\t\tmaximumFrequencies[character] = characterFrequency;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic char[] makeArrayFromCharFrequencies(Dictionary<char, int> characterFrequencies) {\n\t\tList<char> characters = new List<char>();\n\n\t\tforeach (var frequency in characterFrequencies) {\n\t\t\tchar character = frequency.Key;\n\t\t\tint characterFrequency = frequency.Value;\n\n\t\t\tfor (int idx = 0; idx < characterFrequency; idx++) {\n\t\t\t\tcharacters.Add(character);\n\t\t\t}\n\t\t}\n\n\t\tchar[] charactersArray = new char[characters.Count];\n\t\tfor (int idx = 0; idx < characters.Count; idx++) {\n\t\t\tcharactersArray[idx] = characters[idx];\n\t\t}\n\n\t\treturn charactersArray;\n\t}\n\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System;\nusing System.Linq;\n\n\npublic class ProgramTest {\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring[] words = new string[] { \"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\" };\n\t\tchar[] expected =\n\t\t  new char[] { 't', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!' };\n\t\tvar actual = new Program().MinimumCharactersForWords(words);\n\t\tUtils.AssertTrue(expected.SequenceEqual(actual));\n\t}\n}\n",
          unitTests:
            "using System;\nusing System.Linq;\n\n\npublic class ProgramTest {\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tstring[] words = new string[] { \"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\" };\n\t\tchar[] expected =\n\t\t  new char[] { 't', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!' };\n\t\tvar actual = new Program().MinimumCharactersForWords(words);\n\t\tUtils.AssertTrue(expected.SequenceEqual(actual));\n\t}\n}\n",
        },
        go: {
          language: "go",
          solutionsDisabled: false,
          startingCode:
            "package main\n\nfunc MinimumCharactersForWords(words []string) []string {\n\t// Write your code here.\n\treturn []string{}\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage main\n\n// O(n * l) time | O(c) space - where n is the number of words,\n// l is the length of the longest word, and c is the number of\n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nfunc MinimumCharactersForWords(words []string) []string {\n\tmaximumCharacterFrequencies := map[rune]int{}\n\n\tfor _, word := range words {\n\t\tcharacterFrequencies := countCharacterFrequencies(word)\n\t\tupdateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies)\n\t}\n\n\treturn makeArrayFromCharacterFrequencies(maximumCharacterFrequencies)\n}\n\nfunc countCharacterFrequencies(str string) map[rune]int {\n\tcharacterFrequencies := map[rune]int{}\n\tfor _, character := range str {\n\t\tcharacterFrequencies[character] += 1\n\t}\n\treturn characterFrequencies\n}\n\nfunc updateMaximumFrequencies(frequencies map[rune]int, maximumFrequencies map[rune]int) {\n\tfor character, frequency := range frequencies {\n\t\tif maxFrequency, found := maximumFrequencies[character]; found {\n\t\t\tmaximumFrequencies[character] = max(frequency, maxFrequency)\n\t\t} else {\n\t\t\tmaximumFrequencies[character] = frequency\n\t\t}\n\t}\n}\n\nfunc makeArrayFromCharacterFrequencies(characterFrequencies map[rune]int) []string {\n\tcharacters := make([]string, 0)\n\tfor character, frequency := range characterFrequencies {\n\t\tfor i := 0; i < frequency; i++ {\n\t\t\tcharacters = append(characters, string(character))\n\t\t}\n\t}\n\treturn characters\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t"sort"\n\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{"this", "that", "did", "deed", "them!", "a"}\n\texpected := []string{"t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"}\n\tactual := MinimumCharactersForWords(input)\n\tsort.Strings(actual)\n\tsort.Strings(expected)\n\trequire.Equal(t, expected, actual)\n}\n',
          unitTests:
            'package main\n\nimport (\n\t"sort"\n\n\t"github.com/stretchr/testify/require"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tinput := []string{"this", "that", "did", "deed", "them!", "a"}\n\texpected := []string{"t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"}\n\tactual := MinimumCharactersForWords(input)\n\tsort.Strings(actual)\n\tsort.Strings(expected)\n\trequire.Equal(t, expected, actual)\n}\n',
        },
        java: {
          language: "java",
          solutionsDisabled: false,
          startingCode:
            "import java.util.*;\n\nclass Program {\n\n  public char[] minimumCharactersForWords(String[] words) {\n    // Write your code here.\n    return new char[] {};\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n\n  // O(n * l) time | O(c) space - where n is the number of words,\n  // l is the length of the longest word, and c is the number of\n  // unique characters across all words\n  // See notes under video explanation for details about the space complexity.\n  public char[] minimumCharactersForWords(String[] words) {\n    HashMap<Character, Integer> maximumCharacterFrequencies = new HashMap<Character, Integer>();\n\n    for (String word : words) {\n      HashMap<Character, Integer> characterFrequencies = countCharacterFrequencies(word);\n      updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies);\n    }\n\n    return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies);\n  }\n\n  public HashMap<Character, Integer> countCharacterFrequencies(String string) {\n    HashMap<Character, Integer> characterFrequencies = new HashMap<Character, Integer>();\n\n    for (char character : string.toCharArray()) {\n      characterFrequencies.put(character, characterFrequencies.getOrDefault(character, 0) + 1);\n    }\n\n    return characterFrequencies;\n  }\n\n  public void updateMaximumFrequencies(\n      HashMap<Character, Integer> frequencies, HashMap<Character, Integer> maximumFrequencies) {\n\n    for (Map.Entry<Character, Integer> frequency : frequencies.entrySet()) {\n      char character = frequency.getKey();\n      int characterFrequency = frequency.getValue();\n\n      if (maximumFrequencies.containsKey(character)) {\n        maximumFrequencies.put(\n            character, Math.max(characterFrequency, maximumFrequencies.get(character)));\n      } else {\n        maximumFrequencies.put(character, characterFrequency);\n      }\n    }\n  }\n\n  public char[] makeArrayFromCharacterFrequencies(\n      HashMap<Character, Integer> characterFrequencies) {\n    ArrayList<Character> characters = new ArrayList<Character>();\n\n    for (Map.Entry<Character, Integer> frequency : characterFrequencies.entrySet()) {\n      char character = frequency.getKey();\n      int characterFrequency = frequency.getValue();\n\n      for (int idx = 0; idx < characterFrequency; idx++) {\n        characters.add(character);\n      }\n    }\n\n    char[] charactersArray = new char[characters.size()];\n    for (int idx = 0; idx < characters.size(); idx++) {\n      charactersArray[idx] = characters.get(idx);\n    }\n\n    return charactersArray;\n  }\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n\n  @Test\n  public void TestCase1() {\n    String[] words = new String[] {\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\"};\n    char[] expected = new char[] {'t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'};\n    var actual = new Program().minimumCharactersForWords(words);\n    assert (expected == actual);\n  }\n}\n",
          unitTests:
            "import java.util.*;\n\nclass ProgramTest {\n\n  @Test\n  public void TestCase1() {\n    String[] words = new String[] {\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\"};\n    char[] expected = new char[] {'t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'};\n    var actual = new Program().minimumCharactersForWords(words);\n    assert (expected == actual);\n  }\n}\n",
        },
        javascript: {
          language: "javascript",
          solutionsDisabled: false,
          startingCode:
            "function minimumCharactersForWords(words) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.minimumCharactersForWords = minimumCharactersForWords;\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n// O(n * l) time | O(c) space - where n is the number of words,\n// l is the length of the longest word, and c is the number of\n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nfunction minimumCharactersForWords(words) {\n  const maximumCharacterFrequencies = {};\n\n  for (const word of words) {\n    const characterFrequencies = countCharacterFrequencies(word);\n    updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies);\n  }\n\n  return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies);\n}\n\nfunction countCharacterFrequencies(string) {\n  const characterFrequencies = {};\n\n  for (const character of string) {\n    if (!(character in characterFrequencies)) {\n      characterFrequencies[character] = 0;\n    }\n\n    characterFrequencies[character] += 1;\n  }\n\n  return characterFrequencies;\n}\n\nfunction updateMaximumFrequencies(frequencies, maximumFrequencies) {\n  for (const character in frequencies) {\n    const frequency = frequencies[character];\n\n    if (character in maximumFrequencies) {\n      maximumFrequencies[character] = Math.max(frequency, maximumFrequencies[character]);\n    } else {\n      maximumFrequencies[character] = frequency;\n    }\n  }\n}\n\nfunction makeArrayFromCharacterFrequencies(characterFrequencies) {\n  const characters = [];\n\n  for (const character in characterFrequencies) {\n    const frequency = characterFrequencies[character];\n\n    for (let idx = 0; idx < frequency; idx++) {\n      characters.push(character);\n    }\n  }\n\n  return characters;\n}\n\n// Do not edit the line below.\nexports.minimumCharactersForWords = minimumCharactersForWords;\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
        kotlin: {
          language: "kotlin",
          solutionsDisabled: false,
          startingCode:
            "package com.algoexpert.program\n\nfun minimumCharactersForWords(words: List<String>): List<Char> {\n    // Write your code here.\n    return listOf()\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\npackage com.algoexpert.program\n\nimport kotlin.math.max\n\n// O(n * l) time | O(c) space - where n is the number of words, \n// l is the length of the longest word, and c is the number of \n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nfun minimumCharactersForWords(words: List<String>): List<Char> {\n    val maximumCharacterFrequencies = mutableMapOf<Char, Int>()\n\n    for (word in words) {\n        val characterFrequencies = countCharacterFrequencies(word)\n        updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies)\n    }\n\n    return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies)\n}\n\nfun countCharacterFrequencies(string: String): Map<Char, Int> {\n    val characterFrequencies = mutableMapOf<Char, Int>()\n    for (character in string) {\n        characterFrequencies[character] = characterFrequencies.getOrDefault(character, 0) + 1\n    }\n\n    return characterFrequencies\n}\n\nfun updateMaximumFrequencies(frequencies: Map<Char, Int>, maximumFrequencies: MutableMap<Char, Int>) {\n    for ((character, frequency) in frequencies) {\n        if (character in maximumFrequencies) {\n            maximumFrequencies[character] = max(frequency, maximumFrequencies[character]!!)\n        } else {\n            maximumFrequencies[character] = frequency\n        }\n    }\n}\n\nfun makeArrayFromCharacterFrequencies(characterFrequencies: Map<Char, Int>): List<Char> {\n    val characters = mutableListOf<Char>()\n\n    for ((character, frequency) in characterFrequencies) {\n        for (i in 0 until frequency) {\n            characters.add(character)\n        }\n    }\n\n    return characters\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport com.algoexpert.program.minimumCharactersForWords\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\")\n        val expected = listOf('t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!')\n        val output = minimumCharactersForWords(input)\n        assert(expected.sorted() == output.sorted())\n    }\n}\n",
          unitTests:
            "import com.algoexpert.program.minimumCharactersForWords\n\nclass ProgramTest {\n    @Test\n    fun TestCase1() {\n        val input = listOf(\"this\", \"that\", \"did\", \"deed\", \"them!\", \"a\")\n        val expected = listOf('t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!')\n        val output = minimumCharactersForWords(input)\n        assert(expected.sorted() == output.sorted())\n    }\n}\n",
        },
        python: {
          language: "python",
          solutionsDisabled: false,
          startingCode:
            "def minimumCharactersForWords(words):\n    # Write your code here.\n    return []\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\n# O(n * l) time | O(c) space - where n is the number of words,\n# l is the length of the longest word, and c is the number of\n# unique characters across all words\n# See notes under video explanation for details about the space complexity.\ndef minimumCharactersForWords(words):\n    maximumCharacterFrequencies = {}\n\n    for word in words:\n        characterFrequencies = countCharacterFrequencies(word)\n        updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies)\n\n    return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies)\n\n\ndef countCharacterFrequencies(string):\n    characterFrequencies = {}\n\n    for character in string:\n        if character not in characterFrequencies:\n            characterFrequencies[character] = 0\n\n        characterFrequencies[character] += 1\n\n    return characterFrequencies\n\n\ndef updateMaximumFrequencies(frequencies, maximumFrequencies):\n    for character in frequencies:\n        frequency = frequencies[character]\n\n        if character in maximumFrequencies:\n            maximumFrequencies[character] = max(frequency, maximumFrequencies[character])\n        else:\n            maximumFrequencies[character] = frequency\n\n\ndef makeArrayFromCharacterFrequencies(characterFrequencies):\n    characters = []\n\n    for character in characterFrequencies:\n        frequency = characterFrequencies[character]\n\n        for _ in range(frequency):\n            characters.append(character)\n\n    return characters\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = ["this", "that", "did", "deed", "them!", "a"]\n        expected = ["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n        actual = program.minimumCharactersForWords(input)\n        self.assertEqual(actual, expected)\n',
          unitTests:
            'import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        input = ["this", "that", "did", "deed", "them!", "a"]\n        expected = ["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n        actual = program.minimumCharactersForWords(input)\n        self.assertEqual(actual, expected)\n',
        },
        ruby: {
          language: "ruby",
          solutionsDisabled: false,
          startingCode:
            "class Program\n  def minimumCharactersForWords(words)\n    # Write your code here.\n    return []\n  end\nend\n",
          solutions: [
            "# Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program\n  def minimumCharactersForWords(words)\n    # Write your code here.\n    return []\n  end\nend\n",
          ],
          sandboxCode:
            '# This file is initialized with a code version of this\n# question\'s sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nrequire "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumCharactersForWords\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
          unitTests:
            'require "./program.rb"\n\nclass TestSuite\n  include Assertions\n\n  def test_1\n    # inputs = ...\n    # output = Program.new.minimumCharactersForWords\n    # expected = ...\n    # assertEqual(expected, output)\n  end\nend\n',
        },
        swift: {
          language: "swift",
          solutionsDisabled: false,
          startingCode:
            "class Program {\n  func minimumCharactersForWords(_ words: [String]) -> [String] {\n    // Write your code here.\n    return [String]()\n  }\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\nclass Program {\n  // O(n * l) time | O(c) space - where n is the number of words,\n  // l is the length of the longest word, and c is the number of\n  // unique characters across all words\n  // See notes under video explanation for details about the space complexity.\n  func minimumCharactersForWords(_ words: [String]) -> [String] {\n    var maximumCharacterFrequencies = [Character: Int]()\n\n    for word in words {\n      let characterFrequencies = countCharacterFrequencies(word)\n      updateMaximumFrequencies(characterFrequencies, &maximumCharacterFrequencies)\n    }\n\n    return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies)\n  }\n\n  func countCharacterFrequencies(_ str: String) -> [Character: Int] {\n    var characterFrequencies = [Character: Int]()\n    for character in str {\n      if characterFrequencies[character] == nil {\n        characterFrequencies[character] = 0\n      }\n      characterFrequencies[character]! += 1\n    }\n    return characterFrequencies\n  }\n\n  func updateMaximumFrequencies(_ frequencies: [Character: Int], _ maximumFrequencies: inout [Character: Int]) {\n    for (character, frequency) in frequencies {\n      if maximumFrequencies[character] != nil {\n        maximumFrequencies[character] = max(frequency, maximumFrequencies[character]!)\n      } else {\n        maximumFrequencies[character] = frequency\n      }\n    }\n  }\n\n  func makeArrayFromCharacterFrequencies(_ characterFrequencies: [Character: Int]) -> [String] {\n    var characters = [String]()\n    for (character, frequency) in characterFrequencies {\n      for i in stride(from: 0, to: frequency, by: 1) {\n        characters.append(String(character))\n      }\n    }\n    return characters\n  }\n}\n",
          ],
          sandboxCode:
            '// This file is initialized with a code version of this\n// question\'s sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = ["this", "that", "did", "deed", "them!", "a"]\n      var expected = ["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n      var actual = Program().minimumCharactersForWords(input)\n      try assertEqual(expected.sorted(), actual.sorted())\n    }\n  }\n}\n',
          unitTests:
            'class ProgramTest: TestSuite {\n  func test() {\n    runTest("Test Case 1") { () throws -> Void in\n      var input = ["this", "that", "did", "deed", "them!", "a"]\n      var expected = ["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n      var actual = Program().minimumCharactersForWords(input)\n      try assertEqual(expected.sorted(), actual.sorted())\n    }\n  }\n}\n',
        },
        typescript: {
          language: "typescript",
          solutionsDisabled: false,
          startingCode:
            "export function minimumCharactersForWords(words: string[]) {\n  // Write your code here.\n  return [];\n}\n",
          solutions: [
            "// Copyright © 2022 AlgoExpert LLC. All rights reserved.\n\ninterface CharacterFrequencies {\n  [character: string]: number;\n}\n\n// O(n * l) time | O(c) space - where n is the number of words,\n// l is the length of the longest word, and c is the number of\n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nexport function minimumCharactersForWords(words: string[]) {\n  const maximumCharacterFrequencies: CharacterFrequencies = {};\n\n  for (const word of words) {\n    const characterFrequencies = countCharacterFrequencies(word);\n    updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies);\n  }\n\n  return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies);\n}\n\nfunction countCharacterFrequencies(string: string) {\n  const characterFrequencies: CharacterFrequencies = {};\n\n  for (const character of string) {\n    if (!(character in characterFrequencies)) {\n      characterFrequencies[character] = 0;\n    }\n\n    characterFrequencies[character] += 1;\n  }\n\n  return characterFrequencies;\n}\n\nfunction updateMaximumFrequencies(frequencies: CharacterFrequencies, maximumFrequencies: CharacterFrequencies) {\n  for (const character in frequencies) {\n    const frequency = frequencies[character];\n\n    if (character in maximumFrequencies) {\n      maximumFrequencies[character] = Math.max(frequency, maximumFrequencies[character]);\n    } else {\n      maximumFrequencies[character] = frequency;\n    }\n  }\n}\n\nfunction makeArrayFromCharacterFrequencies(characterFrequencies: CharacterFrequencies) {\n  const characters: string[] = [];\n\n  for (const character in characterFrequencies) {\n    const frequency = characterFrequencies[character];\n\n    for (let idx = 0; idx < frequency; idx++) {\n      characters.push(character);\n    }\n  }\n\n  return characters;\n}\n",
          ],
          sandboxCode:
            "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
          unitTests:
            "import * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
        },
      },
      customInputVars: [
        {
          name: "words",
          example: ["this", "that", "did", "deed", "them!", "a"],
          schema: {
            items: {
              type: "string",
            },
            type: "array",
          },
        },
      ],
      tests: [
        {
          words: ["this", "that", "did", "deed", "them!", "a"],
        },
        {
          words: ["a", "abc", "ab", "boo"],
        },
        {
          words: ["a"],
        },
        {
          words: ["abc", "ab", "b", "bac", "c"],
        },
        {
          words: ["!!!2", "234", "222", "432"],
        },
        {
          words: [
            "this",
            "that",
            "they",
            "them",
            "their",
            "there",
            "time",
            "is",
          ],
        },
        {
          words: ["tim", "is", "great"],
        },
        {
          words: ["abc", "bavcc", "aaaa", "cde", "efg", "gead"],
        },
        {
          words: ["a", "a", "a"],
        },
        {
          words: [
            "them",
            "they",
            "that",
            "that",
            "yes",
            "yo",
            "no",
            "boo",
            "you",
            "okay",
            "too",
          ],
        },
        {
          words: ["cta", "cat", "tca", "tac", "a", "c", "t"],
        },
        {
          words: ["my", "coding", "skills", "are", "great"],
        },
        {
          words: [],
        },
        {
          words: ["168712hn3;nlsdjhahjdksaxa097918@#$RT%T^&*()_"],
        },
        {
          words: ["cat", "cAt", "tAc", "Act", "Cat"],
        },
        {
          words: ["Abc", "baVcc", "aaaa", "cdeE", "efg", "gead"],
        },
        {
          words: [
            "mississippi",
            "piper",
            "icing",
            "ice",
            "pickle",
            "piping",
            "pie",
            "pi",
            "sassy",
            "serpent",
            "python",
            "ascii",
            "sister",
            "mister",
          ],
        },
      ],
      jsonTests: [
        {
          words: ["this", "that", "did", "deed", "them!", "a"],
        },
        {
          words: ["a", "abc", "ab", "boo"],
        },
        {
          words: ["a"],
        },
        {
          words: ["abc", "ab", "b", "bac", "c"],
        },
        {
          words: ["!!!2", "234", "222", "432"],
        },
        {
          words: [
            "this",
            "that",
            "they",
            "them",
            "their",
            "there",
            "time",
            "is",
          ],
        },
        {
          words: ["tim", "is", "great"],
        },
        {
          words: ["abc", "bavcc", "aaaa", "cde", "efg", "gead"],
        },
        {
          words: ["a", "a", "a"],
        },
        {
          words: [
            "them",
            "they",
            "that",
            "that",
            "yes",
            "yo",
            "no",
            "boo",
            "you",
            "okay",
            "too",
          ],
        },
        {
          words: ["cta", "cat", "tca", "tac", "a", "c", "t"],
        },
        {
          words: ["my", "coding", "skills", "are", "great"],
        },
        {
          words: [],
        },
        {
          words: ["168712hn3;nlsdjhahjdksaxa097918@#$RT%T^&*()_"],
        },
        {
          words: ["cat", "cAt", "tAc", "Act", "Cat"],
        },
        {
          words: ["Abc", "baVcc", "aaaa", "cdeE", "efg", "gead"],
        },
        {
          words: [
            "mississippi",
            "piper",
            "icing",
            "ice",
            "pickle",
            "piping",
            "pie",
            "pi",
            "sassy",
            "serpent",
            "python",
            "ascii",
            "sister",
            "mister",
          ],
        },
      ],
      changelog: [],
      id: 40,
    },
  ],
};

module.exports = { data };
